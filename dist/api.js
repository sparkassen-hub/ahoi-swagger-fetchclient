"use strict";
/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 *
 * [AHOI cookbook](/ahoi/docs/cookbook/index.html)  [Data Privacy](/sandboxmanager/#/privacy)  [Terms of Service](/sandboxmanager/#/terms)  [Imprint](https://sparkassen-hub.com/impressum/)  &copy; 2016&dash;2017 Starfinanz - Ein Unternehmen der Finanz Informatik
 *
 * OpenAPI spec version: 2.1.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var url = require("url");
var portableFetch = require("portable-fetch");
var BASE_PATH = "https://localhost/ahoi/api/v2".replace(/\/+$/, "");
/**
 *
 * @export
 */
exports.COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};
/**
 *
 * @export
 * @class BaseAPI
 */
var BaseAPI = /** @class */ (function () {
    function BaseAPI(configuration, basePath, fetch) {
        if (basePath === void 0) { basePath = BASE_PATH; }
        if (fetch === void 0) { fetch = portableFetch; }
        this.basePath = basePath;
        this.fetch = fetch;
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
    return BaseAPI;
}());
exports.BaseAPI = BaseAPI;
;
/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
var RequiredError = /** @class */ (function (_super) {
    __extends(RequiredError, _super);
    function RequiredError(field, msg) {
        var _this = _super.call(this, msg) || this;
        _this.field = field;
        return _this;
    }
    return RequiredError;
}(Error));
exports.RequiredError = RequiredError;
/**
 * @export
 * @namespace Access
 */
var Access;
(function (Access) {
    /**
     * @export
     * @enum {string}
     */
    var ValidationStateEnum;
    (function (ValidationStateEnum) {
        ValidationStateEnum[ValidationStateEnum["OK"] = 'OK'] = "OK";
        ValidationStateEnum[ValidationStateEnum["ACCESSLOCKED"] = 'ACCESS_LOCKED'] = "ACCESSLOCKED";
        ValidationStateEnum[ValidationStateEnum["ACCESSWRONG"] = 'ACCESS_WRONG'] = "ACCESSWRONG";
    })(ValidationStateEnum = Access.ValidationStateEnum || (Access.ValidationStateEnum = {}));
})(Access = exports.Access || (exports.Access = {}));
/**
 * @export
 * @namespace Account
 */
var Account;
(function (Account) {
    /**
     * @export
     * @enum {string}
     */
    var KindEnum;
    (function (KindEnum) {
        KindEnum[KindEnum["GIRO"] = 'GIRO'] = "GIRO";
        KindEnum[KindEnum["SPAR"] = 'SPAR'] = "SPAR";
        KindEnum[KindEnum["FESTGELD"] = 'FESTGELD'] = "FESTGELD";
        KindEnum[KindEnum["DEPOT"] = 'DEPOT'] = "DEPOT";
        KindEnum[KindEnum["DARLEHEN"] = 'DARLEHEN'] = "DARLEHEN";
        KindEnum[KindEnum["KREDITKARTE"] = 'KREDITKARTE'] = "KREDITKARTE";
        KindEnum[KindEnum["BAUSPAR"] = 'BAUSPAR'] = "BAUSPAR";
        KindEnum[KindEnum["VLSPAR"] = 'VL_SPAR'] = "VLSPAR";
        KindEnum[KindEnum["VLBAUSPAR"] = 'VL_BAUSPAR'] = "VLBAUSPAR";
        KindEnum[KindEnum["VLWERTPAPIERSPARVERTRAG"] = 'VL_WERTPAPIERSPARVERTRAG'] = "VLWERTPAPIERSPARVERTRAG";
        KindEnum[KindEnum["XXX"] = 'XXX'] = "XXX";
    })(KindEnum = Account.KindEnum || (Account.KindEnum = {}));
})(Account = exports.Account || (exports.Account = {}));
/**
 * @export
 * @namespace Contract
 */
var Contract;
(function (Contract) {
    /**
     * @export
     * @enum {string}
     */
    var PaymentIntervalEnum;
    (function (PaymentIntervalEnum) {
        PaymentIntervalEnum[PaymentIntervalEnum["WEEKLY"] = 'WEEKLY'] = "WEEKLY";
        PaymentIntervalEnum[PaymentIntervalEnum["BIWEEKLY"] = 'BIWEEKLY'] = "BIWEEKLY";
        PaymentIntervalEnum[PaymentIntervalEnum["MONTHLY"] = 'MONTHLY'] = "MONTHLY";
        PaymentIntervalEnum[PaymentIntervalEnum["QUARTERLY"] = 'QUARTERLY'] = "QUARTERLY";
        PaymentIntervalEnum[PaymentIntervalEnum["SEMIANNUAL"] = 'SEMIANNUAL'] = "SEMIANNUAL";
        PaymentIntervalEnum[PaymentIntervalEnum["ANNUAL"] = 'ANNUAL'] = "ANNUAL";
        PaymentIntervalEnum[PaymentIntervalEnum["BIENNIAL"] = 'BIENNIAL'] = "BIENNIAL";
    })(PaymentIntervalEnum = Contract.PaymentIntervalEnum || (Contract.PaymentIntervalEnum = {}));
    /**
     * @export
     * @enum {string}
     */
    var TypeEnum;
    (function (TypeEnum) {
        TypeEnum[TypeEnum["SUBSCRIPTION"] = 'SUBSCRIPTION'] = "SUBSCRIPTION";
        TypeEnum[TypeEnum["RENT"] = 'RENT'] = "RENT";
        TypeEnum[TypeEnum["RENTREVENUES"] = 'RENT_REVENUES'] = "RENTREVENUES";
        TypeEnum[TypeEnum["SALARY"] = 'SALARY'] = "SALARY";
        TypeEnum[TypeEnum["SALARYSIDEJOB"] = 'SALARY_SIDE_JOB'] = "SALARYSIDEJOB";
        TypeEnum[TypeEnum["PRIVATEPENSION"] = 'PRIVATE_PENSION'] = "PRIVATEPENSION";
        TypeEnum[TypeEnum["PENSION"] = 'PENSION'] = "PENSION";
        TypeEnum[TypeEnum["RIESTERRETIREMENTPLANPAYMENTS"] = 'RIESTER_RETIREMENT_PLAN_PAYMENTS'] = "RIESTERRETIREMENTPLANPAYMENTS";
        TypeEnum[TypeEnum["RIESTERRETIREMENTPLANPAYOUTS"] = 'RIESTER_RETIREMENT_PLAN_PAYOUTS'] = "RIESTERRETIREMENTPLANPAYOUTS";
    })(TypeEnum = Contract.TypeEnum || (Contract.TypeEnum = {}));
})(Contract = exports.Contract || (exports.Contract = {}));
/**
 * @export
 * @namespace InputFieldDescription
 */
var InputFieldDescription;
(function (InputFieldDescription) {
    /**
     * @export
     * @enum {string}
     */
    var IdEnum;
    (function (IdEnum) {
        IdEnum[IdEnum["USERNAME"] = 'USERNAME'] = "USERNAME";
        IdEnum[IdEnum["CUSTOMERNUMBER"] = 'CUSTOMERNUMBER'] = "CUSTOMERNUMBER";
        IdEnum[IdEnum["PIN"] = 'PIN'] = "PIN";
        IdEnum[IdEnum["TAN"] = 'TAN'] = "TAN";
    })(IdEnum = InputFieldDescription.IdEnum || (InputFieldDescription.IdEnum = {}));
    /**
     * @export
     * @enum {string}
     */
    var FormatEnum;
    (function (FormatEnum) {
        FormatEnum[FormatEnum["UNSPECIFIED"] = 'UNSPECIFIED'] = "UNSPECIFIED";
        FormatEnum[FormatEnum["PROBABLYNUMERIC"] = 'PROBABLYNUMERIC'] = "PROBABLYNUMERIC";
        FormatEnum[FormatEnum["DEFINITELYNUMERIC"] = 'DEFINITELYNUMERIC'] = "DEFINITELYNUMERIC";
        FormatEnum[FormatEnum["PROBABLYALPHANUMERIC"] = 'PROBABLYALPHANUMERIC'] = "PROBABLYALPHANUMERIC";
        FormatEnum[FormatEnum["DEFINITELYALPHANUMERIC"] = 'DEFINITELYALPHANUMERIC'] = "DEFINITELYALPHANUMERIC";
    })(FormatEnum = InputFieldDescription.FormatEnum || (InputFieldDescription.FormatEnum = {}));
})(InputFieldDescription = exports.InputFieldDescription || (exports.InputFieldDescription = {}));
/**
 * @export
 * @namespace Security
 */
var Security;
(function (Security) {
    /**
     * @export
     * @enum {string}
     */
    var PriceSourceEnum;
    (function (PriceSourceEnum) {
        PriceSourceEnum[PriceSourceEnum["LMAR"] = 'LMAR'] = "LMAR";
        PriceSourceEnum[PriceSourceEnum["THEO"] = 'THEO'] = "THEO";
        PriceSourceEnum[PriceSourceEnum["VEND"] = 'VEND'] = "VEND";
    })(PriceSourceEnum = Security.PriceSourceEnum || (Security.PriceSourceEnum = {}));
    /**
     * @export
     * @enum {string}
     */
    var PriceQualifierEnum;
    (function (PriceQualifierEnum) {
        PriceQualifierEnum[PriceQualifierEnum["MRKT"] = 'MRKT'] = "MRKT";
        PriceQualifierEnum[PriceQualifierEnum["INDC"] = 'INDC'] = "INDC";
    })(PriceQualifierEnum = Security.PriceQualifierEnum || (Security.PriceQualifierEnum = {}));
})(Security = exports.Security || (exports.Security = {}));
/**
 * @export
 * @namespace Task
 */
var Task;
(function (Task) {
    /**
     * @export
     * @enum {string}
     */
    var StateEnum;
    (function (StateEnum) {
        StateEnum[StateEnum["UNKNOWN"] = 'UNKNOWN'] = "UNKNOWN";
        StateEnum[StateEnum["INITIAL"] = 'INITIAL'] = "INITIAL";
        StateEnum[StateEnum["DONE"] = 'DONE'] = "DONE";
        StateEnum[StateEnum["FAILED"] = 'FAILED'] = "FAILED";
        StateEnum[StateEnum["AUTHORIZATIONPENDING"] = 'AUTHORIZATION_PENDING'] = "AUTHORIZATIONPENDING";
        StateEnum[StateEnum["AUTHORIZATIONWRONG"] = 'AUTHORIZATION_WRONG'] = "AUTHORIZATIONWRONG";
    })(StateEnum = Task.StateEnum || (Task.StateEnum = {}));
})(Task = exports.Task || (exports.Task = {}));
/**
 * @export
 * @namespace TransactionPattern
 */
var TransactionPattern;
(function (TransactionPattern) {
    /**
     * @export
     * @enum {string}
     */
    var StateEnum;
    (function (StateEnum) {
        StateEnum[StateEnum["INACTIVE"] = 'INACTIVE'] = "INACTIVE";
        StateEnum[StateEnum["ACTIVE"] = 'ACTIVE'] = "ACTIVE";
    })(StateEnum = TransactionPattern.StateEnum || (TransactionPattern.StateEnum = {}));
    /**
     * @export
     * @enum {string}
     */
    var CycleEnum;
    (function (CycleEnum) {
        CycleEnum[CycleEnum["MONTHLY"] = 'MONTHLY'] = "MONTHLY";
        CycleEnum[CycleEnum["QUARTERLY"] = 'QUARTERLY'] = "QUARTERLY";
        CycleEnum[CycleEnum["SEMIANNUALLY"] = 'SEMI_ANNUALLY'] = "SEMIANNUALLY";
        CycleEnum[CycleEnum["ANNUALLY"] = 'ANNUALLY'] = "ANNUALLY";
    })(CycleEnum = TransactionPattern.CycleEnum || (TransactionPattern.CycleEnum = {}));
    /**
     * @export
     * @enum {string}
     */
    var OriginEnum;
    (function (OriginEnum) {
        OriginEnum[OriginEnum["FINDER"] = 'FINDER'] = "FINDER";
        OriginEnum[OriginEnum["MANUAL"] = 'MANUAL'] = "MANUAL";
    })(OriginEnum = TransactionPattern.OriginEnum || (TransactionPattern.OriginEnum = {}));
})(TransactionPattern = exports.TransactionPattern || (exports.TransactionPattern = {}));
/**
 * @export
 * @namespace TanChallenge
 */
var TanChallenge;
(function (TanChallenge) {
    /**
     * @export
     * @enum {string}
     */
    var ChallengeTypeEnum;
    (function (ChallengeTypeEnum) {
        ChallengeTypeEnum[ChallengeTypeEnum["UNKNOWN"] = 'UNKNOWN'] = "UNKNOWN";
        ChallengeTypeEnum[ChallengeTypeEnum["ITAN"] = 'ITAN'] = "ITAN";
        ChallengeTypeEnum[ChallengeTypeEnum["CHIPTAN"] = 'CHIPTAN'] = "CHIPTAN";
        ChallengeTypeEnum[ChallengeTypeEnum["OPTICALV3"] = 'OPTICAL_V3'] = "OPTICALV3";
        ChallengeTypeEnum[ChallengeTypeEnum["OPTICALV4"] = 'OPTICAL_V4'] = "OPTICALV4";
        ChallengeTypeEnum[ChallengeTypeEnum["PHOTOTAN"] = 'PHOTOTAN'] = "PHOTOTAN";
    })(ChallengeTypeEnum = TanChallenge.ChallengeTypeEnum || (TanChallenge.ChallengeTypeEnum = {}));
})(TanChallenge = exports.TanChallenge || (exports.TanChallenge = {}));
/**
 * AccessApi - fetch parameter creator
 * @export
 */
exports.AccessApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Delete access with **accessId** and all related accounts.
         * @summary Delete access
         * @param {string} accessId The **id** for the access to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccess: function (accessId, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'accessId' is not null or undefined
            if (accessId === null || accessId === undefined) {
                throw new RequiredError('accessId', 'Required parameter accessId was null or undefined when calling deleteAccess.');
            }
            var localVarPath = "/accesses/{accessId}"
                .replace("{" + "accessId" + "}", encodeURIComponent(String(accessId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                var localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth2", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the access with **accessId**. The retrieved object does not contain sensitive information such as the PIN.
         * @summary Get access
         * @param {string} accessId The **id** for the access to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccess: function (accessId, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'accessId' is not null or undefined
            if (accessId === null || accessId === undefined) {
                throw new RequiredError('accessId', 'Required parameter accessId was null or undefined when calling getAccess.');
            }
            var localVarPath = "/accesses/{accessId}"
                .replace("{" + "accessId" + "}", encodeURIComponent(String(accessId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                var localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth2", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all registered accesses for the authenticated user. Confidential information like the PIN will not be returned.
         * @summary List accesses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccesses: function (options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/accesses";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                var localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth2", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new access and setup all associated accounts and transactions. This will also trigger the creation of monthly transaction summaries, the analysis of all accounts for recurring transactions, and the calculation of the balance forecast.   If the credentials were invalid, the validation state is set accordingly.    It is possible to have multiple accesses for one user.
         * @summary Create a new access
         * @param {Access} accessDto A valid BankAccess object containing the required             **accessFields** as indicated by the provider object and the             **providerId**.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAccess: function (accessDto, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'accessDto' is not null or undefined
            if (accessDto === null || accessDto === undefined) {
                throw new RequiredError('accessDto', 'Required parameter accessDto was null or undefined when calling postAccess.');
            }
            var localVarPath = "/accesses";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                var localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth2", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = ("Access" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(accessDto || {}) : (accessDto || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the access credentials in **accessFields**. If the access does not exist, the **accessId** does not match the **id** in **accessDto** or the **providerId** is not the same, the status code 404 is returned. If another access with the same login  data already exists, the status code 409 is returned.  The updated access is validated by setting up an account. The status code 200 does not imply that the credentials are correct. To check this the client should obtain access.
         * @summary Update access
         * @param {string} accessId The **id** for the access to update.
         * @param {Access} accessDto The Access object that contains the changed credentials in             **accessFields**. Other fields cannot be edited.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putAccess: function (accessId, accessDto, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'accessId' is not null or undefined
            if (accessId === null || accessId === undefined) {
                throw new RequiredError('accessId', 'Required parameter accessId was null or undefined when calling putAccess.');
            }
            // verify required parameter 'accessDto' is not null or undefined
            if (accessDto === null || accessDto === undefined) {
                throw new RequiredError('accessDto', 'Required parameter accessDto was null or undefined when calling putAccess.');
            }
            var localVarPath = "/accesses/{accessId}"
                .replace("{" + "accessId" + "}", encodeURIComponent(String(accessId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                var localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth2", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = ("Access" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(accessDto || {}) : (accessDto || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * AccessApi - functional programming interface
 * @export
 */
exports.AccessApiFp = function (configuration) {
    return {
        /**
         * Delete access with **accessId** and all related accounts.
         * @summary Delete access
         * @param {string} accessId The **id** for the access to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccess: function (accessId, options) {
            var localVarFetchArgs = exports.AccessApiFetchParamCreator(configuration).deleteAccess(accessId, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve the access with **accessId**. The retrieved object does not contain sensitive information such as the PIN.
         * @summary Get access
         * @param {string} accessId The **id** for the access to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccess: function (accessId, options) {
            var localVarFetchArgs = exports.AccessApiFetchParamCreator(configuration).getAccess(accessId, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns all registered accesses for the authenticated user. Confidential information like the PIN will not be returned.
         * @summary List accesses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccesses: function (options) {
            var localVarFetchArgs = exports.AccessApiFetchParamCreator(configuration).getAccesses(options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create a new access and setup all associated accounts and transactions. This will also trigger the creation of monthly transaction summaries, the analysis of all accounts for recurring transactions, and the calculation of the balance forecast.   If the credentials were invalid, the validation state is set accordingly.    It is possible to have multiple accesses for one user.
         * @summary Create a new access
         * @param {Access} accessDto A valid BankAccess object containing the required             **accessFields** as indicated by the provider object and the             **providerId**.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAccess: function (accessDto, options) {
            var localVarFetchArgs = exports.AccessApiFetchParamCreator(configuration).postAccess(accessDto, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update the access credentials in **accessFields**. If the access does not exist, the **accessId** does not match the **id** in **accessDto** or the **providerId** is not the same, the status code 404 is returned. If another access with the same login  data already exists, the status code 409 is returned.  The updated access is validated by setting up an account. The status code 200 does not imply that the credentials are correct. To check this the client should obtain access.
         * @summary Update access
         * @param {string} accessId The **id** for the access to update.
         * @param {Access} accessDto The Access object that contains the changed credentials in             **accessFields**. Other fields cannot be edited.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putAccess: function (accessId, accessDto, options) {
            var localVarFetchArgs = exports.AccessApiFetchParamCreator(configuration).putAccess(accessId, accessDto, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * AccessApi - factory interface
 * @export
 */
exports.AccessApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Delete access with **accessId** and all related accounts.
         * @summary Delete access
         * @param {string} accessId The **id** for the access to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccess: function (accessId, options) {
            return exports.AccessApiFp(configuration).deleteAccess(accessId, options)(fetch, basePath);
        },
        /**
         * Retrieve the access with **accessId**. The retrieved object does not contain sensitive information such as the PIN.
         * @summary Get access
         * @param {string} accessId The **id** for the access to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccess: function (accessId, options) {
            return exports.AccessApiFp(configuration).getAccess(accessId, options)(fetch, basePath);
        },
        /**
         * Returns all registered accesses for the authenticated user. Confidential information like the PIN will not be returned.
         * @summary List accesses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccesses: function (options) {
            return exports.AccessApiFp(configuration).getAccesses(options)(fetch, basePath);
        },
        /**
         * Create a new access and setup all associated accounts and transactions. This will also trigger the creation of monthly transaction summaries, the analysis of all accounts for recurring transactions, and the calculation of the balance forecast.   If the credentials were invalid, the validation state is set accordingly.    It is possible to have multiple accesses for one user.
         * @summary Create a new access
         * @param {Access} accessDto A valid BankAccess object containing the required             **accessFields** as indicated by the provider object and the             **providerId**.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAccess: function (accessDto, options) {
            return exports.AccessApiFp(configuration).postAccess(accessDto, options)(fetch, basePath);
        },
        /**
         * Update the access credentials in **accessFields**. If the access does not exist, the **accessId** does not match the **id** in **accessDto** or the **providerId** is not the same, the status code 404 is returned. If another access with the same login  data already exists, the status code 409 is returned.  The updated access is validated by setting up an account. The status code 200 does not imply that the credentials are correct. To check this the client should obtain access.
         * @summary Update access
         * @param {string} accessId The **id** for the access to update.
         * @param {Access} accessDto The Access object that contains the changed credentials in             **accessFields**. Other fields cannot be edited.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putAccess: function (accessId, accessDto, options) {
            return exports.AccessApiFp(configuration).putAccess(accessId, accessDto, options)(fetch, basePath);
        },
    };
};
/**
 * AccessApi - object-oriented interface
 * @export
 * @class AccessApi
 * @extends {BaseAPI}
 */
var AccessApi = /** @class */ (function (_super) {
    __extends(AccessApi, _super);
    function AccessApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Delete access with **accessId** and all related accounts.
     * @summary Delete access
     * @param {string} accessId The **id** for the access to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessApi
     */
    AccessApi.prototype.deleteAccess = function (accessId, options) {
        return exports.AccessApiFp(this.configuration).deleteAccess(accessId, options)(this.fetch, this.basePath);
    };
    /**
     * Retrieve the access with **accessId**. The retrieved object does not contain sensitive information such as the PIN.
     * @summary Get access
     * @param {string} accessId The **id** for the access to retrieve.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessApi
     */
    AccessApi.prototype.getAccess = function (accessId, options) {
        return exports.AccessApiFp(this.configuration).getAccess(accessId, options)(this.fetch, this.basePath);
    };
    /**
     * Returns all registered accesses for the authenticated user. Confidential information like the PIN will not be returned.
     * @summary List accesses
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessApi
     */
    AccessApi.prototype.getAccesses = function (options) {
        return exports.AccessApiFp(this.configuration).getAccesses(options)(this.fetch, this.basePath);
    };
    /**
     * Create a new access and setup all associated accounts and transactions. This will also trigger the creation of monthly transaction summaries, the analysis of all accounts for recurring transactions, and the calculation of the balance forecast.   If the credentials were invalid, the validation state is set accordingly.    It is possible to have multiple accesses for one user.
     * @summary Create a new access
     * @param {Access} accessDto A valid BankAccess object containing the required             **accessFields** as indicated by the provider object and the             **providerId**.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessApi
     */
    AccessApi.prototype.postAccess = function (accessDto, options) {
        return exports.AccessApiFp(this.configuration).postAccess(accessDto, options)(this.fetch, this.basePath);
    };
    /**
     * Update the access credentials in **accessFields**. If the access does not exist, the **accessId** does not match the **id** in **accessDto** or the **providerId** is not the same, the status code 404 is returned. If another access with the same login  data already exists, the status code 409 is returned.  The updated access is validated by setting up an account. The status code 200 does not imply that the credentials are correct. To check this the client should obtain access.
     * @summary Update access
     * @param {string} accessId The **id** for the access to update.
     * @param {Access} accessDto The Access object that contains the changed credentials in             **accessFields**. Other fields cannot be edited.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessApi
     */
    AccessApi.prototype.putAccess = function (accessId, accessDto, options) {
        return exports.AccessApiFp(this.configuration).putAccess(accessId, accessDto, options)(this.fetch, this.basePath);
    };
    return AccessApi;
}(BaseAPI));
exports.AccessApi = AccessApi;
/**
 * AccountApi - fetch parameter creator
 * @export
 */
exports.AccountApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Delete the account identified by **accountId**.
         * @summary Delete account
         * @param {string} accessId The **accessId** for the account to delete
         * @param {string} accountId The **id** for the account to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccount: function (accessId, accountId, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'accessId' is not null or undefined
            if (accessId === null || accessId === undefined) {
                throw new RequiredError('accessId', 'Required parameter accessId was null or undefined when calling deleteAccount.');
            }
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new RequiredError('accountId', 'Required parameter accountId was null or undefined when calling deleteAccount.');
            }
            var localVarPath = "/accesses/{accessId}/accounts/{accountId}"
                .replace("{" + "accessId" + "}", encodeURIComponent(String(accessId)))
                .replace("{" + "accountId" + "}", encodeURIComponent(String(accountId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                var localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth2", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the account identified by **accountId**.
         * @summary Get account
         * @param {string} accessId The **accessId** for the account to retrieve
         * @param {string} accountId The **id** for the account to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccount: function (accessId, accountId, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'accessId' is not null or undefined
            if (accessId === null || accessId === undefined) {
                throw new RequiredError('accessId', 'Required parameter accessId was null or undefined when calling getAccount.');
            }
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new RequiredError('accountId', 'Required parameter accountId was null or undefined when calling getAccount.');
            }
            var localVarPath = "/accesses/{accessId}/accounts/{accountId}"
                .replace("{" + "accessId" + "}", encodeURIComponent(String(accessId)))
                .replace("{" + "accountId" + "}", encodeURIComponent(String(accountId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                var localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth2", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all accounts for the current user under the **accessId**.
         * @summary List accounts
         * @param {string} accessId The **id** for the access for which to retrieve all accounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccounts: function (accessId, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'accessId' is not null or undefined
            if (accessId === null || accessId === undefined) {
                throw new RequiredError('accessId', 'Required parameter accessId was null or undefined when calling getAccounts.');
            }
            var localVarPath = "/accesses/{accessId}/accounts"
                .replace("{" + "accessId" + "}", encodeURIComponent(String(accessId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                var localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth2", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the account name used in AHOI. Name must be URL encoded.
         * @summary Update account name
         * @param {string} accessId The **accessId** for which the user-defined account name should be altered
         * @param {string} accountId The **id** for which the user-defined account name should be altered
         * @param {string} name The new URL-encoded name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccount: function (accessId, accountId, name, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'accessId' is not null or undefined
            if (accessId === null || accessId === undefined) {
                throw new RequiredError('accessId', 'Required parameter accessId was null or undefined when calling updateAccount.');
            }
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new RequiredError('accountId', 'Required parameter accountId was null or undefined when calling updateAccount.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name', 'Required parameter name was null or undefined when calling updateAccount.');
            }
            var localVarPath = "/accesses/{accessId}/accounts/{accountId}/userdefinedname/{name}"
                .replace("{" + "accessId" + "}", encodeURIComponent(String(accessId)))
                .replace("{" + "accountId" + "}", encodeURIComponent(String(accountId)))
                .replace("{" + "name" + "}", encodeURIComponent(String(name)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                var localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth2", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * AccountApi - functional programming interface
 * @export
 */
exports.AccountApiFp = function (configuration) {
    return {
        /**
         * Delete the account identified by **accountId**.
         * @summary Delete account
         * @param {string} accessId The **accessId** for the account to delete
         * @param {string} accountId The **id** for the account to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccount: function (accessId, accountId, options) {
            var localVarFetchArgs = exports.AccountApiFetchParamCreator(configuration).deleteAccount(accessId, accountId, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns the account identified by **accountId**.
         * @summary Get account
         * @param {string} accessId The **accessId** for the account to retrieve
         * @param {string} accountId The **id** for the account to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccount: function (accessId, accountId, options) {
            var localVarFetchArgs = exports.AccountApiFetchParamCreator(configuration).getAccount(accessId, accountId, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve all accounts for the current user under the **accessId**.
         * @summary List accounts
         * @param {string} accessId The **id** for the access for which to retrieve all accounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccounts: function (accessId, options) {
            var localVarFetchArgs = exports.AccountApiFetchParamCreator(configuration).getAccounts(accessId, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update the account name used in AHOI. Name must be URL encoded.
         * @summary Update account name
         * @param {string} accessId The **accessId** for which the user-defined account name should be altered
         * @param {string} accountId The **id** for which the user-defined account name should be altered
         * @param {string} name The new URL-encoded name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccount: function (accessId, accountId, name, options) {
            var localVarFetchArgs = exports.AccountApiFetchParamCreator(configuration).updateAccount(accessId, accountId, name, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * AccountApi - factory interface
 * @export
 */
exports.AccountApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Delete the account identified by **accountId**.
         * @summary Delete account
         * @param {string} accessId The **accessId** for the account to delete
         * @param {string} accountId The **id** for the account to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccount: function (accessId, accountId, options) {
            return exports.AccountApiFp(configuration).deleteAccount(accessId, accountId, options)(fetch, basePath);
        },
        /**
         * Returns the account identified by **accountId**.
         * @summary Get account
         * @param {string} accessId The **accessId** for the account to retrieve
         * @param {string} accountId The **id** for the account to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccount: function (accessId, accountId, options) {
            return exports.AccountApiFp(configuration).getAccount(accessId, accountId, options)(fetch, basePath);
        },
        /**
         * Retrieve all accounts for the current user under the **accessId**.
         * @summary List accounts
         * @param {string} accessId The **id** for the access for which to retrieve all accounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccounts: function (accessId, options) {
            return exports.AccountApiFp(configuration).getAccounts(accessId, options)(fetch, basePath);
        },
        /**
         * Update the account name used in AHOI. Name must be URL encoded.
         * @summary Update account name
         * @param {string} accessId The **accessId** for which the user-defined account name should be altered
         * @param {string} accountId The **id** for which the user-defined account name should be altered
         * @param {string} name The new URL-encoded name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccount: function (accessId, accountId, name, options) {
            return exports.AccountApiFp(configuration).updateAccount(accessId, accountId, name, options)(fetch, basePath);
        },
    };
};
/**
 * AccountApi - object-oriented interface
 * @export
 * @class AccountApi
 * @extends {BaseAPI}
 */
var AccountApi = /** @class */ (function (_super) {
    __extends(AccountApi, _super);
    function AccountApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Delete the account identified by **accountId**.
     * @summary Delete account
     * @param {string} accessId The **accessId** for the account to delete
     * @param {string} accountId The **id** for the account to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    AccountApi.prototype.deleteAccount = function (accessId, accountId, options) {
        return exports.AccountApiFp(this.configuration).deleteAccount(accessId, accountId, options)(this.fetch, this.basePath);
    };
    /**
     * Returns the account identified by **accountId**.
     * @summary Get account
     * @param {string} accessId The **accessId** for the account to retrieve
     * @param {string} accountId The **id** for the account to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    AccountApi.prototype.getAccount = function (accessId, accountId, options) {
        return exports.AccountApiFp(this.configuration).getAccount(accessId, accountId, options)(this.fetch, this.basePath);
    };
    /**
     * Retrieve all accounts for the current user under the **accessId**.
     * @summary List accounts
     * @param {string} accessId The **id** for the access for which to retrieve all accounts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    AccountApi.prototype.getAccounts = function (accessId, options) {
        return exports.AccountApiFp(this.configuration).getAccounts(accessId, options)(this.fetch, this.basePath);
    };
    /**
     * Update the account name used in AHOI. Name must be URL encoded.
     * @summary Update account name
     * @param {string} accessId The **accessId** for which the user-defined account name should be altered
     * @param {string} accountId The **id** for which the user-defined account name should be altered
     * @param {string} name The new URL-encoded name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    AccountApi.prototype.updateAccount = function (accessId, accountId, name, options) {
        return exports.AccountApiFp(this.configuration).updateAccount(accessId, accountId, name, options)(this.fetch, this.basePath);
    };
    return AccountApi;
}(BaseAPI));
exports.AccountApi = AccountApi;
/**
 * CategoryApi - fetch parameter creator
 * @export
 */
exports.CategoryApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Supported origins are: FINLYTICS
         * @summary Retrieve all categories for given origin.
         * @param {string} origin identifier of a supported origin
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategories: function (origin, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'origin' is not null or undefined
            if (origin === null || origin === undefined) {
                throw new RequiredError('origin', 'Required parameter origin was null or undefined when calling getCategories.');
            }
            var localVarPath = "/categories";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                var localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth2", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (origin !== undefined) {
                localVarQueryParameter['origin'] = origin;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * CategoryApi - functional programming interface
 * @export
 */
exports.CategoryApiFp = function (configuration) {
    return {
        /**
         * Supported origins are: FINLYTICS
         * @summary Retrieve all categories for given origin.
         * @param {string} origin identifier of a supported origin
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategories: function (origin, options) {
            var localVarFetchArgs = exports.CategoryApiFetchParamCreator(configuration).getCategories(origin, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * CategoryApi - factory interface
 * @export
 */
exports.CategoryApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Supported origins are: FINLYTICS
         * @summary Retrieve all categories for given origin.
         * @param {string} origin identifier of a supported origin
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategories: function (origin, options) {
            return exports.CategoryApiFp(configuration).getCategories(origin, options)(fetch, basePath);
        },
    };
};
/**
 * CategoryApi - object-oriented interface
 * @export
 * @class CategoryApi
 * @extends {BaseAPI}
 */
var CategoryApi = /** @class */ (function (_super) {
    __extends(CategoryApi, _super);
    function CategoryApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Supported origins are: FINLYTICS
     * @summary Retrieve all categories for given origin.
     * @param {string} origin identifier of a supported origin
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryApi
     */
    CategoryApi.prototype.getCategories = function (origin, options) {
        return exports.CategoryApiFp(this.configuration).getCategories(origin, options)(this.fetch, this.basePath);
    };
    return CategoryApi;
}(BaseAPI));
exports.CategoryApi = CategoryApi;
/**
 * ContractApi - fetch parameter creator
 * @export
 */
exports.ContractApiFetchParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Fetches contract list of current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContractList: function (options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/contracts";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                var localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth2", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * ContractApi - functional programming interface
 * @export
 */
exports.ContractApiFp = function (configuration) {
    return {
        /**
         *
         * @summary Fetches contract list of current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContractList: function (options) {
            var localVarFetchArgs = exports.ContractApiFetchParamCreator(configuration).getContractList(options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * ContractApi - factory interface
 * @export
 */
exports.ContractApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         *
         * @summary Fetches contract list of current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContractList: function (options) {
            return exports.ContractApiFp(configuration).getContractList(options)(fetch, basePath);
        },
    };
};
/**
 * ContractApi - object-oriented interface
 * @export
 * @class ContractApi
 * @extends {BaseAPI}
 */
var ContractApi = /** @class */ (function (_super) {
    __extends(ContractApi, _super);
    function ContractApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary Fetches contract list of current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractApi
     */
    ContractApi.prototype.getContractList = function (options) {
        return exports.ContractApiFp(this.configuration).getContractList(options)(this.fetch, this.basePath);
    };
    return ContractApi;
}(BaseAPI));
exports.ContractApi = ContractApi;
/**
 * ForecastApi - fetch parameter creator
 * @export
 */
exports.ForecastApiFetchParamCreator = function (configuration) {
    return {
        /**
         * The current month is determined by the latest refresh.
         * @summary Get balance forecast
         * @param {string} accessId The **accessId** for which to retrieve forecasts
         * @param {string} accountId The **accountId** for which to retrieve forecasts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForecast: function (accessId, accountId, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'accessId' is not null or undefined
            if (accessId === null || accessId === undefined) {
                throw new RequiredError('accessId', 'Required parameter accessId was null or undefined when calling getForecast.');
            }
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new RequiredError('accountId', 'Required parameter accountId was null or undefined when calling getForecast.');
            }
            var localVarPath = "/accesses/{accessId}/accounts/{accountId}/forecast"
                .replace("{" + "accessId" + "}", encodeURIComponent(String(accessId)))
                .replace("{" + "accountId" + "}", encodeURIComponent(String(accountId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                var localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth2", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The current  month is determined by latest refresh of transactions. The request  also retrieves the transactions expected to be applied until the  end of the current month.
         * @summary Retrieve balance forecast for the end of the current month.
         * @param {string} accessId The **accessId** for the forecast.
         * @param {string} accountId The **id** for the account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForecastTransactions: function (accessId, accountId, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'accessId' is not null or undefined
            if (accessId === null || accessId === undefined) {
                throw new RequiredError('accessId', 'Required parameter accessId was null or undefined when calling getForecastTransactions.');
            }
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new RequiredError('accountId', 'Required parameter accountId was null or undefined when calling getForecastTransactions.');
            }
            var localVarPath = "/accesses/{accessId}/accounts/{accountId}/forecast/transactions"
                .replace("{" + "accessId" + "}", encodeURIComponent(String(accessId)))
                .replace("{" + "accountId" + "}", encodeURIComponent(String(accountId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                var localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth2", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * ForecastApi - functional programming interface
 * @export
 */
exports.ForecastApiFp = function (configuration) {
    return {
        /**
         * The current month is determined by the latest refresh.
         * @summary Get balance forecast
         * @param {string} accessId The **accessId** for which to retrieve forecasts
         * @param {string} accountId The **accountId** for which to retrieve forecasts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForecast: function (accessId, accountId, options) {
            var localVarFetchArgs = exports.ForecastApiFetchParamCreator(configuration).getForecast(accessId, accountId, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * The current  month is determined by latest refresh of transactions. The request  also retrieves the transactions expected to be applied until the  end of the current month.
         * @summary Retrieve balance forecast for the end of the current month.
         * @param {string} accessId The **accessId** for the forecast.
         * @param {string} accountId The **id** for the account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForecastTransactions: function (accessId, accountId, options) {
            var localVarFetchArgs = exports.ForecastApiFetchParamCreator(configuration).getForecastTransactions(accessId, accountId, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * ForecastApi - factory interface
 * @export
 */
exports.ForecastApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * The current month is determined by the latest refresh.
         * @summary Get balance forecast
         * @param {string} accessId The **accessId** for which to retrieve forecasts
         * @param {string} accountId The **accountId** for which to retrieve forecasts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForecast: function (accessId, accountId, options) {
            return exports.ForecastApiFp(configuration).getForecast(accessId, accountId, options)(fetch, basePath);
        },
        /**
         * The current  month is determined by latest refresh of transactions. The request  also retrieves the transactions expected to be applied until the  end of the current month.
         * @summary Retrieve balance forecast for the end of the current month.
         * @param {string} accessId The **accessId** for the forecast.
         * @param {string} accountId The **id** for the account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForecastTransactions: function (accessId, accountId, options) {
            return exports.ForecastApiFp(configuration).getForecastTransactions(accessId, accountId, options)(fetch, basePath);
        },
    };
};
/**
 * ForecastApi - object-oriented interface
 * @export
 * @class ForecastApi
 * @extends {BaseAPI}
 */
var ForecastApi = /** @class */ (function (_super) {
    __extends(ForecastApi, _super);
    function ForecastApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * The current month is determined by the latest refresh.
     * @summary Get balance forecast
     * @param {string} accessId The **accessId** for which to retrieve forecasts
     * @param {string} accountId The **accountId** for which to retrieve forecasts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ForecastApi
     */
    ForecastApi.prototype.getForecast = function (accessId, accountId, options) {
        return exports.ForecastApiFp(this.configuration).getForecast(accessId, accountId, options)(this.fetch, this.basePath);
    };
    /**
     * The current  month is determined by latest refresh of transactions. The request  also retrieves the transactions expected to be applied until the  end of the current month.
     * @summary Retrieve balance forecast for the end of the current month.
     * @param {string} accessId The **accessId** for the forecast.
     * @param {string} accountId The **id** for the account.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ForecastApi
     */
    ForecastApi.prototype.getForecastTransactions = function (accessId, accountId, options) {
        return exports.ForecastApiFp(this.configuration).getForecastTransactions(accessId, accountId, options)(this.fetch, this.basePath);
    };
    return ForecastApi;
}(BaseAPI));
exports.ForecastApi = ForecastApi;
/**
 * ProviderApi - fetch parameter creator
 * @export
 */
exports.ProviderApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Retrieve a single provider identified by **providerId**.
         * @summary Get provider
         * @param {string} providerId The **providerId** to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProvider: function (providerId, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'providerId' is not null or undefined
            if (providerId === null || providerId === undefined) {
                throw new RequiredError('providerId', 'Required parameter providerId was null or undefined when calling getProvider.');
            }
            var localVarPath = "/providers/{providerId}"
                .replace("{" + "providerId" + "}", encodeURIComponent(String(providerId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                var localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth2", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of bank providers. A provider-**id** is necessary to create an _access_. To retrieve the necessary access fields, you need to query the specific `provider/{providerId}`. For performance reasons they are kept separate.
         * @summary List bank providers
         * @param {string} [bankCode] Optional — if length &#x3D; 8, the response will also contain data describing             the fields required for account setup
         * @param {boolean} [supported] Optional — response should only contain providers supported for account             setup via this API
         * @param {string} [query] Optional — search parameters for BankCode, BIC, Location, Name. Will be ignored             if the bankCode query parameter is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProviders: function (bankCode, supported, query, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/providers";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                var localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth2", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (bankCode !== undefined) {
                localVarQueryParameter['bankCode'] = bankCode;
            }
            if (supported !== undefined) {
                localVarQueryParameter['supported'] = supported;
            }
            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * ProviderApi - functional programming interface
 * @export
 */
exports.ProviderApiFp = function (configuration) {
    return {
        /**
         * Retrieve a single provider identified by **providerId**.
         * @summary Get provider
         * @param {string} providerId The **providerId** to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProvider: function (providerId, options) {
            var localVarFetchArgs = exports.ProviderApiFetchParamCreator(configuration).getProvider(providerId, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve a list of bank providers. A provider-**id** is necessary to create an _access_. To retrieve the necessary access fields, you need to query the specific `provider/{providerId}`. For performance reasons they are kept separate.
         * @summary List bank providers
         * @param {string} [bankCode] Optional — if length &#x3D; 8, the response will also contain data describing             the fields required for account setup
         * @param {boolean} [supported] Optional — response should only contain providers supported for account             setup via this API
         * @param {string} [query] Optional — search parameters for BankCode, BIC, Location, Name. Will be ignored             if the bankCode query parameter is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProviders: function (bankCode, supported, query, options) {
            var localVarFetchArgs = exports.ProviderApiFetchParamCreator(configuration).getProviders(bankCode, supported, query, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * ProviderApi - factory interface
 * @export
 */
exports.ProviderApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Retrieve a single provider identified by **providerId**.
         * @summary Get provider
         * @param {string} providerId The **providerId** to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProvider: function (providerId, options) {
            return exports.ProviderApiFp(configuration).getProvider(providerId, options)(fetch, basePath);
        },
        /**
         * Retrieve a list of bank providers. A provider-**id** is necessary to create an _access_. To retrieve the necessary access fields, you need to query the specific `provider/{providerId}`. For performance reasons they are kept separate.
         * @summary List bank providers
         * @param {string} [bankCode] Optional — if length &#x3D; 8, the response will also contain data describing             the fields required for account setup
         * @param {boolean} [supported] Optional — response should only contain providers supported for account             setup via this API
         * @param {string} [query] Optional — search parameters for BankCode, BIC, Location, Name. Will be ignored             if the bankCode query parameter is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProviders: function (bankCode, supported, query, options) {
            return exports.ProviderApiFp(configuration).getProviders(bankCode, supported, query, options)(fetch, basePath);
        },
    };
};
/**
 * ProviderApi - object-oriented interface
 * @export
 * @class ProviderApi
 * @extends {BaseAPI}
 */
var ProviderApi = /** @class */ (function (_super) {
    __extends(ProviderApi, _super);
    function ProviderApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Retrieve a single provider identified by **providerId**.
     * @summary Get provider
     * @param {string} providerId The **providerId** to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderApi
     */
    ProviderApi.prototype.getProvider = function (providerId, options) {
        return exports.ProviderApiFp(this.configuration).getProvider(providerId, options)(this.fetch, this.basePath);
    };
    /**
     * Retrieve a list of bank providers. A provider-**id** is necessary to create an _access_. To retrieve the necessary access fields, you need to query the specific `provider/{providerId}`. For performance reasons they are kept separate.
     * @summary List bank providers
     * @param {string} [bankCode] Optional — if length &#x3D; 8, the response will also contain data describing             the fields required for account setup
     * @param {boolean} [supported] Optional — response should only contain providers supported for account             setup via this API
     * @param {string} [query] Optional — search parameters for BankCode, BIC, Location, Name. Will be ignored             if the bankCode query parameter is set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderApi
     */
    ProviderApi.prototype.getProviders = function (bankCode, supported, query, options) {
        return exports.ProviderApiFp(this.configuration).getProviders(bankCode, supported, query, options)(this.fetch, this.basePath);
    };
    return ProviderApi;
}(BaseAPI));
exports.ProviderApi = ProviderApi;
/**
 * RegistrationApi - fetch parameter creator
 * @export
 */
exports.RegistrationApiFetchParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Delete the user context for the current token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRegistration: function (options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/registration";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                var localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth2", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A valid API public key will be returned in JWK format to be used to encrypt registration data
         * @summary Request API jwk public key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJsonWebKey: function (options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/registration/jwk";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                var localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth2", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A valid API public key will be returned to be used to encrypt registration data
         * @summary Request API public key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRegistrationPublicKey: function (options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/registration/keys";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                var localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth2", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Registers a user with AHOI
         * @summary User registration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register: function (options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/registration";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                var localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth2", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * RegistrationApi - functional programming interface
 * @export
 */
exports.RegistrationApiFp = function (configuration) {
    return {
        /**
         *
         * @summary Delete the user context for the current token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRegistration: function (options) {
            var localVarFetchArgs = exports.RegistrationApiFetchParamCreator(configuration).deleteRegistration(options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * A valid API public key will be returned in JWK format to be used to encrypt registration data
         * @summary Request API jwk public key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJsonWebKey: function (options) {
            var localVarFetchArgs = exports.RegistrationApiFetchParamCreator(configuration).getJsonWebKey(options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * A valid API public key will be returned to be used to encrypt registration data
         * @summary Request API public key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRegistrationPublicKey: function (options) {
            var localVarFetchArgs = exports.RegistrationApiFetchParamCreator(configuration).getRegistrationPublicKey(options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Registers a user with AHOI
         * @summary User registration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register: function (options) {
            var localVarFetchArgs = exports.RegistrationApiFetchParamCreator(configuration).register(options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * RegistrationApi - factory interface
 * @export
 */
exports.RegistrationApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         *
         * @summary Delete the user context for the current token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRegistration: function (options) {
            return exports.RegistrationApiFp(configuration).deleteRegistration(options)(fetch, basePath);
        },
        /**
         * A valid API public key will be returned in JWK format to be used to encrypt registration data
         * @summary Request API jwk public key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJsonWebKey: function (options) {
            return exports.RegistrationApiFp(configuration).getJsonWebKey(options)(fetch, basePath);
        },
        /**
         * A valid API public key will be returned to be used to encrypt registration data
         * @summary Request API public key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRegistrationPublicKey: function (options) {
            return exports.RegistrationApiFp(configuration).getRegistrationPublicKey(options)(fetch, basePath);
        },
        /**
         * Registers a user with AHOI
         * @summary User registration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register: function (options) {
            return exports.RegistrationApiFp(configuration).register(options)(fetch, basePath);
        },
    };
};
/**
 * RegistrationApi - object-oriented interface
 * @export
 * @class RegistrationApi
 * @extends {BaseAPI}
 */
var RegistrationApi = /** @class */ (function (_super) {
    __extends(RegistrationApi, _super);
    function RegistrationApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary Delete the user context for the current token.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegistrationApi
     */
    RegistrationApi.prototype.deleteRegistration = function (options) {
        return exports.RegistrationApiFp(this.configuration).deleteRegistration(options)(this.fetch, this.basePath);
    };
    /**
     * A valid API public key will be returned in JWK format to be used to encrypt registration data
     * @summary Request API jwk public key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegistrationApi
     */
    RegistrationApi.prototype.getJsonWebKey = function (options) {
        return exports.RegistrationApiFp(this.configuration).getJsonWebKey(options)(this.fetch, this.basePath);
    };
    /**
     * A valid API public key will be returned to be used to encrypt registration data
     * @summary Request API public key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegistrationApi
     */
    RegistrationApi.prototype.getRegistrationPublicKey = function (options) {
        return exports.RegistrationApiFp(this.configuration).getRegistrationPublicKey(options)(this.fetch, this.basePath);
    };
    /**
     * Registers a user with AHOI
     * @summary User registration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegistrationApi
     */
    RegistrationApi.prototype.register = function (options) {
        return exports.RegistrationApiFp(this.configuration).register(options)(this.fetch, this.basePath);
    };
    return RegistrationApi;
}(BaseAPI));
exports.RegistrationApi = RegistrationApi;
/**
 * SecurityApi - fetch parameter creator
 * @export
 */
exports.SecurityApiFetchParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Get security
         * @param {string} accessId
         * @param {string} accountId The **accountId** for which to retrieve securities
         * @param {string} securityId The **securityId** for the security to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSecurity: function (accessId, accountId, securityId, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'accessId' is not null or undefined
            if (accessId === null || accessId === undefined) {
                throw new RequiredError('accessId', 'Required parameter accessId was null or undefined when calling getSecurity.');
            }
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new RequiredError('accountId', 'Required parameter accountId was null or undefined when calling getSecurity.');
            }
            // verify required parameter 'securityId' is not null or undefined
            if (securityId === null || securityId === undefined) {
                throw new RequiredError('securityId', 'Required parameter securityId was null or undefined when calling getSecurity.');
            }
            var localVarPath = "/accesses/{accessId}/accounts/{accountId}/securities/{securityId}"
                .replace("{" + "accessId" + "}", encodeURIComponent(String(accessId)))
                .replace("{" + "accountId" + "}", encodeURIComponent(String(accountId)))
                .replace("{" + "securityId" + "}", encodeURIComponent(String(securityId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                var localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth2", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary List securities for account
         * @param {string} accessId
         * @param {string} accountId The **accountId** for which to retrieve securities
         * @param {number} [maxAge] Optional - defines maximum age (in seconds) of cached account data provided by the bank.         A \&quot;maxAge\&quot; of 3600 will not trigger an update of the account securities, when last         refresh has been done 2000 seconds ago.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSecurities: function (accessId, accountId, maxAge, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'accessId' is not null or undefined
            if (accessId === null || accessId === undefined) {
                throw new RequiredError('accessId', 'Required parameter accessId was null or undefined when calling listSecurities.');
            }
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new RequiredError('accountId', 'Required parameter accountId was null or undefined when calling listSecurities.');
            }
            var localVarPath = "/accesses/{accessId}/accounts/{accountId}/securities"
                .replace("{" + "accessId" + "}", encodeURIComponent(String(accessId)))
                .replace("{" + "accountId" + "}", encodeURIComponent(String(accountId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                var localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth2", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (maxAge !== undefined) {
                localVarQueryParameter['max-age'] = maxAge;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * SecurityApi - functional programming interface
 * @export
 */
exports.SecurityApiFp = function (configuration) {
    return {
        /**
         *
         * @summary Get security
         * @param {string} accessId
         * @param {string} accountId The **accountId** for which to retrieve securities
         * @param {string} securityId The **securityId** for the security to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSecurity: function (accessId, accountId, securityId, options) {
            var localVarFetchArgs = exports.SecurityApiFetchParamCreator(configuration).getSecurity(accessId, accountId, securityId, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary List securities for account
         * @param {string} accessId
         * @param {string} accountId The **accountId** for which to retrieve securities
         * @param {number} [maxAge] Optional - defines maximum age (in seconds) of cached account data provided by the bank.         A \&quot;maxAge\&quot; of 3600 will not trigger an update of the account securities, when last         refresh has been done 2000 seconds ago.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSecurities: function (accessId, accountId, maxAge, options) {
            var localVarFetchArgs = exports.SecurityApiFetchParamCreator(configuration).listSecurities(accessId, accountId, maxAge, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * SecurityApi - factory interface
 * @export
 */
exports.SecurityApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         *
         * @summary Get security
         * @param {string} accessId
         * @param {string} accountId The **accountId** for which to retrieve securities
         * @param {string} securityId The **securityId** for the security to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSecurity: function (accessId, accountId, securityId, options) {
            return exports.SecurityApiFp(configuration).getSecurity(accessId, accountId, securityId, options)(fetch, basePath);
        },
        /**
         *
         * @summary List securities for account
         * @param {string} accessId
         * @param {string} accountId The **accountId** for which to retrieve securities
         * @param {number} [maxAge] Optional - defines maximum age (in seconds) of cached account data provided by the bank.         A \&quot;maxAge\&quot; of 3600 will not trigger an update of the account securities, when last         refresh has been done 2000 seconds ago.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSecurities: function (accessId, accountId, maxAge, options) {
            return exports.SecurityApiFp(configuration).listSecurities(accessId, accountId, maxAge, options)(fetch, basePath);
        },
    };
};
/**
 * SecurityApi - object-oriented interface
 * @export
 * @class SecurityApi
 * @extends {BaseAPI}
 */
var SecurityApi = /** @class */ (function (_super) {
    __extends(SecurityApi, _super);
    function SecurityApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary Get security
     * @param {string} accessId
     * @param {string} accountId The **accountId** for which to retrieve securities
     * @param {string} securityId The **securityId** for the security to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecurityApi
     */
    SecurityApi.prototype.getSecurity = function (accessId, accountId, securityId, options) {
        return exports.SecurityApiFp(this.configuration).getSecurity(accessId, accountId, securityId, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary List securities for account
     * @param {string} accessId
     * @param {string} accountId The **accountId** for which to retrieve securities
     * @param {number} [maxAge] Optional - defines maximum age (in seconds) of cached account data provided by the bank.         A \&quot;maxAge\&quot; of 3600 will not trigger an update of the account securities, when last         refresh has been done 2000 seconds ago.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecurityApi
     */
    SecurityApi.prototype.listSecurities = function (accessId, accountId, maxAge, options) {
        return exports.SecurityApiFp(this.configuration).listSecurities(accessId, accountId, maxAge, options)(this.fetch, this.basePath);
    };
    return SecurityApi;
}(BaseAPI));
exports.SecurityApi = SecurityApi;
/**
 * TANSchemesApi - fetch parameter creator
 * @export
 */
exports.TANSchemesApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Returns the currently selected TAN media for the access.
         * @summary Get current TAN media.
         * @param {string} accessId The **accessId** for which to retrieve the current TAN media.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentTanMedia: function (accessId, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'accessId' is not null or undefined
            if (accessId === null || accessId === undefined) {
                throw new RequiredError('accessId', 'Required parameter accessId was null or undefined when calling getCurrentTanMedia.');
            }
            var localVarPath = "/accesses/{accessId}/currenttanmedia"
                .replace("{" + "accessId" + "}", encodeURIComponent(String(accessId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                var localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth2", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the currently selected TAN scheme for the access.
         * @summary Get current TAN scheme.
         * @param {string} accessId The **accessId** for which to retrieve the current TAN scheme.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentTanScheme: function (accessId, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'accessId' is not null or undefined
            if (accessId === null || accessId === undefined) {
                throw new RequiredError('accessId', 'Required parameter accessId was null or undefined when calling getCurrentTanScheme.');
            }
            var localVarPath = "/accesses/{accessId}/currenttanscheme"
                .replace("{" + "accessId" + "}", encodeURIComponent(String(accessId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                var localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth2", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves all available TAN schemes for access.
         * @summary List TAN schemes for access
         * @param {string} accessId The **id** for the access for which to retrieve the TAN list
         * @param {number} [maxAge] Optional - defines maximum age (in seconds) of cached account data provided by the bank.      A \&quot;maxAge\&quot; of 3600 will not trigger an update of TAN schemes, when last refresh has been      done 2000 seconds ago.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTanSchemes: function (accessId, maxAge, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'accessId' is not null or undefined
            if (accessId === null || accessId === undefined) {
                throw new RequiredError('accessId', 'Required parameter accessId was null or undefined when calling getTanSchemes.');
            }
            var localVarPath = "/accesses/{accessId}/tanschemes"
                .replace("{" + "accessId" + "}", encodeURIComponent(String(accessId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                var localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth2", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (maxAge !== undefined) {
                localVarQueryParameter['max-age'] = maxAge;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the access with a new currentTanMedia.
         * @summary Update current TAN media.
         * @param {string} accessId The **accessId** for which to set the current TAN media.
         * @param {string} tanMediaId The **id** for the TAN media that should be set as the new currentTanMedia.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putCurrentTanMedia: function (accessId, tanMediaId, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'accessId' is not null or undefined
            if (accessId === null || accessId === undefined) {
                throw new RequiredError('accessId', 'Required parameter accessId was null or undefined when calling putCurrentTanMedia.');
            }
            // verify required parameter 'tanMediaId' is not null or undefined
            if (tanMediaId === null || tanMediaId === undefined) {
                throw new RequiredError('tanMediaId', 'Required parameter tanMediaId was null or undefined when calling putCurrentTanMedia.');
            }
            var localVarPath = "/accesses/{accessId}/currenttanmedia/{tanMediaId}"
                .replace("{" + "accessId" + "}", encodeURIComponent(String(accessId)))
                .replace("{" + "tanMediaId" + "}", encodeURIComponent(String(tanMediaId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                var localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth2", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the access with a new currentTanScheme.
         * @summary Update current TAN scheme.
         * @param {string} accessId The **accessId** for which to set the current TAN scheme.
         * @param {string} tanSchemeId The **id** for the TAN scheme that should be set as the new currentTanScheme.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putCurrentTanScheme: function (accessId, tanSchemeId, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'accessId' is not null or undefined
            if (accessId === null || accessId === undefined) {
                throw new RequiredError('accessId', 'Required parameter accessId was null or undefined when calling putCurrentTanScheme.');
            }
            // verify required parameter 'tanSchemeId' is not null or undefined
            if (tanSchemeId === null || tanSchemeId === undefined) {
                throw new RequiredError('tanSchemeId', 'Required parameter tanSchemeId was null or undefined when calling putCurrentTanScheme.');
            }
            var localVarPath = "/accesses/{accessId}/currenttanscheme/{tanSchemeId}"
                .replace("{" + "accessId" + "}", encodeURIComponent(String(accessId)))
                .replace("{" + "tanSchemeId" + "}", encodeURIComponent(String(tanSchemeId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                var localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth2", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * TANSchemesApi - functional programming interface
 * @export
 */
exports.TANSchemesApiFp = function (configuration) {
    return {
        /**
         * Returns the currently selected TAN media for the access.
         * @summary Get current TAN media.
         * @param {string} accessId The **accessId** for which to retrieve the current TAN media.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentTanMedia: function (accessId, options) {
            var localVarFetchArgs = exports.TANSchemesApiFetchParamCreator(configuration).getCurrentTanMedia(accessId, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns the currently selected TAN scheme for the access.
         * @summary Get current TAN scheme.
         * @param {string} accessId The **accessId** for which to retrieve the current TAN scheme.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentTanScheme: function (accessId, options) {
            var localVarFetchArgs = exports.TANSchemesApiFetchParamCreator(configuration).getCurrentTanScheme(accessId, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves all available TAN schemes for access.
         * @summary List TAN schemes for access
         * @param {string} accessId The **id** for the access for which to retrieve the TAN list
         * @param {number} [maxAge] Optional - defines maximum age (in seconds) of cached account data provided by the bank.      A \&quot;maxAge\&quot; of 3600 will not trigger an update of TAN schemes, when last refresh has been      done 2000 seconds ago.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTanSchemes: function (accessId, maxAge, options) {
            var localVarFetchArgs = exports.TANSchemesApiFetchParamCreator(configuration).getTanSchemes(accessId, maxAge, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update the access with a new currentTanMedia.
         * @summary Update current TAN media.
         * @param {string} accessId The **accessId** for which to set the current TAN media.
         * @param {string} tanMediaId The **id** for the TAN media that should be set as the new currentTanMedia.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putCurrentTanMedia: function (accessId, tanMediaId, options) {
            var localVarFetchArgs = exports.TANSchemesApiFetchParamCreator(configuration).putCurrentTanMedia(accessId, tanMediaId, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update the access with a new currentTanScheme.
         * @summary Update current TAN scheme.
         * @param {string} accessId The **accessId** for which to set the current TAN scheme.
         * @param {string} tanSchemeId The **id** for the TAN scheme that should be set as the new currentTanScheme.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putCurrentTanScheme: function (accessId, tanSchemeId, options) {
            var localVarFetchArgs = exports.TANSchemesApiFetchParamCreator(configuration).putCurrentTanScheme(accessId, tanSchemeId, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * TANSchemesApi - factory interface
 * @export
 */
exports.TANSchemesApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Returns the currently selected TAN media for the access.
         * @summary Get current TAN media.
         * @param {string} accessId The **accessId** for which to retrieve the current TAN media.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentTanMedia: function (accessId, options) {
            return exports.TANSchemesApiFp(configuration).getCurrentTanMedia(accessId, options)(fetch, basePath);
        },
        /**
         * Returns the currently selected TAN scheme for the access.
         * @summary Get current TAN scheme.
         * @param {string} accessId The **accessId** for which to retrieve the current TAN scheme.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentTanScheme: function (accessId, options) {
            return exports.TANSchemesApiFp(configuration).getCurrentTanScheme(accessId, options)(fetch, basePath);
        },
        /**
         * Retrieves all available TAN schemes for access.
         * @summary List TAN schemes for access
         * @param {string} accessId The **id** for the access for which to retrieve the TAN list
         * @param {number} [maxAge] Optional - defines maximum age (in seconds) of cached account data provided by the bank.      A \&quot;maxAge\&quot; of 3600 will not trigger an update of TAN schemes, when last refresh has been      done 2000 seconds ago.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTanSchemes: function (accessId, maxAge, options) {
            return exports.TANSchemesApiFp(configuration).getTanSchemes(accessId, maxAge, options)(fetch, basePath);
        },
        /**
         * Update the access with a new currentTanMedia.
         * @summary Update current TAN media.
         * @param {string} accessId The **accessId** for which to set the current TAN media.
         * @param {string} tanMediaId The **id** for the TAN media that should be set as the new currentTanMedia.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putCurrentTanMedia: function (accessId, tanMediaId, options) {
            return exports.TANSchemesApiFp(configuration).putCurrentTanMedia(accessId, tanMediaId, options)(fetch, basePath);
        },
        /**
         * Update the access with a new currentTanScheme.
         * @summary Update current TAN scheme.
         * @param {string} accessId The **accessId** for which to set the current TAN scheme.
         * @param {string} tanSchemeId The **id** for the TAN scheme that should be set as the new currentTanScheme.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putCurrentTanScheme: function (accessId, tanSchemeId, options) {
            return exports.TANSchemesApiFp(configuration).putCurrentTanScheme(accessId, tanSchemeId, options)(fetch, basePath);
        },
    };
};
/**
 * TANSchemesApi - object-oriented interface
 * @export
 * @class TANSchemesApi
 * @extends {BaseAPI}
 */
var TANSchemesApi = /** @class */ (function (_super) {
    __extends(TANSchemesApi, _super);
    function TANSchemesApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Returns the currently selected TAN media for the access.
     * @summary Get current TAN media.
     * @param {string} accessId The **accessId** for which to retrieve the current TAN media.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TANSchemesApi
     */
    TANSchemesApi.prototype.getCurrentTanMedia = function (accessId, options) {
        return exports.TANSchemesApiFp(this.configuration).getCurrentTanMedia(accessId, options)(this.fetch, this.basePath);
    };
    /**
     * Returns the currently selected TAN scheme for the access.
     * @summary Get current TAN scheme.
     * @param {string} accessId The **accessId** for which to retrieve the current TAN scheme.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TANSchemesApi
     */
    TANSchemesApi.prototype.getCurrentTanScheme = function (accessId, options) {
        return exports.TANSchemesApiFp(this.configuration).getCurrentTanScheme(accessId, options)(this.fetch, this.basePath);
    };
    /**
     * Retrieves all available TAN schemes for access.
     * @summary List TAN schemes for access
     * @param {string} accessId The **id** for the access for which to retrieve the TAN list
     * @param {number} [maxAge] Optional - defines maximum age (in seconds) of cached account data provided by the bank.      A \&quot;maxAge\&quot; of 3600 will not trigger an update of TAN schemes, when last refresh has been      done 2000 seconds ago.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TANSchemesApi
     */
    TANSchemesApi.prototype.getTanSchemes = function (accessId, maxAge, options) {
        return exports.TANSchemesApiFp(this.configuration).getTanSchemes(accessId, maxAge, options)(this.fetch, this.basePath);
    };
    /**
     * Update the access with a new currentTanMedia.
     * @summary Update current TAN media.
     * @param {string} accessId The **accessId** for which to set the current TAN media.
     * @param {string} tanMediaId The **id** for the TAN media that should be set as the new currentTanMedia.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TANSchemesApi
     */
    TANSchemesApi.prototype.putCurrentTanMedia = function (accessId, tanMediaId, options) {
        return exports.TANSchemesApiFp(this.configuration).putCurrentTanMedia(accessId, tanMediaId, options)(this.fetch, this.basePath);
    };
    /**
     * Update the access with a new currentTanScheme.
     * @summary Update current TAN scheme.
     * @param {string} accessId The **accessId** for which to set the current TAN scheme.
     * @param {string} tanSchemeId The **id** for the TAN scheme that should be set as the new currentTanScheme.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TANSchemesApi
     */
    TANSchemesApi.prototype.putCurrentTanScheme = function (accessId, tanSchemeId, options) {
        return exports.TANSchemesApiFp(this.configuration).putCurrentTanScheme(accessId, tanSchemeId, options)(this.fetch, this.basePath);
    };
    return TANSchemesApi;
}(BaseAPI));
exports.TANSchemesApi = TANSchemesApi;
/**
 * TaskApi - fetch parameter creator
 * @export
 */
exports.TaskApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Fetch challenge for asynchronous running task item from AHOI.
         * @summary Fetch challenge
         * @param {string} taskId The **id** for the Task.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChallenge: function (taskId, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'taskId' is not null or undefined
            if (taskId === null || taskId === undefined) {
                throw new RequiredError('taskId', 'Required parameter taskId was null or undefined when calling getChallenge.');
            }
            var localVarPath = "/tasks/{taskId}/challenges"
                .replace("{" + "taskId" + "}", encodeURIComponent(String(taskId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                var localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth2", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch asynchronous running task item and its state from AHOI.
         * @summary Fetch task
         * @param {string} taskId The **id** for the access to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTask: function (taskId, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'taskId' is not null or undefined
            if (taskId === null || taskId === undefined) {
                throw new RequiredError('taskId', 'Required parameter taskId was null or undefined when calling getTask.');
            }
            var localVarPath = "/tasks/{taskId}"
                .replace("{" + "taskId" + "}", encodeURIComponent(String(taskId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                var localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth2", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Provide an authorization information (e.g. TAN) to an asynchronous running task.
         * @summary Authorize task
         * @param {string} taskId The **id** for the Task.
         * @param {ChallengeResponse} challengeResponse the response to process
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postChallengeResponse: function (taskId, challengeResponse, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'taskId' is not null or undefined
            if (taskId === null || taskId === undefined) {
                throw new RequiredError('taskId', 'Required parameter taskId was null or undefined when calling postChallengeResponse.');
            }
            // verify required parameter 'challengeResponse' is not null or undefined
            if (challengeResponse === null || challengeResponse === undefined) {
                throw new RequiredError('challengeResponse', 'Required parameter challengeResponse was null or undefined when calling postChallengeResponse.');
            }
            var localVarPath = "/tasks/{taskId}/authorizations"
                .replace("{" + "taskId" + "}", encodeURIComponent(String(taskId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                var localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth2", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = ("ChallengeResponse" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(challengeResponse || {}) : (challengeResponse || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * TaskApi - functional programming interface
 * @export
 */
exports.TaskApiFp = function (configuration) {
    return {
        /**
         * Fetch challenge for asynchronous running task item from AHOI.
         * @summary Fetch challenge
         * @param {string} taskId The **id** for the Task.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChallenge: function (taskId, options) {
            var localVarFetchArgs = exports.TaskApiFetchParamCreator(configuration).getChallenge(taskId, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Fetch asynchronous running task item and its state from AHOI.
         * @summary Fetch task
         * @param {string} taskId The **id** for the access to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTask: function (taskId, options) {
            var localVarFetchArgs = exports.TaskApiFetchParamCreator(configuration).getTask(taskId, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Provide an authorization information (e.g. TAN) to an asynchronous running task.
         * @summary Authorize task
         * @param {string} taskId The **id** for the Task.
         * @param {ChallengeResponse} challengeResponse the response to process
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postChallengeResponse: function (taskId, challengeResponse, options) {
            var localVarFetchArgs = exports.TaskApiFetchParamCreator(configuration).postChallengeResponse(taskId, challengeResponse, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * TaskApi - factory interface
 * @export
 */
exports.TaskApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Fetch challenge for asynchronous running task item from AHOI.
         * @summary Fetch challenge
         * @param {string} taskId The **id** for the Task.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChallenge: function (taskId, options) {
            return exports.TaskApiFp(configuration).getChallenge(taskId, options)(fetch, basePath);
        },
        /**
         * Fetch asynchronous running task item and its state from AHOI.
         * @summary Fetch task
         * @param {string} taskId The **id** for the access to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTask: function (taskId, options) {
            return exports.TaskApiFp(configuration).getTask(taskId, options)(fetch, basePath);
        },
        /**
         * Provide an authorization information (e.g. TAN) to an asynchronous running task.
         * @summary Authorize task
         * @param {string} taskId The **id** for the Task.
         * @param {ChallengeResponse} challengeResponse the response to process
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postChallengeResponse: function (taskId, challengeResponse, options) {
            return exports.TaskApiFp(configuration).postChallengeResponse(taskId, challengeResponse, options)(fetch, basePath);
        },
    };
};
/**
 * TaskApi - object-oriented interface
 * @export
 * @class TaskApi
 * @extends {BaseAPI}
 */
var TaskApi = /** @class */ (function (_super) {
    __extends(TaskApi, _super);
    function TaskApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Fetch challenge for asynchronous running task item from AHOI.
     * @summary Fetch challenge
     * @param {string} taskId The **id** for the Task.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    TaskApi.prototype.getChallenge = function (taskId, options) {
        return exports.TaskApiFp(this.configuration).getChallenge(taskId, options)(this.fetch, this.basePath);
    };
    /**
     * Fetch asynchronous running task item and its state from AHOI.
     * @summary Fetch task
     * @param {string} taskId The **id** for the access to retrieve.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    TaskApi.prototype.getTask = function (taskId, options) {
        return exports.TaskApiFp(this.configuration).getTask(taskId, options)(this.fetch, this.basePath);
    };
    /**
     * Provide an authorization information (e.g. TAN) to an asynchronous running task.
     * @summary Authorize task
     * @param {string} taskId The **id** for the Task.
     * @param {ChallengeResponse} challengeResponse the response to process
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    TaskApi.prototype.postChallengeResponse = function (taskId, challengeResponse, options) {
        return exports.TaskApiFp(this.configuration).postChallengeResponse(taskId, challengeResponse, options)(this.fetch, this.basePath);
    };
    return TaskApi;
}(BaseAPI));
exports.TaskApi = TaskApi;
/**
 * TransactionApi - fetch parameter creator
 * @export
 */
exports.TransactionApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Returns the transaction identified by **transactionId** in relationship with **accountId**.
         * @summary Get transaction
         * @param {string} accessId The **accessId** for the transaction to retrieve
         * @param {string} accountId The **accountId** for the transaction to retrieve
         * @param {string} transactionId The **transactionId** for the pattern to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransaction: function (accessId, accountId, transactionId, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'accessId' is not null or undefined
            if (accessId === null || accessId === undefined) {
                throw new RequiredError('accessId', 'Required parameter accessId was null or undefined when calling getTransaction.');
            }
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new RequiredError('accountId', 'Required parameter accountId was null or undefined when calling getTransaction.');
            }
            // verify required parameter 'transactionId' is not null or undefined
            if (transactionId === null || transactionId === undefined) {
                throw new RequiredError('transactionId', 'Required parameter transactionId was null or undefined when calling getTransaction.');
            }
            var localVarPath = "/accesses/{accessId}/accounts/{accountId}/transactions/{transactionId}"
                .replace("{" + "accessId" + "}", encodeURIComponent(String(accessId)))
                .replace("{" + "accountId" + "}", encodeURIComponent(String(accountId)))
                .replace("{" + "transactionId" + "}", encodeURIComponent(String(transactionId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                var localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth2", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all transactions for **accountId**.
         * @summary List transactions for account
         * @param {string} accessId The **accessId** for which to retrieve transactions.
         * @param {string} accountId The **accountId** for which to retrieve transactions.
         * @param {number} [maxAge] Optional - defines maximum age (in seconds) of cached account data provided by the bank.          A \&quot;maxAge\&quot; of 3600 will not trigger an update of transactions, when last refresh has          been done 2000 seconds ago.
         * @param {number} [limit] Optional — limit the number of returned transactions
         * @param {number} [offset] Optional — skip the first **offset** transactions in result
         * @param {string} [from] Optional — only return transactions with booking date later than **from**; an ISO8601 Month(2014-11), Date (2014-11-17) or DateTime         (2014-11-17T12:00:00Z)
         * @param {string} [to] Optional — only return transactions with booking date prior or equal to **to**; an ISO8601 Date, Month or DateTime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactions: function (accessId, accountId, maxAge, limit, offset, from, to, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'accessId' is not null or undefined
            if (accessId === null || accessId === undefined) {
                throw new RequiredError('accessId', 'Required parameter accessId was null or undefined when calling listTransactions.');
            }
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new RequiredError('accountId', 'Required parameter accountId was null or undefined when calling listTransactions.');
            }
            var localVarPath = "/accesses/{accessId}/accounts/{accountId}/transactions"
                .replace("{" + "accessId" + "}", encodeURIComponent(String(accessId)))
                .replace("{" + "accountId" + "}", encodeURIComponent(String(accountId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                var localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth2", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (maxAge !== undefined) {
                localVarQueryParameter['max-age'] = maxAge;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }
            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all transactions for **patternId**.
         * @summary List transactions for pattern
         * @param {string} accessId The **accessId** for which to retrieve transactions
         * @param {string} accountId The **accountId** for which to retrieve transactions
         * @param {string} patternId The **patternId** for which to retrieve transactions
         * @param {number} [maxAge] Optional - defines maximum age (in seconds) of cached account data provided by the bank.       A \&quot;maxAge\&quot; of 3600 will not trigger an update of transactions, when last refresh has       been done 2000 seconds ago.
         * @param {number} [limit] Optional — limit the number of returned transactions
         * @param {number} [offset] Optional — skip the first **offset** transactions in result
         * @param {string} [from] Optional — only return transactions with a booking date later than **from**; an ISO8601 Month(2014-11), Date (2014-11-17) or DateTime         (2014-11-17T12:00:00Z)
         * @param {string} [to] Optional — only return transactions with a booking date prior or equal to **to**; an ISO8601 Date, Month or DateTime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactionsForPattern: function (accessId, accountId, patternId, maxAge, limit, offset, from, to, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'accessId' is not null or undefined
            if (accessId === null || accessId === undefined) {
                throw new RequiredError('accessId', 'Required parameter accessId was null or undefined when calling listTransactionsForPattern.');
            }
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new RequiredError('accountId', 'Required parameter accountId was null or undefined when calling listTransactionsForPattern.');
            }
            // verify required parameter 'patternId' is not null or undefined
            if (patternId === null || patternId === undefined) {
                throw new RequiredError('patternId', 'Required parameter patternId was null or undefined when calling listTransactionsForPattern.');
            }
            var localVarPath = "/accesses/{accessId}/accounts/{accountId}/transactionpatterns/{patternId}/transactions"
                .replace("{" + "accessId" + "}", encodeURIComponent(String(accessId)))
                .replace("{" + "accountId" + "}", encodeURIComponent(String(accountId)))
                .replace("{" + "patternId" + "}", encodeURIComponent(String(patternId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                var localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth2", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (maxAge !== undefined) {
                localVarQueryParameter['max-age'] = maxAge;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }
            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * TransactionApi - functional programming interface
 * @export
 */
exports.TransactionApiFp = function (configuration) {
    return {
        /**
         * Returns the transaction identified by **transactionId** in relationship with **accountId**.
         * @summary Get transaction
         * @param {string} accessId The **accessId** for the transaction to retrieve
         * @param {string} accountId The **accountId** for the transaction to retrieve
         * @param {string} transactionId The **transactionId** for the pattern to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransaction: function (accessId, accountId, transactionId, options) {
            var localVarFetchArgs = exports.TransactionApiFetchParamCreator(configuration).getTransaction(accessId, accountId, transactionId, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve all transactions for **accountId**.
         * @summary List transactions for account
         * @param {string} accessId The **accessId** for which to retrieve transactions.
         * @param {string} accountId The **accountId** for which to retrieve transactions.
         * @param {number} [maxAge] Optional - defines maximum age (in seconds) of cached account data provided by the bank.          A \&quot;maxAge\&quot; of 3600 will not trigger an update of transactions, when last refresh has          been done 2000 seconds ago.
         * @param {number} [limit] Optional — limit the number of returned transactions
         * @param {number} [offset] Optional — skip the first **offset** transactions in result
         * @param {string} [from] Optional — only return transactions with booking date later than **from**; an ISO8601 Month(2014-11), Date (2014-11-17) or DateTime         (2014-11-17T12:00:00Z)
         * @param {string} [to] Optional — only return transactions with booking date prior or equal to **to**; an ISO8601 Date, Month or DateTime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactions: function (accessId, accountId, maxAge, limit, offset, from, to, options) {
            var localVarFetchArgs = exports.TransactionApiFetchParamCreator(configuration).listTransactions(accessId, accountId, maxAge, limit, offset, from, to, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve all transactions for **patternId**.
         * @summary List transactions for pattern
         * @param {string} accessId The **accessId** for which to retrieve transactions
         * @param {string} accountId The **accountId** for which to retrieve transactions
         * @param {string} patternId The **patternId** for which to retrieve transactions
         * @param {number} [maxAge] Optional - defines maximum age (in seconds) of cached account data provided by the bank.       A \&quot;maxAge\&quot; of 3600 will not trigger an update of transactions, when last refresh has       been done 2000 seconds ago.
         * @param {number} [limit] Optional — limit the number of returned transactions
         * @param {number} [offset] Optional — skip the first **offset** transactions in result
         * @param {string} [from] Optional — only return transactions with a booking date later than **from**; an ISO8601 Month(2014-11), Date (2014-11-17) or DateTime         (2014-11-17T12:00:00Z)
         * @param {string} [to] Optional — only return transactions with a booking date prior or equal to **to**; an ISO8601 Date, Month or DateTime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactionsForPattern: function (accessId, accountId, patternId, maxAge, limit, offset, from, to, options) {
            var localVarFetchArgs = exports.TransactionApiFetchParamCreator(configuration).listTransactionsForPattern(accessId, accountId, patternId, maxAge, limit, offset, from, to, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * TransactionApi - factory interface
 * @export
 */
exports.TransactionApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Returns the transaction identified by **transactionId** in relationship with **accountId**.
         * @summary Get transaction
         * @param {string} accessId The **accessId** for the transaction to retrieve
         * @param {string} accountId The **accountId** for the transaction to retrieve
         * @param {string} transactionId The **transactionId** for the pattern to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransaction: function (accessId, accountId, transactionId, options) {
            return exports.TransactionApiFp(configuration).getTransaction(accessId, accountId, transactionId, options)(fetch, basePath);
        },
        /**
         * Retrieve all transactions for **accountId**.
         * @summary List transactions for account
         * @param {string} accessId The **accessId** for which to retrieve transactions.
         * @param {string} accountId The **accountId** for which to retrieve transactions.
         * @param {number} [maxAge] Optional - defines maximum age (in seconds) of cached account data provided by the bank.          A \&quot;maxAge\&quot; of 3600 will not trigger an update of transactions, when last refresh has          been done 2000 seconds ago.
         * @param {number} [limit] Optional — limit the number of returned transactions
         * @param {number} [offset] Optional — skip the first **offset** transactions in result
         * @param {string} [from] Optional — only return transactions with booking date later than **from**; an ISO8601 Month(2014-11), Date (2014-11-17) or DateTime         (2014-11-17T12:00:00Z)
         * @param {string} [to] Optional — only return transactions with booking date prior or equal to **to**; an ISO8601 Date, Month or DateTime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactions: function (accessId, accountId, maxAge, limit, offset, from, to, options) {
            return exports.TransactionApiFp(configuration).listTransactions(accessId, accountId, maxAge, limit, offset, from, to, options)(fetch, basePath);
        },
        /**
         * Retrieve all transactions for **patternId**.
         * @summary List transactions for pattern
         * @param {string} accessId The **accessId** for which to retrieve transactions
         * @param {string} accountId The **accountId** for which to retrieve transactions
         * @param {string} patternId The **patternId** for which to retrieve transactions
         * @param {number} [maxAge] Optional - defines maximum age (in seconds) of cached account data provided by the bank.       A \&quot;maxAge\&quot; of 3600 will not trigger an update of transactions, when last refresh has       been done 2000 seconds ago.
         * @param {number} [limit] Optional — limit the number of returned transactions
         * @param {number} [offset] Optional — skip the first **offset** transactions in result
         * @param {string} [from] Optional — only return transactions with a booking date later than **from**; an ISO8601 Month(2014-11), Date (2014-11-17) or DateTime         (2014-11-17T12:00:00Z)
         * @param {string} [to] Optional — only return transactions with a booking date prior or equal to **to**; an ISO8601 Date, Month or DateTime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactionsForPattern: function (accessId, accountId, patternId, maxAge, limit, offset, from, to, options) {
            return exports.TransactionApiFp(configuration).listTransactionsForPattern(accessId, accountId, patternId, maxAge, limit, offset, from, to, options)(fetch, basePath);
        },
    };
};
/**
 * TransactionApi - object-oriented interface
 * @export
 * @class TransactionApi
 * @extends {BaseAPI}
 */
var TransactionApi = /** @class */ (function (_super) {
    __extends(TransactionApi, _super);
    function TransactionApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Returns the transaction identified by **transactionId** in relationship with **accountId**.
     * @summary Get transaction
     * @param {string} accessId The **accessId** for the transaction to retrieve
     * @param {string} accountId The **accountId** for the transaction to retrieve
     * @param {string} transactionId The **transactionId** for the pattern to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionApi
     */
    TransactionApi.prototype.getTransaction = function (accessId, accountId, transactionId, options) {
        return exports.TransactionApiFp(this.configuration).getTransaction(accessId, accountId, transactionId, options)(this.fetch, this.basePath);
    };
    /**
     * Retrieve all transactions for **accountId**.
     * @summary List transactions for account
     * @param {string} accessId The **accessId** for which to retrieve transactions.
     * @param {string} accountId The **accountId** for which to retrieve transactions.
     * @param {number} [maxAge] Optional - defines maximum age (in seconds) of cached account data provided by the bank.          A \&quot;maxAge\&quot; of 3600 will not trigger an update of transactions, when last refresh has          been done 2000 seconds ago.
     * @param {number} [limit] Optional — limit the number of returned transactions
     * @param {number} [offset] Optional — skip the first **offset** transactions in result
     * @param {string} [from] Optional — only return transactions with booking date later than **from**; an ISO8601 Month(2014-11), Date (2014-11-17) or DateTime         (2014-11-17T12:00:00Z)
     * @param {string} [to] Optional — only return transactions with booking date prior or equal to **to**; an ISO8601 Date, Month or DateTime
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionApi
     */
    TransactionApi.prototype.listTransactions = function (accessId, accountId, maxAge, limit, offset, from, to, options) {
        return exports.TransactionApiFp(this.configuration).listTransactions(accessId, accountId, maxAge, limit, offset, from, to, options)(this.fetch, this.basePath);
    };
    /**
     * Retrieve all transactions for **patternId**.
     * @summary List transactions for pattern
     * @param {string} accessId The **accessId** for which to retrieve transactions
     * @param {string} accountId The **accountId** for which to retrieve transactions
     * @param {string} patternId The **patternId** for which to retrieve transactions
     * @param {number} [maxAge] Optional - defines maximum age (in seconds) of cached account data provided by the bank.       A \&quot;maxAge\&quot; of 3600 will not trigger an update of transactions, when last refresh has       been done 2000 seconds ago.
     * @param {number} [limit] Optional — limit the number of returned transactions
     * @param {number} [offset] Optional — skip the first **offset** transactions in result
     * @param {string} [from] Optional — only return transactions with a booking date later than **from**; an ISO8601 Month(2014-11), Date (2014-11-17) or DateTime         (2014-11-17T12:00:00Z)
     * @param {string} [to] Optional — only return transactions with a booking date prior or equal to **to**; an ISO8601 Date, Month or DateTime
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionApi
     */
    TransactionApi.prototype.listTransactionsForPattern = function (accessId, accountId, patternId, maxAge, limit, offset, from, to, options) {
        return exports.TransactionApiFp(this.configuration).listTransactionsForPattern(accessId, accountId, patternId, maxAge, limit, offset, from, to, options)(this.fetch, this.basePath);
    };
    return TransactionApi;
}(BaseAPI));
exports.TransactionApi = TransactionApi;
/**
 * TransactionPatternApi - fetch parameter creator
 * @export
 */
exports.TransactionPatternApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Disabling the transaction pattern results in ignoring the pattern in the forecast. The transaction still exists and relations with transactions are not modified.
         * @summary Enable a transaction pattern
         * @param {string} accessId The **accessId** for which to activate the pattern
         * @param {string} accountId The **accountId** for which to activate the pattern
         * @param {string} patternId The **patternId** to (de)activate
         * @param {boolean} activated If &#x60;true&#x60;, the pattern will be used for forecast calculations;         &#x60;false&#x60; will be ignored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateTransactionPattern: function (accessId, accountId, patternId, activated, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'accessId' is not null or undefined
            if (accessId === null || accessId === undefined) {
                throw new RequiredError('accessId', 'Required parameter accessId was null or undefined when calling activateTransactionPattern.');
            }
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new RequiredError('accountId', 'Required parameter accountId was null or undefined when calling activateTransactionPattern.');
            }
            // verify required parameter 'patternId' is not null or undefined
            if (patternId === null || patternId === undefined) {
                throw new RequiredError('patternId', 'Required parameter patternId was null or undefined when calling activateTransactionPattern.');
            }
            // verify required parameter 'activated' is not null or undefined
            if (activated === null || activated === undefined) {
                throw new RequiredError('activated', 'Required parameter activated was null or undefined when calling activateTransactionPattern.');
            }
            var localVarPath = "/accesses/{accessId}/accounts/{accountId}/transactionpatterns/{patternId}/active/{activated}"
                .replace("{" + "accessId" + "}", encodeURIComponent(String(accessId)))
                .replace("{" + "accountId" + "}", encodeURIComponent(String(accountId)))
                .replace("{" + "patternId" + "}", encodeURIComponent(String(patternId)))
                .replace("{" + "activated" + "}", encodeURIComponent(String(activated)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                var localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth2", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete the transaction pattern identified by the **patternId**. All associated transactions will be updated to {{patternId = null}}.
         * @summary Delete transaction pattern
         * @param {string} accessId The **accessId** for the transaction pattern to delete
         * @param {string} accountId The **accountId** for the transaction pattern to delete
         * @param {string} patternId The **patternId** to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTransactionPattern: function (accessId, accountId, patternId, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'accessId' is not null or undefined
            if (accessId === null || accessId === undefined) {
                throw new RequiredError('accessId', 'Required parameter accessId was null or undefined when calling deleteTransactionPattern.');
            }
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new RequiredError('accountId', 'Required parameter accountId was null or undefined when calling deleteTransactionPattern.');
            }
            // verify required parameter 'patternId' is not null or undefined
            if (patternId === null || patternId === undefined) {
                throw new RequiredError('patternId', 'Required parameter patternId was null or undefined when calling deleteTransactionPattern.');
            }
            var localVarPath = "/accesses/{accessId}/accounts/{accountId}/transactionpatterns/{patternId}"
                .replace("{" + "accessId" + "}", encodeURIComponent(String(accessId)))
                .replace("{" + "accountId" + "}", encodeURIComponent(String(accountId)))
                .replace("{" + "patternId" + "}", encodeURIComponent(String(patternId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                var localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth2", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the transaction pattern identified by **patternId** in relationship with  **accountId**.
         * @summary Get transaction pattern
         * @param {string} accessId The **accessId** for the pattern to retrieve
         * @param {string} accountId The **accoundId** for the pattern to retrieve
         * @param {string} patternId The **patternId** for the pattern to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionPattern: function (accessId, accountId, patternId, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'accessId' is not null or undefined
            if (accessId === null || accessId === undefined) {
                throw new RequiredError('accessId', 'Required parameter accessId was null or undefined when calling getTransactionPattern.');
            }
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new RequiredError('accountId', 'Required parameter accountId was null or undefined when calling getTransactionPattern.');
            }
            // verify required parameter 'patternId' is not null or undefined
            if (patternId === null || patternId === undefined) {
                throw new RequiredError('patternId', 'Required parameter patternId was null or undefined when calling getTransactionPattern.');
            }
            var localVarPath = "/accesses/{accessId}/accounts/{accountId}/transactionpatterns/{patternId}"
                .replace("{" + "accessId" + "}", encodeURIComponent(String(accessId)))
                .replace("{" + "accountId" + "}", encodeURIComponent(String(accountId)))
                .replace("{" + "patternId" + "}", encodeURIComponent(String(patternId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                var localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth2", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all transaction pattern for **accountId**. Transaction patterns are recurring transactions automatically identified by the server or manually created via [create transaction pattern](#!/Transaction_pattern/postTransactionPattern).
         * @summary List transaction patterns for account
         * @param {string} accessId The **accessId** for which to retrieve transaction patterns
         * @param {string} accountId The **accountId** for which to retrieve transaction patterns
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactionPatterns: function (accessId, accountId, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'accessId' is not null or undefined
            if (accessId === null || accessId === undefined) {
                throw new RequiredError('accessId', 'Required parameter accessId was null or undefined when calling listTransactionPatterns.');
            }
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new RequiredError('accountId', 'Required parameter accountId was null or undefined when calling listTransactionPatterns.');
            }
            var localVarPath = "/accesses/{accessId}/accounts/{accountId}/transactionpatterns"
                .replace("{" + "accessId" + "}", encodeURIComponent(String(accessId)))
                .replace("{" + "accountId" + "}", encodeURIComponent(String(accountId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                var localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth2", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new pattern for an **accountId**. The **cycle** can be one of `MONTHLY`, `QUARTERLY`, `SEMI_ANNUALLY` or `ANNUALLY`. The **day** can be between `1` and `366`, depending on **cycle**:  | cycle | day range | example | | --- | --- | --- | | `MONTHLY` | `1`-`31`  | every 29th of the month => `29` | | `QUARTERLY` | `1`-`92`  | 23rd of February (23rd of May, etc.) => `54` (31 [complete first month] + 23 [days in second month]) | | `SEMI_ANNUALLY` | `1`-`184` | 1st of May and 1st of November => `121` (for first half of year: 31 + 28 + 31 + 30 + 1) | | `ANNUALLY` | `1`-`366` | 24th of December => `358` |  If a similar pattern already exists, you will receive an HTTP status code 409.
         * @summary Create a new pattern
         * @param {string} accessId The **accessId** to which the new created pattern is associated with
         * @param {string} accountId The **accountId** to which the new created pattern is associated with
         * @param {TransactionPattern} transactionPatternDto The transaction pattern to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTransactionPattern: function (accessId, accountId, transactionPatternDto, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'accessId' is not null or undefined
            if (accessId === null || accessId === undefined) {
                throw new RequiredError('accessId', 'Required parameter accessId was null or undefined when calling postTransactionPattern.');
            }
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new RequiredError('accountId', 'Required parameter accountId was null or undefined when calling postTransactionPattern.');
            }
            // verify required parameter 'transactionPatternDto' is not null or undefined
            if (transactionPatternDto === null || transactionPatternDto === undefined) {
                throw new RequiredError('transactionPatternDto', 'Required parameter transactionPatternDto was null or undefined when calling postTransactionPattern.');
            }
            var localVarPath = "/accesses/{accessId}/accounts/{accountId}/transactionpatterns"
                .replace("{" + "accessId" + "}", encodeURIComponent(String(accessId)))
                .replace("{" + "accountId" + "}", encodeURIComponent(String(accountId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                var localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth2", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = ("TransactionPattern" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(transactionPatternDto || {}) : (transactionPatternDto || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * TransactionPatternApi - functional programming interface
 * @export
 */
exports.TransactionPatternApiFp = function (configuration) {
    return {
        /**
         * Disabling the transaction pattern results in ignoring the pattern in the forecast. The transaction still exists and relations with transactions are not modified.
         * @summary Enable a transaction pattern
         * @param {string} accessId The **accessId** for which to activate the pattern
         * @param {string} accountId The **accountId** for which to activate the pattern
         * @param {string} patternId The **patternId** to (de)activate
         * @param {boolean} activated If &#x60;true&#x60;, the pattern will be used for forecast calculations;         &#x60;false&#x60; will be ignored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateTransactionPattern: function (accessId, accountId, patternId, activated, options) {
            var localVarFetchArgs = exports.TransactionPatternApiFetchParamCreator(configuration).activateTransactionPattern(accessId, accountId, patternId, activated, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete the transaction pattern identified by the **patternId**. All associated transactions will be updated to {{patternId = null}}.
         * @summary Delete transaction pattern
         * @param {string} accessId The **accessId** for the transaction pattern to delete
         * @param {string} accountId The **accountId** for the transaction pattern to delete
         * @param {string} patternId The **patternId** to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTransactionPattern: function (accessId, accountId, patternId, options) {
            var localVarFetchArgs = exports.TransactionPatternApiFetchParamCreator(configuration).deleteTransactionPattern(accessId, accountId, patternId, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns the transaction pattern identified by **patternId** in relationship with  **accountId**.
         * @summary Get transaction pattern
         * @param {string} accessId The **accessId** for the pattern to retrieve
         * @param {string} accountId The **accoundId** for the pattern to retrieve
         * @param {string} patternId The **patternId** for the pattern to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionPattern: function (accessId, accountId, patternId, options) {
            var localVarFetchArgs = exports.TransactionPatternApiFetchParamCreator(configuration).getTransactionPattern(accessId, accountId, patternId, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns all transaction pattern for **accountId**. Transaction patterns are recurring transactions automatically identified by the server or manually created via [create transaction pattern](#!/Transaction_pattern/postTransactionPattern).
         * @summary List transaction patterns for account
         * @param {string} accessId The **accessId** for which to retrieve transaction patterns
         * @param {string} accountId The **accountId** for which to retrieve transaction patterns
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactionPatterns: function (accessId, accountId, options) {
            var localVarFetchArgs = exports.TransactionPatternApiFetchParamCreator(configuration).listTransactionPatterns(accessId, accountId, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create a new pattern for an **accountId**. The **cycle** can be one of `MONTHLY`, `QUARTERLY`, `SEMI_ANNUALLY` or `ANNUALLY`. The **day** can be between `1` and `366`, depending on **cycle**:  | cycle | day range | example | | --- | --- | --- | | `MONTHLY` | `1`-`31`  | every 29th of the month => `29` | | `QUARTERLY` | `1`-`92`  | 23rd of February (23rd of May, etc.) => `54` (31 [complete first month] + 23 [days in second month]) | | `SEMI_ANNUALLY` | `1`-`184` | 1st of May and 1st of November => `121` (for first half of year: 31 + 28 + 31 + 30 + 1) | | `ANNUALLY` | `1`-`366` | 24th of December => `358` |  If a similar pattern already exists, you will receive an HTTP status code 409.
         * @summary Create a new pattern
         * @param {string} accessId The **accessId** to which the new created pattern is associated with
         * @param {string} accountId The **accountId** to which the new created pattern is associated with
         * @param {TransactionPattern} transactionPatternDto The transaction pattern to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTransactionPattern: function (accessId, accountId, transactionPatternDto, options) {
            var localVarFetchArgs = exports.TransactionPatternApiFetchParamCreator(configuration).postTransactionPattern(accessId, accountId, transactionPatternDto, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * TransactionPatternApi - factory interface
 * @export
 */
exports.TransactionPatternApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Disabling the transaction pattern results in ignoring the pattern in the forecast. The transaction still exists and relations with transactions are not modified.
         * @summary Enable a transaction pattern
         * @param {string} accessId The **accessId** for which to activate the pattern
         * @param {string} accountId The **accountId** for which to activate the pattern
         * @param {string} patternId The **patternId** to (de)activate
         * @param {boolean} activated If &#x60;true&#x60;, the pattern will be used for forecast calculations;         &#x60;false&#x60; will be ignored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateTransactionPattern: function (accessId, accountId, patternId, activated, options) {
            return exports.TransactionPatternApiFp(configuration).activateTransactionPattern(accessId, accountId, patternId, activated, options)(fetch, basePath);
        },
        /**
         * Delete the transaction pattern identified by the **patternId**. All associated transactions will be updated to {{patternId = null}}.
         * @summary Delete transaction pattern
         * @param {string} accessId The **accessId** for the transaction pattern to delete
         * @param {string} accountId The **accountId** for the transaction pattern to delete
         * @param {string} patternId The **patternId** to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTransactionPattern: function (accessId, accountId, patternId, options) {
            return exports.TransactionPatternApiFp(configuration).deleteTransactionPattern(accessId, accountId, patternId, options)(fetch, basePath);
        },
        /**
         * Returns the transaction pattern identified by **patternId** in relationship with  **accountId**.
         * @summary Get transaction pattern
         * @param {string} accessId The **accessId** for the pattern to retrieve
         * @param {string} accountId The **accoundId** for the pattern to retrieve
         * @param {string} patternId The **patternId** for the pattern to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionPattern: function (accessId, accountId, patternId, options) {
            return exports.TransactionPatternApiFp(configuration).getTransactionPattern(accessId, accountId, patternId, options)(fetch, basePath);
        },
        /**
         * Returns all transaction pattern for **accountId**. Transaction patterns are recurring transactions automatically identified by the server or manually created via [create transaction pattern](#!/Transaction_pattern/postTransactionPattern).
         * @summary List transaction patterns for account
         * @param {string} accessId The **accessId** for which to retrieve transaction patterns
         * @param {string} accountId The **accountId** for which to retrieve transaction patterns
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactionPatterns: function (accessId, accountId, options) {
            return exports.TransactionPatternApiFp(configuration).listTransactionPatterns(accessId, accountId, options)(fetch, basePath);
        },
        /**
         * Create a new pattern for an **accountId**. The **cycle** can be one of `MONTHLY`, `QUARTERLY`, `SEMI_ANNUALLY` or `ANNUALLY`. The **day** can be between `1` and `366`, depending on **cycle**:  | cycle | day range | example | | --- | --- | --- | | `MONTHLY` | `1`-`31`  | every 29th of the month => `29` | | `QUARTERLY` | `1`-`92`  | 23rd of February (23rd of May, etc.) => `54` (31 [complete first month] + 23 [days in second month]) | | `SEMI_ANNUALLY` | `1`-`184` | 1st of May and 1st of November => `121` (for first half of year: 31 + 28 + 31 + 30 + 1) | | `ANNUALLY` | `1`-`366` | 24th of December => `358` |  If a similar pattern already exists, you will receive an HTTP status code 409.
         * @summary Create a new pattern
         * @param {string} accessId The **accessId** to which the new created pattern is associated with
         * @param {string} accountId The **accountId** to which the new created pattern is associated with
         * @param {TransactionPattern} transactionPatternDto The transaction pattern to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTransactionPattern: function (accessId, accountId, transactionPatternDto, options) {
            return exports.TransactionPatternApiFp(configuration).postTransactionPattern(accessId, accountId, transactionPatternDto, options)(fetch, basePath);
        },
    };
};
/**
 * TransactionPatternApi - object-oriented interface
 * @export
 * @class TransactionPatternApi
 * @extends {BaseAPI}
 */
var TransactionPatternApi = /** @class */ (function (_super) {
    __extends(TransactionPatternApi, _super);
    function TransactionPatternApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Disabling the transaction pattern results in ignoring the pattern in the forecast. The transaction still exists and relations with transactions are not modified.
     * @summary Enable a transaction pattern
     * @param {string} accessId The **accessId** for which to activate the pattern
     * @param {string} accountId The **accountId** for which to activate the pattern
     * @param {string} patternId The **patternId** to (de)activate
     * @param {boolean} activated If &#x60;true&#x60;, the pattern will be used for forecast calculations;         &#x60;false&#x60; will be ignored
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionPatternApi
     */
    TransactionPatternApi.prototype.activateTransactionPattern = function (accessId, accountId, patternId, activated, options) {
        return exports.TransactionPatternApiFp(this.configuration).activateTransactionPattern(accessId, accountId, patternId, activated, options)(this.fetch, this.basePath);
    };
    /**
     * Delete the transaction pattern identified by the **patternId**. All associated transactions will be updated to {{patternId = null}}.
     * @summary Delete transaction pattern
     * @param {string} accessId The **accessId** for the transaction pattern to delete
     * @param {string} accountId The **accountId** for the transaction pattern to delete
     * @param {string} patternId The **patternId** to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionPatternApi
     */
    TransactionPatternApi.prototype.deleteTransactionPattern = function (accessId, accountId, patternId, options) {
        return exports.TransactionPatternApiFp(this.configuration).deleteTransactionPattern(accessId, accountId, patternId, options)(this.fetch, this.basePath);
    };
    /**
     * Returns the transaction pattern identified by **patternId** in relationship with  **accountId**.
     * @summary Get transaction pattern
     * @param {string} accessId The **accessId** for the pattern to retrieve
     * @param {string} accountId The **accoundId** for the pattern to retrieve
     * @param {string} patternId The **patternId** for the pattern to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionPatternApi
     */
    TransactionPatternApi.prototype.getTransactionPattern = function (accessId, accountId, patternId, options) {
        return exports.TransactionPatternApiFp(this.configuration).getTransactionPattern(accessId, accountId, patternId, options)(this.fetch, this.basePath);
    };
    /**
     * Returns all transaction pattern for **accountId**. Transaction patterns are recurring transactions automatically identified by the server or manually created via [create transaction pattern](#!/Transaction_pattern/postTransactionPattern).
     * @summary List transaction patterns for account
     * @param {string} accessId The **accessId** for which to retrieve transaction patterns
     * @param {string} accountId The **accountId** for which to retrieve transaction patterns
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionPatternApi
     */
    TransactionPatternApi.prototype.listTransactionPatterns = function (accessId, accountId, options) {
        return exports.TransactionPatternApiFp(this.configuration).listTransactionPatterns(accessId, accountId, options)(this.fetch, this.basePath);
    };
    /**
     * Create a new pattern for an **accountId**. The **cycle** can be one of `MONTHLY`, `QUARTERLY`, `SEMI_ANNUALLY` or `ANNUALLY`. The **day** can be between `1` and `366`, depending on **cycle**:  | cycle | day range | example | | --- | --- | --- | | `MONTHLY` | `1`-`31`  | every 29th of the month => `29` | | `QUARTERLY` | `1`-`92`  | 23rd of February (23rd of May, etc.) => `54` (31 [complete first month] + 23 [days in second month]) | | `SEMI_ANNUALLY` | `1`-`184` | 1st of May and 1st of November => `121` (for first half of year: 31 + 28 + 31 + 30 + 1) | | `ANNUALLY` | `1`-`366` | 24th of December => `358` |  If a similar pattern already exists, you will receive an HTTP status code 409.
     * @summary Create a new pattern
     * @param {string} accessId The **accessId** to which the new created pattern is associated with
     * @param {string} accountId The **accountId** to which the new created pattern is associated with
     * @param {TransactionPattern} transactionPatternDto The transaction pattern to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionPatternApi
     */
    TransactionPatternApi.prototype.postTransactionPattern = function (accessId, accountId, transactionPatternDto, options) {
        return exports.TransactionPatternApiFp(this.configuration).postTransactionPattern(accessId, accountId, transactionPatternDto, options)(this.fetch, this.basePath);
    };
    return TransactionPatternApi;
}(BaseAPI));
exports.TransactionPatternApi = TransactionPatternApi;
/**
 * TransactionSummaryApi - fetch parameter creator
 * @export
 */
exports.TransactionSummaryApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Retrieve account summaries and provide a sum for incoming and outgoing transactions.
         * @summary List account summaries
         * @param {string} accessId The **accessId** for which to list the summaries
         * @param {string} accountId The **accountId** for which to list the summaries
         * @param {number} [limit] Optional — limit the number of returned summary entries
         * @param {number} [offset] Optional — skip the first **offset** summary entries in the result
         * @param {string} [from] Optional — only return summary entries later than **from**; an         ISO8601 Date (2014-11-17)
         * @param {string} [to] Optional — only return summary entries prior or equal to         **to**; an ISO8601 Date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSummary: function (accessId, accountId, limit, offset, from, to, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'accessId' is not null or undefined
            if (accessId === null || accessId === undefined) {
                throw new RequiredError('accessId', 'Required parameter accessId was null or undefined when calling listSummary.');
            }
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new RequiredError('accountId', 'Required parameter accountId was null or undefined when calling listSummary.');
            }
            var localVarPath = "/accesses/{accessId}/accounts/{accountId}/transactionsummaries"
                .replace("{" + "accessId" + "}", encodeURIComponent(String(accessId)))
                .replace("{" + "accountId" + "}", encodeURIComponent(String(accountId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                var localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth2", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }
            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * TransactionSummaryApi - functional programming interface
 * @export
 */
exports.TransactionSummaryApiFp = function (configuration) {
    return {
        /**
         * Retrieve account summaries and provide a sum for incoming and outgoing transactions.
         * @summary List account summaries
         * @param {string} accessId The **accessId** for which to list the summaries
         * @param {string} accountId The **accountId** for which to list the summaries
         * @param {number} [limit] Optional — limit the number of returned summary entries
         * @param {number} [offset] Optional — skip the first **offset** summary entries in the result
         * @param {string} [from] Optional — only return summary entries later than **from**; an         ISO8601 Date (2014-11-17)
         * @param {string} [to] Optional — only return summary entries prior or equal to         **to**; an ISO8601 Date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSummary: function (accessId, accountId, limit, offset, from, to, options) {
            var localVarFetchArgs = exports.TransactionSummaryApiFetchParamCreator(configuration).listSummary(accessId, accountId, limit, offset, from, to, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * TransactionSummaryApi - factory interface
 * @export
 */
exports.TransactionSummaryApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Retrieve account summaries and provide a sum for incoming and outgoing transactions.
         * @summary List account summaries
         * @param {string} accessId The **accessId** for which to list the summaries
         * @param {string} accountId The **accountId** for which to list the summaries
         * @param {number} [limit] Optional — limit the number of returned summary entries
         * @param {number} [offset] Optional — skip the first **offset** summary entries in the result
         * @param {string} [from] Optional — only return summary entries later than **from**; an         ISO8601 Date (2014-11-17)
         * @param {string} [to] Optional — only return summary entries prior or equal to         **to**; an ISO8601 Date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSummary: function (accessId, accountId, limit, offset, from, to, options) {
            return exports.TransactionSummaryApiFp(configuration).listSummary(accessId, accountId, limit, offset, from, to, options)(fetch, basePath);
        },
    };
};
/**
 * TransactionSummaryApi - object-oriented interface
 * @export
 * @class TransactionSummaryApi
 * @extends {BaseAPI}
 */
var TransactionSummaryApi = /** @class */ (function (_super) {
    __extends(TransactionSummaryApi, _super);
    function TransactionSummaryApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Retrieve account summaries and provide a sum for incoming and outgoing transactions.
     * @summary List account summaries
     * @param {string} accessId The **accessId** for which to list the summaries
     * @param {string} accountId The **accountId** for which to list the summaries
     * @param {number} [limit] Optional — limit the number of returned summary entries
     * @param {number} [offset] Optional — skip the first **offset** summary entries in the result
     * @param {string} [from] Optional — only return summary entries later than **from**; an         ISO8601 Date (2014-11-17)
     * @param {string} [to] Optional — only return summary entries prior or equal to         **to**; an ISO8601 Date
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionSummaryApi
     */
    TransactionSummaryApi.prototype.listSummary = function (accessId, accountId, limit, offset, from, to, options) {
        return exports.TransactionSummaryApiFp(this.configuration).listSummary(accessId, accountId, limit, offset, from, to, options)(this.fetch, this.basePath);
    };
    return TransactionSummaryApi;
}(BaseAPI));
exports.TransactionSummaryApi = TransactionSummaryApi;
/**
 * TransferApi - fetch parameter creator
 * @export
 */
exports.TransferApiFetchParamCreator = function (configuration) {
    return {
        /**
         * The transfer represents a money  transfer from the account identified by its id to another bank account.  **Please note:** Exception from the norm. This POST request will not return  the two header fields X-Id and Location. Also, the returned JSON document  does not represent the transfer entity, but a temporary placeholder.  The transfer is processed asynchronous and needs a message URL zu be configured  to report back the tan challenge and when it is finished.
         * @summary Create a new transfer
         * @param {string} accessId
         * @param {string} accountId The **id** for the account.
         * @param {Transfer} transfer transfer to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTransfer: function (accessId, accountId, transfer, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'accessId' is not null or undefined
            if (accessId === null || accessId === undefined) {
                throw new RequiredError('accessId', 'Required parameter accessId was null or undefined when calling postTransfer.');
            }
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new RequiredError('accountId', 'Required parameter accountId was null or undefined when calling postTransfer.');
            }
            // verify required parameter 'transfer' is not null or undefined
            if (transfer === null || transfer === undefined) {
                throw new RequiredError('transfer', 'Required parameter transfer was null or undefined when calling postTransfer.');
            }
            var localVarPath = "/accesses/{accessId}/accounts/{accountId}/transfers"
                .replace("{" + "accessId" + "}", encodeURIComponent(String(accessId)))
                .replace("{" + "accountId" + "}", encodeURIComponent(String(accountId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                var localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth2", [])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = ("Transfer" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(transfer || {}) : (transfer || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * TransferApi - functional programming interface
 * @export
 */
exports.TransferApiFp = function (configuration) {
    return {
        /**
         * The transfer represents a money  transfer from the account identified by its id to another bank account.  **Please note:** Exception from the norm. This POST request will not return  the two header fields X-Id and Location. Also, the returned JSON document  does not represent the transfer entity, but a temporary placeholder.  The transfer is processed asynchronous and needs a message URL zu be configured  to report back the tan challenge and when it is finished.
         * @summary Create a new transfer
         * @param {string} accessId
         * @param {string} accountId The **id** for the account.
         * @param {Transfer} transfer transfer to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTransfer: function (accessId, accountId, transfer, options) {
            var localVarFetchArgs = exports.TransferApiFetchParamCreator(configuration).postTransfer(accessId, accountId, transfer, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * TransferApi - factory interface
 * @export
 */
exports.TransferApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * The transfer represents a money  transfer from the account identified by its id to another bank account.  **Please note:** Exception from the norm. This POST request will not return  the two header fields X-Id and Location. Also, the returned JSON document  does not represent the transfer entity, but a temporary placeholder.  The transfer is processed asynchronous and needs a message URL zu be configured  to report back the tan challenge and when it is finished.
         * @summary Create a new transfer
         * @param {string} accessId
         * @param {string} accountId The **id** for the account.
         * @param {Transfer} transfer transfer to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTransfer: function (accessId, accountId, transfer, options) {
            return exports.TransferApiFp(configuration).postTransfer(accessId, accountId, transfer, options)(fetch, basePath);
        },
    };
};
/**
 * TransferApi - object-oriented interface
 * @export
 * @class TransferApi
 * @extends {BaseAPI}
 */
var TransferApi = /** @class */ (function (_super) {
    __extends(TransferApi, _super);
    function TransferApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * The transfer represents a money  transfer from the account identified by its id to another bank account.  **Please note:** Exception from the norm. This POST request will not return  the two header fields X-Id and Location. Also, the returned JSON document  does not represent the transfer entity, but a temporary placeholder.  The transfer is processed asynchronous and needs a message URL zu be configured  to report back the tan challenge and when it is finished.
     * @summary Create a new transfer
     * @param {string} accessId
     * @param {string} accountId The **id** for the account.
     * @param {Transfer} transfer transfer to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransferApi
     */
    TransferApi.prototype.postTransfer = function (accessId, accountId, transfer, options) {
        return exports.TransferApiFp(this.configuration).postTransfer(accessId, accountId, transfer, options)(this.fetch, this.basePath);
    };
    return TransferApi;
}(BaseAPI));
exports.TransferApi = TransferApi;
