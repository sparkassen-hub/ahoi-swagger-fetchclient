/**
 *
 * [AHOI cookbook](/ahoi/docs/cookbook/index.html)  [Data Privacy](/sandboxmanager/#/privacy)  [Terms of Service](/sandboxmanager/#/terms)  [Imprint](https://sparkassen-hub.com/impressum/)  &copy; 2016&dash;2017 Starfinanz - Ein Unternehmen der Finanz Informatik
 *
 * OpenAPI spec version: 2.1.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
/// <reference path="../custom.d.ts" />
import { Configuration } from "./configuration";
/**
 *
 * @export
 */
export declare const COLLECTION_FORMATS: {
    csv: string;
    ssv: string;
    tsv: string;
    pipes: string;
};
/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}
/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}
/**
 *
 * @export
 * @class BaseAPI
 */
export declare class BaseAPI {
    protected basePath: string;
    protected fetch: FetchAPI;
    protected configuration: Configuration;
    constructor(configuration?: Configuration, basePath?: string, fetch?: FetchAPI);
}
/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export declare class RequiredError extends Error {
    field: string;
    name: "RequiredError";
    constructor(field: string, msg?: string);
}
/**
 *
 * @export
 * @interface Access
 */
export interface Access {
    /**
     * Internal ID of this access (generated value)
     * @type {string}
     * @memberof Access
     */
    id?: string;
    /**
     * Identifier of the provider to which this access belongs
     * @type {string}
     * @memberof Access
     */
    providerId: string;
    /**
     * Authentication data for the given provider as a map of InputFieldId to String (e.g., `{\"USERNAME\", \"yourName\"}`)  The fields necessary for the access are determined by the   InputField descriptions of the related provider. The access fields will not be returned when accesses are read from the API.
     * @type {AccessFieldsMap}
     * @memberof Access
     */
    accessFields: AccessFieldsMap;
    /**
     * The state reflects the validity of the access credentials. The state can change after communicating with the provider.  It can be OK (access credentials are valid); `ACCESS_LOCKED` (access is locked: This can happen when, for example, someone tried to login to your account by  using an incorrect PIN too many times or if your account was used for illegal purposes — automatic refresh will be disabled); or `ACCESS_WRONG` (access wrong: Saved  credentials are incorrect and no communication with the provider is possible — automatic refresh will be disabled).
     * @type {string}
     * @memberof Access
     */
    validationState?: Access.ValidationStateEnum;
    /**
     * Discriminator for subtypes. At the moment only `BankAccess` is supported.
     * @type {string}
     * @memberof Access
     */
    type: string;
}
/**
 * @export
 * @namespace Access
 */
export declare namespace Access {
    /**
     * @export
     * @enum {string}
     */
    enum ValidationStateEnum {
        OK,
        ACCESSLOCKED,
        ACCESSWRONG
    }
}
/**
 *
 * @export
 * @interface AccessDescription
 */
export interface AccessDescription {
    /**
     * Information text by the provider as a description for required user actions during the account setup (e.g.,   \"Provided your financial institution has not given you a separate username, please enter  your account number as your username. Depending on your financial institution,  additional information such as a customer number can be entered. Most of the time  entering this information is optional.\")
     * @type {string}
     * @memberof AccessDescription
     */
    infoText?: string;
    /**
     * Information to describe and facilitate validation of an access
     * @type {Array<InputFieldDescription>}
     * @memberof AccessDescription
     */
    fieldDescriptions?: Array<InputFieldDescription>;
}
/**
 *
 * @export
 * @interface AccessFieldsMap
 */
export interface AccessFieldsMap {
    /**
     * Should be filled with the username if the Provider object signals this as mandatory.
     * @type {string}
     * @memberof AccessFieldsMap
     */
    USERNAME?: string;
    /**
     * Should be filled with the customer number if the Provider object signals this as mandatory.
     * @type {string}
     * @memberof AccessFieldsMap
     */
    CUSTOMERNUMBER?: string;
    /**
     * Should be filled with the PIN if the Provider object signals this as mandatory. In some special production scenarios the pin has to be encrypted. We will inform you when to use the extended encryption.
     * @type {string}
     * @memberof AccessFieldsMap
     */
    PIN?: string;
}
/**
 *
 * @export
 * @interface Account
 */
export interface Account {
    /**
     * Internal ID of this account (generated value)
     * @type {string}
     * @memberof Account
     */
    id: string;
    /**
     * Account name returned by bank provider (e.g., \"Giro Account\")
     * @type {string}
     * @memberof Account
     */
    name: string;
    /**
     * Account userDefinedName. This value can be set to define a custom name used in AHOI (e.g., \"My Giro Account\").  Can be changed by using the _account_ resource.
     * @type {string}
     * @memberof Account
     */
    userDefinedName?: string;
    /**
     * Account owner returned by bank provider (e.g., \"Max Mustermann\")
     * @type {string}
     * @memberof Account
     */
    owner: string;
    /**
     * Identifier of the provider to which this account belongs
     * @type {string}
     * @memberof Account
     */
    providerId: string;
    /**
     * An account kind is a classification of its structure and its possibilities.   This is typically defined by the bank provider.
     * @type {string}
     * @memberof Account
     */
    kind: Account.KindEnum;
    /**
     * Interval that indicates the freguency at which the account is updated.   This interval is read-only and is determined by the server depending on the last use of the API. The range is between every hour, daily and monthly.
     * @type {number}
     * @memberof Account
     */
    automaticRefreshInterval: number;
    /**
     * Discriminator for subtypes. At the moment only `BankAccount` is supported.
     * @type {string}
     * @memberof Account
     */
    type: string;
}
/**
 * @export
 * @namespace Account
 */
export declare namespace Account {
    /**
     * @export
     * @enum {string}
     */
    enum KindEnum {
        GIRO,
        SPAR,
        FESTGELD,
        DEPOT,
        DARLEHEN,
        KREDITKARTE,
        BAUSPAR,
        VLSPAR,
        VLBAUSPAR,
        VLWERTPAPIERSPARVERTRAG,
        XXX
    }
}
/**
 *
 * @export
 * @interface AdditionalInformation
 */
export interface AdditionalInformation {
    /**
     * DTO ID in UUID form
     * @type {string}
     * @memberof AdditionalInformation
     */
    id: string;
    /**
     * Discriminator for subtypes. At the moment only `Category` and `Contractor` are supported.
     * @type {string}
     * @memberof AdditionalInformation
     */
    type: string;
}
/**
 *
 * @export
 * @interface Amount
 */
export interface Amount {
    /**
     * Amount value (in smallest unit; e.g., euro cents)
     * @type {number}
     * @memberof Amount
     */
    value: number;
    /**
     * Amount currency (ISO-4217; e.g., \"EUR\")
     * @type {string}
     * @memberof Amount
     */
    currency: string;
}
/**
 *
 * @export
 * @interface Balance
 */
export interface Balance {
    /**
     * Balance amount
     * @type {Amount}
     * @memberof Balance
     */
    amount: Amount;
    /**
     * Date of balance (ISO 8601: \"yyyy-MM-dd'T'HH:mm:ssX\")
     * @type {Date}
     * @memberof Balance
     */
    date: Date;
}
/**
 *
 * @export
 * @interface Challenge
 */
export interface Challenge {
    /**
     * Text of the challenge
     * @type {string}
     * @memberof Challenge
     */
    challenge?: string;
    /**
     * Additional information for authorization purposes (e.g., IBAN, BIC, amount of transfer transaction)
     * @type {string}
     * @memberof Challenge
     */
    additionalInformation?: string;
    /**
     * Only `TanChallengeDto` is supported.
     * @type {string}
     * @memberof Challenge
     */
    type: string;
}
/**
 *
 * @export
 * @interface ChallengeResponse
 */
export interface ChallengeResponse {
    /**
     * Contains the challange to be used for task authorization
     * @type {string}
     * @memberof ChallengeResponse
     */
    response: string;
    /**
     * Only `TanChallengeResponseDto` is supported
     * @type {string}
     * @memberof ChallengeResponse
     */
    type: string;
}
/**
 *
 * @export
 * @interface Contract
 */
export interface Contract {
    /**
     * Name of the contractor
     * @type {string}
     * @memberof Contract
     */
    contractorName?: string;
    /**
     * Name of assigned category
     * @type {string}
     * @memberof Contract
     */
    categoryName?: string;
    /**
     * Detected amount of the transaction
     * @type {Amount}
     * @memberof Contract
     */
    averageAmount?: Amount;
    /**
     * Interval in which a transaction is repeated
     * @type {string}
     * @memberof Contract
     */
    paymentInterval?: Contract.PaymentIntervalEnum;
    /**
     * Type of the contract
     * @type {string}
     * @memberof Contract
     */
    type?: Contract.TypeEnum;
    /**
     * First booking date detected
     * @type {string}
     * @memberof Contract
     */
    firstKnownBookingDate?: string;
    /**
     * Most recent booking date detected
     * @type {string}
     * @memberof Contract
     */
    lastKnownBookingDate?: string;
    /**
     * Estimated next booking date in the future
     * @type {string}
     * @memberof Contract
     */
    estimatedNextBookingDate?: string;
    /**
     * Estimated amount of the next booking
     * @type {Amount}
     * @memberof Contract
     */
    estimatedNextAmount?: Amount;
    /**
     * Some more details of a contract
     * @type {ContractDetailsMap}
     * @memberof Contract
     */
    contractDetails?: ContractDetailsMap;
}
/**
 * @export
 * @namespace Contract
 */
export declare namespace Contract {
    /**
     * @export
     * @enum {string}
     */
    enum PaymentIntervalEnum {
        WEEKLY,
        BIWEEKLY,
        MONTHLY,
        QUARTERLY,
        SEMIANNUAL,
        ANNUAL,
        BIENNIAL
    }
    /**
     * @export
     * @enum {string}
     */
    enum TypeEnum {
        SUBSCRIPTION,
        RENT,
        RENTREVENUES,
        SALARY,
        SALARYSIDEJOB,
        PRIVATEPENSION,
        PENSION,
        RIESTERRETIREMENTPLANPAYMENTS,
        RIESTERRETIREMENTPLANPAYOUTS
    }
}
/**
 *
 * @export
 * @interface ContractDetailsMap
 */
export interface ContractDetailsMap {
    /**
     * The customer number corresponding to the contract.
     * @type {string}
     * @memberof ContractDetailsMap
     */
    CUSTOMER_NUMBER?: string;
    /**
     * The contract number of the contract.
     * @type {string}
     * @memberof ContractDetailsMap
     */
    CONTRACT_NUMBER?: string;
    /**
     * The invoice number corresponding to the contract.
     * @type {string}
     * @memberof ContractDetailsMap
     */
    INVOICE_NUMBER?: string;
    /**
     * The license plate corresponding to the contract.
     * @type {string}
     * @memberof ContractDetailsMap
     */
    LICENSE_PLATE?: string;
    /**
     * The policy number corresponding to the contract.
     * @type {string}
     * @memberof ContractDetailsMap
     */
    POLICY_NUMBER?: string;
}
/**
 *
 * @export
 * @interface Forecast
 */
export interface Forecast {
    /**
     * Balance forecast
     * @type {Balance}
     * @memberof Forecast
     */
    forecastBalance: Balance;
    /**
     * ID of account to which this entry belongs
     * @type {string}
     * @memberof Forecast
     */
    accountId: string;
}
/**
 *
 * @export
 * @interface InputFieldDescription
 */
export interface InputFieldDescription {
    /**
     * Internal id for this field description
     * @type {string}
     * @memberof InputFieldDescription
     */
    id: InputFieldDescription.IdEnum;
    /**
     * Label for this field description (e.g., 'PIN', 'Login name', 'Customer No.')
     * @type {string}
     * @memberof InputFieldDescription
     */
    label: string;
    /**
     * Flag that indicates whether the given field value must be masked when entered on the client side or encrypted when persisting  on the server side
     * @type {boolean}
     * @memberof InputFieldDescription
     */
    masked: boolean;
    /**
     * Format of field value  Can be DEFINITELYNUMERIC (Format is definitely numeric), DEFINITELYALPHANUMERIC (Format is definitely alphanumeric),  PROBABLYALPHANUMERIC (Format is probably alphanumeric; numeric is unlikely but possible), PROBABLYNUMERIC (Format is probably  numeric; alphanumeric is unlikely but possible) or UNSPECIFIED (Default. No hint available).
     * @type {string}
     * @memberof InputFieldDescription
     */
    format: InputFieldDescription.FormatEnum;
    /**
     * Minimum length of field value (0 = no limit)
     * @type {number}
     * @memberof InputFieldDescription
     */
    lengthMin?: number;
    /**
     * Maximum length of field value (0 = no limit)
     * @type {number}
     * @memberof InputFieldDescription
     */
    lengthMax?: number;
}
/**
 * @export
 * @namespace InputFieldDescription
 */
export declare namespace InputFieldDescription {
    /**
     * @export
     * @enum {string}
     */
    enum IdEnum {
        USERNAME,
        CUSTOMERNUMBER,
        PIN,
        TAN
    }
    /**
     * @export
     * @enum {string}
     */
    enum FormatEnum {
        UNSPECIFIED,
        PROBABLYNUMERIC,
        DEFINITELYNUMERIC,
        PROBABLYALPHANUMERIC,
        DEFINITELYALPHANUMERIC
    }
}
/**
 *
 * @export
 * @interface JwkJwkPublicKey
 */
export interface JwkJwkPublicKey {
    /**
     * Key type, in this context RSA only
     * @type {string}
     * @memberof JwkJwkPublicKey
     */
    kty?: string;
    /**
     * Algorithm, in this context RSA-OAEP (RSA_2048_SHA1) only.
     * @type {string}
     * @memberof JwkJwkPublicKey
     */
    alg?: string;
    /**
     * Public key modulus BigInteger as Base64URL encoded
     * @type {string}
     * @memberof JwkJwkPublicKey
     */
    n?: string;
    /**
     * Public key exponent BigInteger as Base64URL encoded
     * @type {string}
     * @memberof JwkJwkPublicKey
     */
    e?: string;
    /**
     * Public key ID (i.e., a random UUID per key)
     * @type {string}
     * @memberof JwkJwkPublicKey
     */
    kid?: string;
}
/**
 *
 * @export
 * @interface MonthlySummary
 */
export interface MonthlySummary {
    /**
     * MonthlySummary id in UUID form
     * @type {string}
     * @memberof MonthlySummary
     */
    id: string;
    /**
     * The month this entry belongs to (year-month in the ISO-8601: \"yyyy-MM\")
     * @type {string}
     * @memberof MonthlySummary
     */
    month: string;
    /**
     * Id of account this entry belongs to
     * @type {string}
     * @memberof MonthlySummary
     */
    accountId: string;
    /**
     * Sum of all incoming transactions for this month
     * @type {Amount}
     * @memberof MonthlySummary
     */
    income: Amount;
    /**
     * Sum of all outgoing transactions for this month
     * @type {Amount}
     * @memberof MonthlySummary
     */
    outgoings: Amount;
    /**
     * Balance at end of month
     * @type {Amount}
     * @memberof MonthlySummary
     */
    balance: Amount;
}
/**
 *
 * @export
 * @interface Provider
 */
export interface Provider {
    /**
     * UUID of this provider. A constant to identify provider even when, for  example, their bank code changes (provided type is BankProvider)
     * @type {string}
     * @memberof Provider
     */
    id: string;
    /**
     * Name of this provider (e.g., \"Hamburger Bank\")
     * @type {string}
     * @memberof Provider
     */
    name: string;
    /**
     * Location of this provider (e.g., \"Hamburg\")
     * @type {string}
     * @memberof Provider
     */
    location: string;
    /**
     * Description of the access for the account setup (e.g., UI input fields).
     * @type {AccessDescription}
     * @memberof Provider
     */
    accessDescription?: AccessDescription;
    /**
     * Whether this bank is supported by AHOI API (i.e., whether you can use a connection to this provider).
     * @type {boolean}
     * @memberof Provider
     */
    supported: boolean;
    /**
     * Discriminator for subtypes. At the moment only `BankProvider` is supported.
     * @type {string}
     * @memberof Provider
     */
    type: string;
}
/**
 *
 * @export
 * @interface RegistrationPublicKey
 */
export interface RegistrationPublicKey {
    /**
     * UUID of the public key for reference in the \"X-Ahoi-Session-Security\" header
     * @type {string}
     * @memberof RegistrationPublicKey
     */
    keyId: string;
    /**
     * Timestamp in ISO-8601 format defining when the public key expires
     * @type {string}
     * @memberof RegistrationPublicKey
     */
    validUntil: string;
    /**
     * Contains the Base64URL-encoded value and the encoding algorithm of the key
     * @type {SelfDescribedValue}
     * @memberof RegistrationPublicKey
     */
    publicKey: SelfDescribedValue;
    /**
     * Contains the Base64 URL-encoded signature of the key and the encoding algorithm of the signature
     * @type {SelfDescribedValue}
     * @memberof RegistrationPublicKey
     */
    publicKeySignature: SelfDescribedValue;
}
/**
 *
 * @export
 * @interface RegistrationResponse
 */
export interface RegistrationResponse {
    /**
     * Contains the installation ID
     * @type {string}
     * @memberof RegistrationResponse
     */
    installation?: string;
}
/**
 *
 * @export
 * @interface ResponseObjectMap
 */
export interface ResponseObjectMap {
    /**
     * The username for the authorization.
     * @type {string}
     * @memberof ResponseObjectMap
     */
    USERNAME?: string;
    /**
     * The username for the authorization.
     * @type {string}
     * @memberof ResponseObjectMap
     */
    CUSTOMERNUMBER?: string;
    /**
     * The PIN for the authorization
     * @type {string}
     * @memberof ResponseObjectMap
     */
    PIN?: string;
    /**
     * The TAN for the authorization.
     * @type {string}
     * @memberof ResponseObjectMap
     */
    TAN?: string;
}
/**
 *
 * @export
 * @interface Security
 */
export interface Security {
    /**
     * Internal ID of this security (generated value)
     * @type {string}
     * @memberof Security
     */
    id: string;
    /**
     * Wertpapierkennnummer  (German) securities identification number
     * @type {string}
     * @memberof Security
     */
    wkn?: string;
    /**
     * International Securities Identification Number
     * @type {string}
     * @memberof Security
     */
    isin?: string;
    /**
     * Name
     * @type {string}
     * @memberof Security
     */
    name?: string;
    /**
     * Price
     * @type {Amount}
     * @memberof Security
     */
    price?: Amount;
    /**
     * Source of price:   **LMAR - Local Market**   Source of price quotation is the market.     **THEO -Theoretical**   Source of price quotation is a theoretical value based on the market yield.     **VEND- Vendor**   Source of price quotation is an external vendor.
     * @type {string}
     * @memberof Security
     */
    priceSource?: Security.PriceSourceEnum;
    /**
     * api.dto.model.com-starfinanz-ahoi-dto-v2-SecurityDto.properties.quotationDate.description
     * @type {string}
     * @memberof Security
     */
    quotationDate?: string;
    /**
     * Market name/location if **priceSource** is *LMAR*
     * @type {string}
     * @memberof Security
     */
    location?: string;
    /**
     * Price qualifier:    **MRKT** - Market Price   Last reported/known price of a financial instrument in a market.    **INDC** - Indicative Price   Estimated price, for example, for valuation purposes.
     * @type {string}
     * @memberof Security
     */
    priceQualifier?: Security.PriceQualifierEnum;
    /**
     * Balance
     * @type {string}
     * @memberof Security
     */
    quantity?: string;
    /**
     * Holding value
     * @type {Amount}
     * @memberof Security
     */
    amount?: Amount;
    /**
     * Holding value in divergent currency
     * @type {Amount}
     * @memberof Security
     */
    amountDivCurr?: Amount;
    /**
     * Acquisition date
     * @type {string}
     * @memberof Security
     */
    acquisitionDate?: string;
    /**
     * Acquisition price
     * @type {Amount}
     * @memberof Security
     */
    acquisitionPrice?: Amount;
    /**
     * Due date
     * @type {string}
     * @memberof Security
     */
    dueDate?: string;
}
/**
 * @export
 * @namespace Security
 */
export declare namespace Security {
    /**
     * @export
     * @enum {string}
     */
    enum PriceSourceEnum {
        LMAR,
        THEO,
        VEND
    }
    /**
     * @export
     * @enum {string}
     */
    enum PriceQualifierEnum {
        MRKT,
        INDC
    }
}
/**
 *
 * @export
 * @interface SelfDescribedValue
 */
export interface SelfDescribedValue {
    /**
     * Key or signature value itself
     * @type {string}
     * @memberof SelfDescribedValue
     */
    value: string;
    /**
     * Specification of the encryption algorithm
     * @type {string}
     * @memberof SelfDescribedValue
     */
    specification: string;
}
/**
 *
 * @export
 * @interface TanMedia
 */
export interface TanMedia {
    /**
     * ID of this TAN media
     * @type {string}
     * @memberof TanMedia
     */
    tanMediaId: string;
    /**
     * Name of TANMedia (e.g., \"iTan\")
     * @type {string}
     * @memberof TanMedia
     */
    name: string;
    /**
     * Description of TANMedia (e.g., phone number or card number used for given type)
     * @type {string}
     * @memberof TanMedia
     */
    description: string;
}
/**
 *
 * @export
 * @interface TanScheme
 */
export interface TanScheme {
    /**
     * Internal ID of this TAN scheme (generated value)
     * @type {string}
     * @memberof TanScheme
     */
    schemeId?: string;
    /**
     * Name of the TAN scheme used
     * @type {string}
     * @memberof TanScheme
     */
    name?: string;
    /**
     * List of available TAN media for this scheme
     * @type {Array<TanMedia>}
     * @memberof TanScheme
     */
    tanMediaList?: Array<TanMedia>;
}
/**
 *
 * @export
 * @interface Task
 */
export interface Task {
    /**
     * Represents the state of this task
     * @type {string}
     * @memberof Task
     */
    state?: Task.StateEnum;
    /**
     * UUID of this task to be used for identification on further task actions
     * @type {string}
     * @memberof Task
     */
    id?: string;
    /**
     * Discriminator for subtypes. At the moment only `TransferTask` is supported.
     * @type {string}
     * @memberof Task
     */
    type: string;
}
/**
 * @export
 * @namespace Task
 */
export declare namespace Task {
    /**
     * @export
     * @enum {string}
     */
    enum StateEnum {
        UNKNOWN,
        INITIAL,
        DONE,
        FAILED,
        AUTHORIZATIONPENDING,
        AUTHORIZATIONWRONG
    }
}
/**
 *
 * @export
 * @interface Transaction
 */
export interface Transaction {
    /**
     * Internal ID of this transaction (generated value)
     * @type {string}
     * @memberof Transaction
     */
    id: string;
    /**
     * Identifier of the transactionPattern to which this transaction belongs
     * @type {string}
     * @memberof Transaction
     */
    transactionPatternId?: string;
    /**
     * api.dto.model.com-starfinanz-ahoi-dto-v2-TransactionDto.properties.additionalInformation.description
     * @type {Array<AdditionalInformation>}
     * @memberof Transaction
     */
    additionalInformation?: Array<AdditionalInformation>;
    /**
     * Discriminator for subtypes. At the moment only `GiroTransaction` is supported.
     * @type {string}
     * @memberof Transaction
     */
    type: string;
}
/**
 *
 * @export
 * @interface TransactionPattern
 */
export interface TransactionPattern {
    /**
     * Internal ID of this transactionPattern (generated value)
     * @type {string}
     * @memberof TransactionPattern
     */
    id?: string;
    /**
     * The state of this pattern  can be `ACTIVE` (default) or `INACTIVE` (user has disabled it)
     * @type {string}
     * @memberof TransactionPattern
     */
    state: TransactionPattern.StateEnum;
    /**
     * Frequency of occurrence for this pattern
     * @type {string}
     * @memberof TransactionPattern
     */
    cycle: TransactionPattern.CycleEnum;
    /**
     * Origin of creation can be `FINDER` (automatically found) or `MANUAL` (created by user). Cannot be set with creation or update.
     * @type {string}
     * @memberof TransactionPattern
     */
    origin?: TransactionPattern.OriginEnum;
    /**
     * Day in the cycle this pattern occurs
     * @type {number}
     * @memberof TransactionPattern
     */
    day: number;
    /**
     * Name of owner of related account (debtor or creditor)
     * @type {string}
     * @memberof TransactionPattern
     */
    relatedAccountOwner: string;
    /**
     * Amount value
     * @type {Amount}
     * @memberof TransactionPattern
     */
    amount: Amount;
    /**
     * Account number or IBAN of related account (debtor or creditor)
     * @type {string}
     * @memberof TransactionPattern
     */
    accountNumber: string;
    /**
     * Bank code number or BIC of related account (debtor or creditor)
     * @type {string}
     * @memberof TransactionPattern
     */
    bankCode: string;
    /**
     * Kind of transaction (e.g., \"Lastschrift\" or \"Dauerauftrag\")
     * @type {string}
     * @memberof TransactionPattern
     */
    kind?: string;
}
/**
 * @export
 * @namespace TransactionPattern
 */
export declare namespace TransactionPattern {
    /**
     * @export
     * @enum {string}
     */
    enum StateEnum {
        INACTIVE,
        ACTIVE
    }
    /**
     * @export
     * @enum {string}
     */
    enum CycleEnum {
        MONTHLY,
        QUARTERLY,
        SEMIANNUALLY,
        ANNUALLY
    }
    /**
     * @export
     * @enum {string}
     */
    enum OriginEnum {
        FINDER,
        MANUAL
    }
}
/**
 *
 * @export
 * @interface Transfer
 */
export interface Transfer {
    /**
     * IBAN - International Bank Account Number (defined in ISO 13616-1)
     * @type {string}
     * @memberof Transfer
     */
    iban: string;
    /**
     * BIC - Business Identifier Code (defined in ISO-9362)
     * @type {string}
     * @memberof Transfer
     */
    bic?: string;
    /**
     * Name - Name of the creditor
     * @type {string}
     * @memberof Transfer
     */
    name: string;
    /**
     * Amount to be transfered
     * @type {Amount}
     * @memberof Transfer
     */
    amount: Amount;
    /**
     * Purpose
     * @type {string}
     * @memberof Transfer
     */
    purpose?: string;
}
/**
 *
 * @export
 * @interface BankAccess
 */
export interface BankAccess extends Access {
}
/**
 * @export
 * @namespace BankAccess
 */
export declare namespace BankAccess {
}
/**
 *
 * @export
 * @interface BankAccount
 */
export interface BankAccount extends Account {
    /**
     * Account number (national)
     * @type {string}
     * @memberof BankAccount
     */
    number: string;
    /**
     * Bank code (i.e., routing number) (BLZ, national, 8 digits)
     * @type {string}
     * @memberof BankAccount
     */
    bankCodeNumber: string;
    /**
     * Business Identifier Code (BIC; ISO 9362)
     * @type {string}
     * @memberof BankAccount
     */
    bic: string;
    /**
     * International Bank Account Number (IBAN; ISO 13616-1)
     * @type {string}
     * @memberof BankAccount
     */
    iban: string;
    /**
     * Account currency (ISO 4217) (e.g., \"EUR\")
     * @type {string}
     * @memberof BankAccount
     */
    currency: string;
    /**
     * Current balance. This value is set whenever the account is refreshed.
     * @type {Balance}
     * @memberof BankAccount
     */
    balance: Balance;
}
/**
 * @export
 * @namespace BankAccount
 */
export declare namespace BankAccount {
}
/**
 *
 * @export
 * @interface BankProvider
 */
export interface BankProvider extends Provider {
    /**
     * Bank code (i.e., routing number) (BLZ, national 8 digits)
     * @type {string}
     * @memberof BankProvider
     */
    bankCode: string;
    /**
     * Business Identifier Code (defined in ISO-9362)
     * @type {string}
     * @memberof BankProvider
     */
    bic: string;
}
/**
 *
 * @export
 * @interface Category
 */
export interface Category extends AdditionalInformation {
    /**
     * Parent category id in UUID form
     * @type {string}
     * @memberof Category
     */
    parent?: string;
    /**
     * Category name
     * @type {string}
     * @memberof Category
     */
    name: string;
    /**
     * Origin id (i.e., the id within the origin id service)
     * @type {string}
     * @memberof Category
     */
    originId?: string;
    /**
     * Origin name
     * @type {string}
     * @memberof Category
     */
    origin: string;
}
/**
 *
 * @export
 * @interface Contractor
 */
export interface Contractor extends AdditionalInformation {
    /**
     * api.dto.model.com-starfinanz-ahoi-dto-v2-ContractorDto.properties.contractorId.description
     * @type {number}
     * @memberof Contractor
     */
    contractorId?: number;
}
/**
 *
 * @export
 * @interface ForecastTransaction
 */
export interface ForecastTransaction {
    /**
     * Balance forecast
     * @type {Balance}
     * @memberof ForecastTransaction
     */
    forecastBalance: Balance;
    /**
     * Id of account this entry belongs to
     * @type {string}
     * @memberof ForecastTransaction
     */
    accountId: string;
    /**
     * List of unappliedTransaction
     * @type {Array<Transaction>}
     * @memberof ForecastTransaction
     */
    transactions: Array<Transaction>;
}
/**
 *
 * @export
 * @interface GiroTransaction
 */
export interface GiroTransaction extends Transaction {
    /**
     * Amount value
     * @type {Amount}
     * @memberof GiroTransaction
     */
    amount: Amount;
    /**
     * Booking date (ISO 8601: \"yyyy-MM-dd'T'HH:mm:ssX\")
     * @type {Date}
     * @memberof GiroTransaction
     */
    bookingDate: Date;
    /**
     * Value date (ISO 8601: \"yyyy-MM-dd'T'HH:mm:ssX\")
     * @type {Date}
     * @memberof GiroTransaction
     */
    valueDate: Date;
    /**
     * Creditor's name
     * @type {string}
     * @memberof GiroTransaction
     */
    creditor: string;
    /**
     * Creditor's bank code (i.e. routing number) or BIC
     * @type {string}
     * @memberof GiroTransaction
     */
    creditorBankCode?: string;
    /**
     * Creditor's account number or IBAN
     * @type {string}
     * @memberof GiroTransaction
     */
    creditorAccountNumber?: string;
    /**
     * Debtor's name
     * @type {string}
     * @memberof GiroTransaction
     */
    debtor: string;
    /**
     * Debtor's bank code (i.e. routing number) or BIC
     * @type {string}
     * @memberof GiroTransaction
     */
    debtorBankCode?: string;
    /**
     * Debtor's account number or IBAN
     * @type {string}
     * @memberof GiroTransaction
     */
    debtorAccountNumber?: string;
    /**
     * Purpose (as given by the provider)
     * @type {string}
     * @memberof GiroTransaction
     */
    purpose: string;
    /**
     * Cleaned purpose. Some SEPA information is filtered out (e.g., \"KREF+-1434947533-2...\")
     * @type {string}
     * @memberof GiroTransaction
     */
    cleanPurpose?: string;
    /**
     * Flag to identify if the transaction is marked as pre-booked
     * @type {boolean}
     * @memberof GiroTransaction
     */
    prebooked: boolean;
    /**
     * Booking key for transaction
     * @type {string}
     * @memberof GiroTransaction
     */
    bookingKey: string;
}
/**
 *
 * @export
 * @interface TanChallenge
 */
export interface TanChallenge extends Challenge {
    /**
     * api.dto.model.com-starfinanz-ahoi-dto-v2-TanChallengeDto.properties.challengeType.description
     * @type {string}
     * @memberof TanChallenge
     */
    challengeType?: TanChallenge.ChallengeTypeEnum;
    /**
     * Currently resource URI pointing to TAN UI input component
     * @type {string}
     * @memberof TanChallenge
     */
    tanGuiUrl?: string;
}
/**
 * @export
 * @namespace TanChallenge
 */
export declare namespace TanChallenge {
    /**
     * @export
     * @enum {string}
     */
    enum ChallengeTypeEnum {
        UNKNOWN,
        ITAN,
        CHIPTAN,
        OPTICALV3,
        OPTICALV4,
        PHOTOTAN
    }
}
/**
 *
 * @export
 * @interface TanChallengeResponse
 */
export interface TanChallengeResponse extends ChallengeResponse {
}
/**
 *
 * @export
 * @interface TransferTask
 */
export interface TransferTask extends Task {
}
/**
 * @export
 * @namespace TransferTask
 */
export declare namespace TransferTask {
}
/**
 * AccessApi - fetch parameter creator
 * @export
 */
export declare const AccessApiFetchParamCreator: (configuration?: Configuration) => {
    /**
     * Delete access with **accessId** and all related accounts
     * @summary Delete access
     * @param {string} accessId The **id** for the access to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAccess(accessId: string, options?: any): FetchArgs;
    /**
     * Retrieve the access with **accessId**. The retrieved object does not contain sensitive information such as the PIN.
     * @summary Get access
     * @param {string} accessId The **id** for the access to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAccess(accessId: string, options?: any): FetchArgs;
    /**
     * Returns all registered accesses for the authenticated user. The access fields contain confidential information (e.g., PIN) that will not be returned.
     * @summary List accesses
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAccesses(options?: any): FetchArgs;
    /**
     * Create a new access and setup all associated accounts and transactions. This will also trigger the creation of monthly transaction summaries, the analysis of all accounts for recurring transactions, and the calculation of the balance forecast.   If the credentials were invalid, the validation state is set accordingly.    It is possible to have multiple accesses for one user.
     * @summary Create a new access
     * @param {Access} accessDto A valid BankAccess object containing the required             **accessFields** as indicated by the provider object and the             **providerId**.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postAccess(accessDto: Access, options?: any): FetchArgs;
    /**
     * Update the access credentials in **accessFields**. If the access does not exist, the **accessId** does not match the **id** in **accessDto**, or the **providerId** is not the same, status code 404 is returned. If another access with the same login data already exists, status code 409 is returned.  The updated access is validated by setting up an account. Status code 200 does not imply that the credentials are correct. To check this, the client should obtain access.
     * @summary Update access
     * @param {string} accessId The **id** for the access to update
     * @param {Access} accessDto The access object that contains the changed credentials in             **accessFields**. Other fields cannot be edited.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putAccess(accessId: string, accessDto: Access, options?: any): FetchArgs;
};
/**
 * AccessApi - functional programming interface
 * @export
 */
export declare const AccessApiFp: (configuration?: Configuration) => {
    /**
     * Delete access with **accessId** and all related accounts
     * @summary Delete access
     * @param {string} accessId The **id** for the access to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAccess(accessId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response>;
    /**
     * Retrieve the access with **accessId**. The retrieved object does not contain sensitive information such as the PIN.
     * @summary Get access
     * @param {string} accessId The **id** for the access to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAccess(accessId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Access>;
    /**
     * Returns all registered accesses for the authenticated user. The access fields contain confidential information (e.g., PIN) that will not be returned.
     * @summary List accesses
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAccesses(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Access[]>;
    /**
     * Create a new access and setup all associated accounts and transactions. This will also trigger the creation of monthly transaction summaries, the analysis of all accounts for recurring transactions, and the calculation of the balance forecast.   If the credentials were invalid, the validation state is set accordingly.    It is possible to have multiple accesses for one user.
     * @summary Create a new access
     * @param {Access} accessDto A valid BankAccess object containing the required             **accessFields** as indicated by the provider object and the             **providerId**.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postAccess(accessDto: Access, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Access>;
    /**
     * Update the access credentials in **accessFields**. If the access does not exist, the **accessId** does not match the **id** in **accessDto**, or the **providerId** is not the same, status code 404 is returned. If another access with the same login data already exists, status code 409 is returned.  The updated access is validated by setting up an account. Status code 200 does not imply that the credentials are correct. To check this, the client should obtain access.
     * @summary Update access
     * @param {string} accessId The **id** for the access to update
     * @param {Access} accessDto The access object that contains the changed credentials in             **accessFields**. Other fields cannot be edited.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putAccess(accessId: string, accessDto: Access, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Access>;
};
/**
 * AccessApi - factory interface
 * @export
 */
export declare const AccessApiFactory: (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) => {
    /**
     * Delete access with **accessId** and all related accounts
     * @summary Delete access
     * @param {string} accessId The **id** for the access to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAccess(accessId: string, options?: any): Promise<Response>;
    /**
     * Retrieve the access with **accessId**. The retrieved object does not contain sensitive information such as the PIN.
     * @summary Get access
     * @param {string} accessId The **id** for the access to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAccess(accessId: string, options?: any): Promise<Access>;
    /**
     * Returns all registered accesses for the authenticated user. The access fields contain confidential information (e.g., PIN) that will not be returned.
     * @summary List accesses
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAccesses(options?: any): Promise<Access[]>;
    /**
     * Create a new access and setup all associated accounts and transactions. This will also trigger the creation of monthly transaction summaries, the analysis of all accounts for recurring transactions, and the calculation of the balance forecast.   If the credentials were invalid, the validation state is set accordingly.    It is possible to have multiple accesses for one user.
     * @summary Create a new access
     * @param {Access} accessDto A valid BankAccess object containing the required             **accessFields** as indicated by the provider object and the             **providerId**.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postAccess(accessDto: Access, options?: any): Promise<Access>;
    /**
     * Update the access credentials in **accessFields**. If the access does not exist, the **accessId** does not match the **id** in **accessDto**, or the **providerId** is not the same, status code 404 is returned. If another access with the same login data already exists, status code 409 is returned.  The updated access is validated by setting up an account. Status code 200 does not imply that the credentials are correct. To check this, the client should obtain access.
     * @summary Update access
     * @param {string} accessId The **id** for the access to update
     * @param {Access} accessDto The access object that contains the changed credentials in             **accessFields**. Other fields cannot be edited.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putAccess(accessId: string, accessDto: Access, options?: any): Promise<Access>;
};
/**
 * AccessApi - object-oriented interface
 * @export
 * @class AccessApi
 * @extends {BaseAPI}
 */
export declare class AccessApi extends BaseAPI {
    /**
     * Delete access with **accessId** and all related accounts
     * @summary Delete access
     * @param {string} accessId The **id** for the access to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessApi
     */
    deleteAccess(accessId: string, options?: any): Promise<Response>;
    /**
     * Retrieve the access with **accessId**. The retrieved object does not contain sensitive information such as the PIN.
     * @summary Get access
     * @param {string} accessId The **id** for the access to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessApi
     */
    getAccess(accessId: string, options?: any): Promise<Access>;
    /**
     * Returns all registered accesses for the authenticated user. The access fields contain confidential information (e.g., PIN) that will not be returned.
     * @summary List accesses
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessApi
     */
    getAccesses(options?: any): Promise<Access[]>;
    /**
     * Create a new access and setup all associated accounts and transactions. This will also trigger the creation of monthly transaction summaries, the analysis of all accounts for recurring transactions, and the calculation of the balance forecast.   If the credentials were invalid, the validation state is set accordingly.    It is possible to have multiple accesses for one user.
     * @summary Create a new access
     * @param {Access} accessDto A valid BankAccess object containing the required             **accessFields** as indicated by the provider object and the             **providerId**.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessApi
     */
    postAccess(accessDto: Access, options?: any): Promise<Access>;
    /**
     * Update the access credentials in **accessFields**. If the access does not exist, the **accessId** does not match the **id** in **accessDto**, or the **providerId** is not the same, status code 404 is returned. If another access with the same login data already exists, status code 409 is returned.  The updated access is validated by setting up an account. Status code 200 does not imply that the credentials are correct. To check this, the client should obtain access.
     * @summary Update access
     * @param {string} accessId The **id** for the access to update
     * @param {Access} accessDto The access object that contains the changed credentials in             **accessFields**. Other fields cannot be edited.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessApi
     */
    putAccess(accessId: string, accessDto: Access, options?: any): Promise<Access>;
}
/**
 * AccountApi - fetch parameter creator
 * @export
 */
export declare const AccountApiFetchParamCreator: (configuration?: Configuration) => {
    /**
     * Delete the account identified by **accountId**
     * @summary Delete account
     * @param {string} accessId The **accessId** for the account to delete
     * @param {string} accountId The **id** for the account to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAccount(accessId: string, accountId: string, options?: any): FetchArgs;
    /**
     * Returns the account identified by **accountId**
     * @summary Get account
     * @param {string} accessId The **accessId** for the account to retrieve
     * @param {string} accountId The **id** for the account to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAccount(accessId: string, accountId: string, options?: any): FetchArgs;
    /**
     * Retrieve all accounts for the current user under the **accessId**
     * @summary List accounts
     * @param {string} accessId The **id** for the access for which to retrieve all accounts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAccounts(accessId: string, options?: any): FetchArgs;
    /**
     * Update the account name used in AHOI. Name must be URL encoded.
     * @summary Update account name
     * @param {string} accessId The **accessId** for which the user-defined account name should be altered
     * @param {string} accountId The **id** for which the user-defined account name should be altered
     * @param {string} name The new URL-encoded name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateAccount(accessId: string, accountId: string, name: string, options?: any): FetchArgs;
};
/**
 * AccountApi - functional programming interface
 * @export
 */
export declare const AccountApiFp: (configuration?: Configuration) => {
    /**
     * Delete the account identified by **accountId**
     * @summary Delete account
     * @param {string} accessId The **accessId** for the account to delete
     * @param {string} accountId The **id** for the account to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAccount(accessId: string, accountId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response>;
    /**
     * Returns the account identified by **accountId**
     * @summary Get account
     * @param {string} accessId The **accessId** for the account to retrieve
     * @param {string} accountId The **id** for the account to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAccount(accessId: string, accountId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Account>;
    /**
     * Retrieve all accounts for the current user under the **accessId**
     * @summary List accounts
     * @param {string} accessId The **id** for the access for which to retrieve all accounts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAccounts(accessId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Account[]>;
    /**
     * Update the account name used in AHOI. Name must be URL encoded.
     * @summary Update account name
     * @param {string} accessId The **accessId** for which the user-defined account name should be altered
     * @param {string} accountId The **id** for which the user-defined account name should be altered
     * @param {string} name The new URL-encoded name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateAccount(accessId: string, accountId: string, name: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Account>;
};
/**
 * AccountApi - factory interface
 * @export
 */
export declare const AccountApiFactory: (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) => {
    /**
     * Delete the account identified by **accountId**
     * @summary Delete account
     * @param {string} accessId The **accessId** for the account to delete
     * @param {string} accountId The **id** for the account to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAccount(accessId: string, accountId: string, options?: any): Promise<Response>;
    /**
     * Returns the account identified by **accountId**
     * @summary Get account
     * @param {string} accessId The **accessId** for the account to retrieve
     * @param {string} accountId The **id** for the account to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAccount(accessId: string, accountId: string, options?: any): Promise<Account>;
    /**
     * Retrieve all accounts for the current user under the **accessId**
     * @summary List accounts
     * @param {string} accessId The **id** for the access for which to retrieve all accounts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAccounts(accessId: string, options?: any): Promise<Account[]>;
    /**
     * Update the account name used in AHOI. Name must be URL encoded.
     * @summary Update account name
     * @param {string} accessId The **accessId** for which the user-defined account name should be altered
     * @param {string} accountId The **id** for which the user-defined account name should be altered
     * @param {string} name The new URL-encoded name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateAccount(accessId: string, accountId: string, name: string, options?: any): Promise<Account>;
};
/**
 * AccountApi - object-oriented interface
 * @export
 * @class AccountApi
 * @extends {BaseAPI}
 */
export declare class AccountApi extends BaseAPI {
    /**
     * Delete the account identified by **accountId**
     * @summary Delete account
     * @param {string} accessId The **accessId** for the account to delete
     * @param {string} accountId The **id** for the account to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    deleteAccount(accessId: string, accountId: string, options?: any): Promise<Response>;
    /**
     * Returns the account identified by **accountId**
     * @summary Get account
     * @param {string} accessId The **accessId** for the account to retrieve
     * @param {string} accountId The **id** for the account to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    getAccount(accessId: string, accountId: string, options?: any): Promise<Account>;
    /**
     * Retrieve all accounts for the current user under the **accessId**
     * @summary List accounts
     * @param {string} accessId The **id** for the access for which to retrieve all accounts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    getAccounts(accessId: string, options?: any): Promise<Account[]>;
    /**
     * Update the account name used in AHOI. Name must be URL encoded.
     * @summary Update account name
     * @param {string} accessId The **accessId** for which the user-defined account name should be altered
     * @param {string} accountId The **id** for which the user-defined account name should be altered
     * @param {string} name The new URL-encoded name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    updateAccount(accessId: string, accountId: string, name: string, options?: any): Promise<Account>;
}
/**
 * CategoryApi - fetch parameter creator
 * @export
 */
export declare const CategoryApiFetchParamCreator: (configuration?: Configuration) => {
    /**
     * Supported origins are: FINLYTICS
     * @summary Retrieve all categories for given origin
     * @param {string} origin identifier of a supported origin
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCategories(origin: string, options?: any): FetchArgs;
};
/**
 * CategoryApi - functional programming interface
 * @export
 */
export declare const CategoryApiFp: (configuration?: Configuration) => {
    /**
     * Supported origins are: FINLYTICS
     * @summary Retrieve all categories for given origin
     * @param {string} origin identifier of a supported origin
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCategories(origin: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Category[]>;
};
/**
 * CategoryApi - factory interface
 * @export
 */
export declare const CategoryApiFactory: (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) => {
    /**
     * Supported origins are: FINLYTICS
     * @summary Retrieve all categories for given origin
     * @param {string} origin identifier of a supported origin
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCategories(origin: string, options?: any): Promise<Category[]>;
};
/**
 * CategoryApi - object-oriented interface
 * @export
 * @class CategoryApi
 * @extends {BaseAPI}
 */
export declare class CategoryApi extends BaseAPI {
    /**
     * Supported origins are: FINLYTICS
     * @summary Retrieve all categories for given origin
     * @param {string} origin identifier of a supported origin
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryApi
     */
    getCategories(origin: string, options?: any): Promise<Category[]>;
}
/**
 * ContractApi - fetch parameter creator
 * @export
 */
export declare const ContractApiFetchParamCreator: (configuration?: Configuration) => {
    /**
     * api.resource.contracts.getContractList.description
     * @summary Fetches contract list of current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getContractList(options?: any): FetchArgs;
};
/**
 * ContractApi - functional programming interface
 * @export
 */
export declare const ContractApiFp: (configuration?: Configuration) => {
    /**
     * api.resource.contracts.getContractList.description
     * @summary Fetches contract list of current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getContractList(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Contract[]>;
};
/**
 * ContractApi - factory interface
 * @export
 */
export declare const ContractApiFactory: (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) => {
    /**
     * api.resource.contracts.getContractList.description
     * @summary Fetches contract list of current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getContractList(options?: any): Promise<Contract[]>;
};
/**
 * ContractApi - object-oriented interface
 * @export
 * @class ContractApi
 * @extends {BaseAPI}
 */
export declare class ContractApi extends BaseAPI {
    /**
     * api.resource.contracts.getContractList.description
     * @summary Fetches contract list of current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractApi
     */
    getContractList(options?: any): Promise<Contract[]>;
}
/**
 * ForecastApi - fetch parameter creator
 * @export
 */
export declare const ForecastApiFetchParamCreator: (configuration?: Configuration) => {
    /**
     * The current month is determined by the most recent refresh.
     * @summary Get balance forecast
     * @param {string} accessId The **accessId** for which to retrieve forecasts
     * @param {string} accountId The **accountId** for which to retrieve forecasts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getForecast(accessId: string, accountId: string, options?: any): FetchArgs;
    /**
     * The current month is determined by the most recent refresh of transactions. The request  also retrieves the transactions expected to be applied until the  end of the current month.
     * @summary Get forecast transactions
     * @param {string} accessId The **accessId** for the forecast
     * @param {string} accountId The **id** for the account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getForecastTransactions(accessId: string, accountId: string, options?: any): FetchArgs;
};
/**
 * ForecastApi - functional programming interface
 * @export
 */
export declare const ForecastApiFp: (configuration?: Configuration) => {
    /**
     * The current month is determined by the most recent refresh.
     * @summary Get balance forecast
     * @param {string} accessId The **accessId** for which to retrieve forecasts
     * @param {string} accountId The **accountId** for which to retrieve forecasts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getForecast(accessId: string, accountId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Forecast>;
    /**
     * The current month is determined by the most recent refresh of transactions. The request  also retrieves the transactions expected to be applied until the  end of the current month.
     * @summary Get forecast transactions
     * @param {string} accessId The **accessId** for the forecast
     * @param {string} accountId The **id** for the account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getForecastTransactions(accessId: string, accountId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ForecastTransaction>;
};
/**
 * ForecastApi - factory interface
 * @export
 */
export declare const ForecastApiFactory: (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) => {
    /**
     * The current month is determined by the most recent refresh.
     * @summary Get balance forecast
     * @param {string} accessId The **accessId** for which to retrieve forecasts
     * @param {string} accountId The **accountId** for which to retrieve forecasts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getForecast(accessId: string, accountId: string, options?: any): Promise<Forecast>;
    /**
     * The current month is determined by the most recent refresh of transactions. The request  also retrieves the transactions expected to be applied until the  end of the current month.
     * @summary Get forecast transactions
     * @param {string} accessId The **accessId** for the forecast
     * @param {string} accountId The **id** for the account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getForecastTransactions(accessId: string, accountId: string, options?: any): Promise<ForecastTransaction>;
};
/**
 * ForecastApi - object-oriented interface
 * @export
 * @class ForecastApi
 * @extends {BaseAPI}
 */
export declare class ForecastApi extends BaseAPI {
    /**
     * The current month is determined by the most recent refresh.
     * @summary Get balance forecast
     * @param {string} accessId The **accessId** for which to retrieve forecasts
     * @param {string} accountId The **accountId** for which to retrieve forecasts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ForecastApi
     */
    getForecast(accessId: string, accountId: string, options?: any): Promise<Forecast>;
    /**
     * The current month is determined by the most recent refresh of transactions. The request  also retrieves the transactions expected to be applied until the  end of the current month.
     * @summary Get forecast transactions
     * @param {string} accessId The **accessId** for the forecast
     * @param {string} accountId The **id** for the account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ForecastApi
     */
    getForecastTransactions(accessId: string, accountId: string, options?: any): Promise<ForecastTransaction>;
}
/**
 * ProviderApi - fetch parameter creator
 * @export
 */
export declare const ProviderApiFetchParamCreator: (configuration?: Configuration) => {
    /**
     * Retrieve a single provider identified by **providerId**
     * @summary Get provider
     * @param {string} providerId The **providerId** to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProvider(providerId: string, options?: any): FetchArgs;
    /**
     * Retrieve a list of bank providers. A **providerid** is required to create an _access_. To retrieve the necessary access fields, you need to query the specific `provider/{providerId}`. For performance reasons they are kept separate.
     * @summary List bank providers
     * @param {string} [bankCode] Optional — if length &#x3D; 8, the response will also contain data describing             the fields required for account setup
     * @param {boolean} [supported] Optional — response should only contain providers supported for account             setup via this API
     * @param {string} [query] Optional — search parameters for BankCode, BIC, Location, Name. Will be ignored             if the bankCode query parameter is set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProviders(bankCode?: string, supported?: boolean, query?: string, options?: any): FetchArgs;
};
/**
 * ProviderApi - functional programming interface
 * @export
 */
export declare const ProviderApiFp: (configuration?: Configuration) => {
    /**
     * Retrieve a single provider identified by **providerId**
     * @summary Get provider
     * @param {string} providerId The **providerId** to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProvider(providerId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Provider>;
    /**
     * Retrieve a list of bank providers. A **providerid** is required to create an _access_. To retrieve the necessary access fields, you need to query the specific `provider/{providerId}`. For performance reasons they are kept separate.
     * @summary List bank providers
     * @param {string} [bankCode] Optional — if length &#x3D; 8, the response will also contain data describing             the fields required for account setup
     * @param {boolean} [supported] Optional — response should only contain providers supported for account             setup via this API
     * @param {string} [query] Optional — search parameters for BankCode, BIC, Location, Name. Will be ignored             if the bankCode query parameter is set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProviders(bankCode?: string, supported?: boolean, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Provider[]>;
};
/**
 * ProviderApi - factory interface
 * @export
 */
export declare const ProviderApiFactory: (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) => {
    /**
     * Retrieve a single provider identified by **providerId**
     * @summary Get provider
     * @param {string} providerId The **providerId** to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProvider(providerId: string, options?: any): Promise<Provider>;
    /**
     * Retrieve a list of bank providers. A **providerid** is required to create an _access_. To retrieve the necessary access fields, you need to query the specific `provider/{providerId}`. For performance reasons they are kept separate.
     * @summary List bank providers
     * @param {string} [bankCode] Optional — if length &#x3D; 8, the response will also contain data describing             the fields required for account setup
     * @param {boolean} [supported] Optional — response should only contain providers supported for account             setup via this API
     * @param {string} [query] Optional — search parameters for BankCode, BIC, Location, Name. Will be ignored             if the bankCode query parameter is set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProviders(bankCode?: string, supported?: boolean, query?: string, options?: any): Promise<Provider[]>;
};
/**
 * ProviderApi - object-oriented interface
 * @export
 * @class ProviderApi
 * @extends {BaseAPI}
 */
export declare class ProviderApi extends BaseAPI {
    /**
     * Retrieve a single provider identified by **providerId**
     * @summary Get provider
     * @param {string} providerId The **providerId** to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderApi
     */
    getProvider(providerId: string, options?: any): Promise<Provider>;
    /**
     * Retrieve a list of bank providers. A **providerid** is required to create an _access_. To retrieve the necessary access fields, you need to query the specific `provider/{providerId}`. For performance reasons they are kept separate.
     * @summary List bank providers
     * @param {string} [bankCode] Optional — if length &#x3D; 8, the response will also contain data describing             the fields required for account setup
     * @param {boolean} [supported] Optional — response should only contain providers supported for account             setup via this API
     * @param {string} [query] Optional — search parameters for BankCode, BIC, Location, Name. Will be ignored             if the bankCode query parameter is set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderApi
     */
    getProviders(bankCode?: string, supported?: boolean, query?: string, options?: any): Promise<Provider[]>;
}
/**
 * QuickStartApi - fetch parameter creator
 * @export
 */
export declare const QuickStartApiFetchParamCreator: (configuration?: Configuration) => {
    /**
     * Retrieve a single provider identified by **providerId**
     * @summary Get provider
     * @param {string} providerId The **providerId** to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProvider(providerId: string, options?: any): FetchArgs;
    /**
     * Retrieve a list of bank providers. A **providerid** is required to create an _access_. To retrieve the necessary access fields, you need to query the specific `provider/{providerId}`. For performance reasons they are kept separate.
     * @summary List bank providers
     * @param {string} [bankCode] Optional — if length &#x3D; 8, the response will also contain data describing             the fields required for account setup
     * @param {boolean} [supported] Optional — response should only contain providers supported for account             setup via this API
     * @param {string} [query] Optional — search parameters for BankCode, BIC, Location, Name. Will be ignored             if the bankCode query parameter is set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProviders(bankCode?: string, supported?: boolean, query?: string, options?: any): FetchArgs;
    /**
     * Create a new access and setup all associated accounts and transactions. This will also trigger the creation of monthly transaction summaries, the analysis of all accounts for recurring transactions, and the calculation of the balance forecast.   If the credentials were invalid, the validation state is set accordingly.    It is possible to have multiple accesses for one user.
     * @summary Create a new access
     * @param {Access} accessDto A valid BankAccess object containing the required             **accessFields** as indicated by the provider object and the             **providerId**.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postAccess(accessDto: Access, options?: any): FetchArgs;
    /**
     * Registers a user with AHOI
     * @summary User registration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    register(options?: any): FetchArgs;
};
/**
 * QuickStartApi - functional programming interface
 * @export
 */
export declare const QuickStartApiFp: (configuration?: Configuration) => {
    /**
     * Retrieve a single provider identified by **providerId**
     * @summary Get provider
     * @param {string} providerId The **providerId** to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProvider(providerId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Provider>;
    /**
     * Retrieve a list of bank providers. A **providerid** is required to create an _access_. To retrieve the necessary access fields, you need to query the specific `provider/{providerId}`. For performance reasons they are kept separate.
     * @summary List bank providers
     * @param {string} [bankCode] Optional — if length &#x3D; 8, the response will also contain data describing             the fields required for account setup
     * @param {boolean} [supported] Optional — response should only contain providers supported for account             setup via this API
     * @param {string} [query] Optional — search parameters for BankCode, BIC, Location, Name. Will be ignored             if the bankCode query parameter is set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProviders(bankCode?: string, supported?: boolean, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Provider[]>;
    /**
     * Create a new access and setup all associated accounts and transactions. This will also trigger the creation of monthly transaction summaries, the analysis of all accounts for recurring transactions, and the calculation of the balance forecast.   If the credentials were invalid, the validation state is set accordingly.    It is possible to have multiple accesses for one user.
     * @summary Create a new access
     * @param {Access} accessDto A valid BankAccess object containing the required             **accessFields** as indicated by the provider object and the             **providerId**.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postAccess(accessDto: Access, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Access>;
    /**
     * Registers a user with AHOI
     * @summary User registration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    register(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RegistrationResponse>;
};
/**
 * QuickStartApi - factory interface
 * @export
 */
export declare const QuickStartApiFactory: (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) => {
    /**
     * Retrieve a single provider identified by **providerId**
     * @summary Get provider
     * @param {string} providerId The **providerId** to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProvider(providerId: string, options?: any): Promise<Provider>;
    /**
     * Retrieve a list of bank providers. A **providerid** is required to create an _access_. To retrieve the necessary access fields, you need to query the specific `provider/{providerId}`. For performance reasons they are kept separate.
     * @summary List bank providers
     * @param {string} [bankCode] Optional — if length &#x3D; 8, the response will also contain data describing             the fields required for account setup
     * @param {boolean} [supported] Optional — response should only contain providers supported for account             setup via this API
     * @param {string} [query] Optional — search parameters for BankCode, BIC, Location, Name. Will be ignored             if the bankCode query parameter is set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProviders(bankCode?: string, supported?: boolean, query?: string, options?: any): Promise<Provider[]>;
    /**
     * Create a new access and setup all associated accounts and transactions. This will also trigger the creation of monthly transaction summaries, the analysis of all accounts for recurring transactions, and the calculation of the balance forecast.   If the credentials were invalid, the validation state is set accordingly.    It is possible to have multiple accesses for one user.
     * @summary Create a new access
     * @param {Access} accessDto A valid BankAccess object containing the required             **accessFields** as indicated by the provider object and the             **providerId**.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postAccess(accessDto: Access, options?: any): Promise<Access>;
    /**
     * Registers a user with AHOI
     * @summary User registration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    register(options?: any): Promise<RegistrationResponse>;
};
/**
 * QuickStartApi - object-oriented interface
 * @export
 * @class QuickStartApi
 * @extends {BaseAPI}
 */
export declare class QuickStartApi extends BaseAPI {
    /**
     * Retrieve a single provider identified by **providerId**
     * @summary Get provider
     * @param {string} providerId The **providerId** to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuickStartApi
     */
    getProvider(providerId: string, options?: any): Promise<Provider>;
    /**
     * Retrieve a list of bank providers. A **providerid** is required to create an _access_. To retrieve the necessary access fields, you need to query the specific `provider/{providerId}`. For performance reasons they are kept separate.
     * @summary List bank providers
     * @param {string} [bankCode] Optional — if length &#x3D; 8, the response will also contain data describing             the fields required for account setup
     * @param {boolean} [supported] Optional — response should only contain providers supported for account             setup via this API
     * @param {string} [query] Optional — search parameters for BankCode, BIC, Location, Name. Will be ignored             if the bankCode query parameter is set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuickStartApi
     */
    getProviders(bankCode?: string, supported?: boolean, query?: string, options?: any): Promise<Provider[]>;
    /**
     * Create a new access and setup all associated accounts and transactions. This will also trigger the creation of monthly transaction summaries, the analysis of all accounts for recurring transactions, and the calculation of the balance forecast.   If the credentials were invalid, the validation state is set accordingly.    It is possible to have multiple accesses for one user.
     * @summary Create a new access
     * @param {Access} accessDto A valid BankAccess object containing the required             **accessFields** as indicated by the provider object and the             **providerId**.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuickStartApi
     */
    postAccess(accessDto: Access, options?: any): Promise<Access>;
    /**
     * Registers a user with AHOI
     * @summary User registration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuickStartApi
     */
    register(options?: any): Promise<RegistrationResponse>;
}
/**
 * RegistrationApi - fetch parameter creator
 * @export
 */
export declare const RegistrationApiFetchParamCreator: (configuration?: Configuration) => {
    /**
     * api.resource.registration.deleteRegistration.description
     * @summary Delete the user context for the current token.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteRegistration(options?: any): FetchArgs;
    /**
     * A valid API public key will be returned in JWK format to be used to encrypt registration data. Only needed with extended encryption.
     * @summary Request API JWK public key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getJsonWebKey(options?: any): FetchArgs;
    /**
     * A valid API public key will be returned to be used to encrypt registration data. Only needed with extended encryption.
     * @summary Request API public key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRegistrationPublicKey(options?: any): FetchArgs;
    /**
     * Registers a user with AHOI
     * @summary User registration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    register(options?: any): FetchArgs;
};
/**
 * RegistrationApi - functional programming interface
 * @export
 */
export declare const RegistrationApiFp: (configuration?: Configuration) => {
    /**
     * api.resource.registration.deleteRegistration.description
     * @summary Delete the user context for the current token.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteRegistration(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response>;
    /**
     * A valid API public key will be returned in JWK format to be used to encrypt registration data. Only needed with extended encryption.
     * @summary Request API JWK public key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getJsonWebKey(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<JwkJwkPublicKey>;
    /**
     * A valid API public key will be returned to be used to encrypt registration data. Only needed with extended encryption.
     * @summary Request API public key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRegistrationPublicKey(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RegistrationPublicKey>;
    /**
     * Registers a user with AHOI
     * @summary User registration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    register(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RegistrationResponse>;
};
/**
 * RegistrationApi - factory interface
 * @export
 */
export declare const RegistrationApiFactory: (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) => {
    /**
     * api.resource.registration.deleteRegistration.description
     * @summary Delete the user context for the current token.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteRegistration(options?: any): Promise<Response>;
    /**
     * A valid API public key will be returned in JWK format to be used to encrypt registration data. Only needed with extended encryption.
     * @summary Request API JWK public key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getJsonWebKey(options?: any): Promise<JwkJwkPublicKey>;
    /**
     * A valid API public key will be returned to be used to encrypt registration data. Only needed with extended encryption.
     * @summary Request API public key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRegistrationPublicKey(options?: any): Promise<RegistrationPublicKey>;
    /**
     * Registers a user with AHOI
     * @summary User registration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    register(options?: any): Promise<RegistrationResponse>;
};
/**
 * RegistrationApi - object-oriented interface
 * @export
 * @class RegistrationApi
 * @extends {BaseAPI}
 */
export declare class RegistrationApi extends BaseAPI {
    /**
     * api.resource.registration.deleteRegistration.description
     * @summary Delete the user context for the current token.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegistrationApi
     */
    deleteRegistration(options?: any): Promise<Response>;
    /**
     * A valid API public key will be returned in JWK format to be used to encrypt registration data. Only needed with extended encryption.
     * @summary Request API JWK public key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegistrationApi
     */
    getJsonWebKey(options?: any): Promise<JwkJwkPublicKey>;
    /**
     * A valid API public key will be returned to be used to encrypt registration data. Only needed with extended encryption.
     * @summary Request API public key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegistrationApi
     */
    getRegistrationPublicKey(options?: any): Promise<RegistrationPublicKey>;
    /**
     * Registers a user with AHOI
     * @summary User registration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegistrationApi
     */
    register(options?: any): Promise<RegistrationResponse>;
}
/**
 * SecurityApi - fetch parameter creator
 * @export
 */
export declare const SecurityApiFetchParamCreator: (configuration?: Configuration) => {
    /**
     * api.resource.accesses.accessId.accounts.accountId.securities.securityId.getSecurity.description
     * @summary Get security
     * @param {string} accessId api.resource.accesses.accessId.accounts.accountId.securities.securityId.getSecurity.parameter.accessId.description
     * @param {string} accountId The **accountId** for which to retrieve securities
     * @param {string} securityId The **securityId** for the security to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSecurity(accessId: string, accountId: string, securityId: string, options?: any): FetchArgs;
    /**
     * api.resource.accesses.accessId.accounts.accountId.securities.listSecurities.description
     * @summary List securities for account
     * @param {string} accessId api.resource.accesses.accessId.accounts.accountId.securities.listSecurities.parameter.accessId.description
     * @param {string} accountId The **accountId** for which to retrieve securities
     * @param {number} [maxAge] Optional - defines maximum age (in seconds) of cached account data provided by the bank.         A \&quot;maxAge\&quot; of 3600 will not trigger an update of the account securities when the last         refresh was performed 2000 seconds ago.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listSecurities(accessId: string, accountId: string, maxAge?: number, options?: any): FetchArgs;
};
/**
 * SecurityApi - functional programming interface
 * @export
 */
export declare const SecurityApiFp: (configuration?: Configuration) => {
    /**
     * api.resource.accesses.accessId.accounts.accountId.securities.securityId.getSecurity.description
     * @summary Get security
     * @param {string} accessId api.resource.accesses.accessId.accounts.accountId.securities.securityId.getSecurity.parameter.accessId.description
     * @param {string} accountId The **accountId** for which to retrieve securities
     * @param {string} securityId The **securityId** for the security to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSecurity(accessId: string, accountId: string, securityId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Security>;
    /**
     * api.resource.accesses.accessId.accounts.accountId.securities.listSecurities.description
     * @summary List securities for account
     * @param {string} accessId api.resource.accesses.accessId.accounts.accountId.securities.listSecurities.parameter.accessId.description
     * @param {string} accountId The **accountId** for which to retrieve securities
     * @param {number} [maxAge] Optional - defines maximum age (in seconds) of cached account data provided by the bank.         A \&quot;maxAge\&quot; of 3600 will not trigger an update of the account securities when the last         refresh was performed 2000 seconds ago.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listSecurities(accessId: string, accountId: string, maxAge?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Security[]>;
};
/**
 * SecurityApi - factory interface
 * @export
 */
export declare const SecurityApiFactory: (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) => {
    /**
     * api.resource.accesses.accessId.accounts.accountId.securities.securityId.getSecurity.description
     * @summary Get security
     * @param {string} accessId api.resource.accesses.accessId.accounts.accountId.securities.securityId.getSecurity.parameter.accessId.description
     * @param {string} accountId The **accountId** for which to retrieve securities
     * @param {string} securityId The **securityId** for the security to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSecurity(accessId: string, accountId: string, securityId: string, options?: any): Promise<Security>;
    /**
     * api.resource.accesses.accessId.accounts.accountId.securities.listSecurities.description
     * @summary List securities for account
     * @param {string} accessId api.resource.accesses.accessId.accounts.accountId.securities.listSecurities.parameter.accessId.description
     * @param {string} accountId The **accountId** for which to retrieve securities
     * @param {number} [maxAge] Optional - defines maximum age (in seconds) of cached account data provided by the bank.         A \&quot;maxAge\&quot; of 3600 will not trigger an update of the account securities when the last         refresh was performed 2000 seconds ago.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listSecurities(accessId: string, accountId: string, maxAge?: number, options?: any): Promise<Security[]>;
};
/**
 * SecurityApi - object-oriented interface
 * @export
 * @class SecurityApi
 * @extends {BaseAPI}
 */
export declare class SecurityApi extends BaseAPI {
    /**
     * api.resource.accesses.accessId.accounts.accountId.securities.securityId.getSecurity.description
     * @summary Get security
     * @param {string} accessId api.resource.accesses.accessId.accounts.accountId.securities.securityId.getSecurity.parameter.accessId.description
     * @param {string} accountId The **accountId** for which to retrieve securities
     * @param {string} securityId The **securityId** for the security to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecurityApi
     */
    getSecurity(accessId: string, accountId: string, securityId: string, options?: any): Promise<Security>;
    /**
     * api.resource.accesses.accessId.accounts.accountId.securities.listSecurities.description
     * @summary List securities for account
     * @param {string} accessId api.resource.accesses.accessId.accounts.accountId.securities.listSecurities.parameter.accessId.description
     * @param {string} accountId The **accountId** for which to retrieve securities
     * @param {number} [maxAge] Optional - defines maximum age (in seconds) of cached account data provided by the bank.         A \&quot;maxAge\&quot; of 3600 will not trigger an update of the account securities when the last         refresh was performed 2000 seconds ago.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecurityApi
     */
    listSecurities(accessId: string, accountId: string, maxAge?: number, options?: any): Promise<Security[]>;
}
/**
 * TANSchemesApi - fetch parameter creator
 * @export
 */
export declare const TANSchemesApiFetchParamCreator: (configuration?: Configuration) => {
    /**
     * Returns the currently selected TAN media for the access
     * @summary Get current TAN media
     * @param {string} accessId The **accessId** for which to retrieve the current TAN media
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCurrentTanMedia(accessId: string, options?: any): FetchArgs;
    /**
     * Returns the currently selected TAN scheme for the access
     * @summary Get current TAN scheme.
     * @param {string} accessId The **accessId** for which to retrieve the current TAN scheme
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCurrentTanScheme(accessId: string, options?: any): FetchArgs;
    /**
     * Retrieves all available TAN schemes for access
     * @summary List TAN schemes for access
     * @param {string} accessId The **id** for the access for which to retrieve the TAN list
     * @param {number} [maxAge] Optional - defines maximum age (in seconds) of cached account data provided by the bank.      A \&quot;maxAge\&quot; of 3600 will not trigger an update of TAN schemes when the last refresh was      performed 2000 seconds ago.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTanSchemes(accessId: string, maxAge?: number, options?: any): FetchArgs;
    /**
     * Update the access with a new currentTanMedia
     * @summary Update current TAN media
     * @param {string} accessId The **accessId** for which to set the current TAN media
     * @param {string} tanMediaId The **id** for the TAN media that should be set as the new currentTanMedia
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putCurrentTanMedia(accessId: string, tanMediaId: string, options?: any): FetchArgs;
    /**
     * Update the access with a new currentTanScheme
     * @summary Update current TAN scheme
     * @param {string} accessId The **accessId** for which to set the current TAN scheme
     * @param {string} tanSchemeId The **id** for the TAN scheme that should be set as the new currentTanScheme
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putCurrentTanScheme(accessId: string, tanSchemeId: string, options?: any): FetchArgs;
};
/**
 * TANSchemesApi - functional programming interface
 * @export
 */
export declare const TANSchemesApiFp: (configuration?: Configuration) => {
    /**
     * Returns the currently selected TAN media for the access
     * @summary Get current TAN media
     * @param {string} accessId The **accessId** for which to retrieve the current TAN media
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCurrentTanMedia(accessId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TanMedia>;
    /**
     * Returns the currently selected TAN scheme for the access
     * @summary Get current TAN scheme.
     * @param {string} accessId The **accessId** for which to retrieve the current TAN scheme
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCurrentTanScheme(accessId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TanScheme>;
    /**
     * Retrieves all available TAN schemes for access
     * @summary List TAN schemes for access
     * @param {string} accessId The **id** for the access for which to retrieve the TAN list
     * @param {number} [maxAge] Optional - defines maximum age (in seconds) of cached account data provided by the bank.      A \&quot;maxAge\&quot; of 3600 will not trigger an update of TAN schemes when the last refresh was      performed 2000 seconds ago.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTanSchemes(accessId: string, maxAge?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TanScheme[]>;
    /**
     * Update the access with a new currentTanMedia
     * @summary Update current TAN media
     * @param {string} accessId The **accessId** for which to set the current TAN media
     * @param {string} tanMediaId The **id** for the TAN media that should be set as the new currentTanMedia
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putCurrentTanMedia(accessId: string, tanMediaId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Access>;
    /**
     * Update the access with a new currentTanScheme
     * @summary Update current TAN scheme
     * @param {string} accessId The **accessId** for which to set the current TAN scheme
     * @param {string} tanSchemeId The **id** for the TAN scheme that should be set as the new currentTanScheme
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putCurrentTanScheme(accessId: string, tanSchemeId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Access>;
};
/**
 * TANSchemesApi - factory interface
 * @export
 */
export declare const TANSchemesApiFactory: (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) => {
    /**
     * Returns the currently selected TAN media for the access
     * @summary Get current TAN media
     * @param {string} accessId The **accessId** for which to retrieve the current TAN media
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCurrentTanMedia(accessId: string, options?: any): Promise<TanMedia>;
    /**
     * Returns the currently selected TAN scheme for the access
     * @summary Get current TAN scheme.
     * @param {string} accessId The **accessId** for which to retrieve the current TAN scheme
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCurrentTanScheme(accessId: string, options?: any): Promise<TanScheme>;
    /**
     * Retrieves all available TAN schemes for access
     * @summary List TAN schemes for access
     * @param {string} accessId The **id** for the access for which to retrieve the TAN list
     * @param {number} [maxAge] Optional - defines maximum age (in seconds) of cached account data provided by the bank.      A \&quot;maxAge\&quot; of 3600 will not trigger an update of TAN schemes when the last refresh was      performed 2000 seconds ago.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTanSchemes(accessId: string, maxAge?: number, options?: any): Promise<TanScheme[]>;
    /**
     * Update the access with a new currentTanMedia
     * @summary Update current TAN media
     * @param {string} accessId The **accessId** for which to set the current TAN media
     * @param {string} tanMediaId The **id** for the TAN media that should be set as the new currentTanMedia
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putCurrentTanMedia(accessId: string, tanMediaId: string, options?: any): Promise<Access>;
    /**
     * Update the access with a new currentTanScheme
     * @summary Update current TAN scheme
     * @param {string} accessId The **accessId** for which to set the current TAN scheme
     * @param {string} tanSchemeId The **id** for the TAN scheme that should be set as the new currentTanScheme
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putCurrentTanScheme(accessId: string, tanSchemeId: string, options?: any): Promise<Access>;
};
/**
 * TANSchemesApi - object-oriented interface
 * @export
 * @class TANSchemesApi
 * @extends {BaseAPI}
 */
export declare class TANSchemesApi extends BaseAPI {
    /**
     * Returns the currently selected TAN media for the access
     * @summary Get current TAN media
     * @param {string} accessId The **accessId** for which to retrieve the current TAN media
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TANSchemesApi
     */
    getCurrentTanMedia(accessId: string, options?: any): Promise<TanMedia>;
    /**
     * Returns the currently selected TAN scheme for the access
     * @summary Get current TAN scheme.
     * @param {string} accessId The **accessId** for which to retrieve the current TAN scheme
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TANSchemesApi
     */
    getCurrentTanScheme(accessId: string, options?: any): Promise<TanScheme>;
    /**
     * Retrieves all available TAN schemes for access
     * @summary List TAN schemes for access
     * @param {string} accessId The **id** for the access for which to retrieve the TAN list
     * @param {number} [maxAge] Optional - defines maximum age (in seconds) of cached account data provided by the bank.      A \&quot;maxAge\&quot; of 3600 will not trigger an update of TAN schemes when the last refresh was      performed 2000 seconds ago.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TANSchemesApi
     */
    getTanSchemes(accessId: string, maxAge?: number, options?: any): Promise<TanScheme[]>;
    /**
     * Update the access with a new currentTanMedia
     * @summary Update current TAN media
     * @param {string} accessId The **accessId** for which to set the current TAN media
     * @param {string} tanMediaId The **id** for the TAN media that should be set as the new currentTanMedia
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TANSchemesApi
     */
    putCurrentTanMedia(accessId: string, tanMediaId: string, options?: any): Promise<Access>;
    /**
     * Update the access with a new currentTanScheme
     * @summary Update current TAN scheme
     * @param {string} accessId The **accessId** for which to set the current TAN scheme
     * @param {string} tanSchemeId The **id** for the TAN scheme that should be set as the new currentTanScheme
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TANSchemesApi
     */
    putCurrentTanScheme(accessId: string, tanSchemeId: string, options?: any): Promise<Access>;
}
/**
 * TaskApi - fetch parameter creator
 * @export
 */
export declare const TaskApiFetchParamCreator: (configuration?: Configuration) => {
    /**
     * This is the third required step when executing a TAN-aware  banking task (e.g., a SEPA transfer).
     * @summary Fetch task challenges
     * @param {string} taskId The **id** of the task
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getChallenge(taskId: string, options?: any): FetchArgs;
    /**
     * Use this to poll for  status changes (e.g., steps two and five of the SEPA transfer process) or to query the state  after receiving a callback from AHOI.
     * @summary Fetch state of task
     * @param {string} taskId The **id** of the task for which to retrieve the status.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTask(taskId: string, options?: any): FetchArgs;
    /**
     * The SEPA transfer initiated using the _Transfer_ resource requires this starting with step four.
     * @summary Authorize a task
     * @param {string} taskId The **id** of the task
     * @param {ChallengeResponse} challengeResponse The response to process
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postChallengeResponse(taskId: string, challengeResponse: ChallengeResponse, options?: any): FetchArgs;
};
/**
 * TaskApi - functional programming interface
 * @export
 */
export declare const TaskApiFp: (configuration?: Configuration) => {
    /**
     * This is the third required step when executing a TAN-aware  banking task (e.g., a SEPA transfer).
     * @summary Fetch task challenges
     * @param {string} taskId The **id** of the task
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getChallenge(taskId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Challenge>;
    /**
     * Use this to poll for  status changes (e.g., steps two and five of the SEPA transfer process) or to query the state  after receiving a callback from AHOI.
     * @summary Fetch state of task
     * @param {string} taskId The **id** of the task for which to retrieve the status.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTask(taskId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Task>;
    /**
     * The SEPA transfer initiated using the _Transfer_ resource requires this starting with step four.
     * @summary Authorize a task
     * @param {string} taskId The **id** of the task
     * @param {ChallengeResponse} challengeResponse The response to process
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postChallengeResponse(taskId: string, challengeResponse: ChallengeResponse, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Task>;
};
/**
 * TaskApi - factory interface
 * @export
 */
export declare const TaskApiFactory: (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) => {
    /**
     * This is the third required step when executing a TAN-aware  banking task (e.g., a SEPA transfer).
     * @summary Fetch task challenges
     * @param {string} taskId The **id** of the task
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getChallenge(taskId: string, options?: any): Promise<Challenge>;
    /**
     * Use this to poll for  status changes (e.g., steps two and five of the SEPA transfer process) or to query the state  after receiving a callback from AHOI.
     * @summary Fetch state of task
     * @param {string} taskId The **id** of the task for which to retrieve the status.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTask(taskId: string, options?: any): Promise<Task>;
    /**
     * The SEPA transfer initiated using the _Transfer_ resource requires this starting with step four.
     * @summary Authorize a task
     * @param {string} taskId The **id** of the task
     * @param {ChallengeResponse} challengeResponse The response to process
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postChallengeResponse(taskId: string, challengeResponse: ChallengeResponse, options?: any): Promise<Task>;
};
/**
 * TaskApi - object-oriented interface
 * @export
 * @class TaskApi
 * @extends {BaseAPI}
 */
export declare class TaskApi extends BaseAPI {
    /**
     * This is the third required step when executing a TAN-aware  banking task (e.g., a SEPA transfer).
     * @summary Fetch task challenges
     * @param {string} taskId The **id** of the task
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    getChallenge(taskId: string, options?: any): Promise<Challenge>;
    /**
     * Use this to poll for  status changes (e.g., steps two and five of the SEPA transfer process) or to query the state  after receiving a callback from AHOI.
     * @summary Fetch state of task
     * @param {string} taskId The **id** of the task for which to retrieve the status.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    getTask(taskId: string, options?: any): Promise<Task>;
    /**
     * The SEPA transfer initiated using the _Transfer_ resource requires this starting with step four.
     * @summary Authorize a task
     * @param {string} taskId The **id** of the task
     * @param {ChallengeResponse} challengeResponse The response to process
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    postChallengeResponse(taskId: string, challengeResponse: ChallengeResponse, options?: any): Promise<Task>;
}
/**
 * TransactionApi - fetch parameter creator
 * @export
 */
export declare const TransactionApiFetchParamCreator: (configuration?: Configuration) => {
    /**
     * Returns the transaction identified by **transactionId** in relation to **accountId**.
     * @summary Get transaction
     * @param {string} accessId The **accessId** for the transaction to retrieve
     * @param {string} accountId The **accountId** for the transaction to retrieve
     * @param {string} transactionId The **transactionId** for the pattern to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTransaction(accessId: string, accountId: string, transactionId: string, options?: any): FetchArgs;
    /**
     * Retrieve all transactions for **accountId**
     * @summary List transactions for account
     * @param {string} accessId The **accessId** for which to retrieve transactions
     * @param {string} accountId The **accountId** for which to retrieve transactions
     * @param {number} [maxAge] Optional - defines maximum age (in seconds) of cached account data provided by the bank.          A \&quot;maxAge\&quot; of 3600 will not trigger an update of transactions, when the last refresh was          performed 2000 seconds ago.
     * @param {number} [limit] Optional — limit the number of returned transactions
     * @param {number} [offset] Optional — skip the first **offset** transactions in the result
     * @param {string} [from] Optional — only return transactions with booking date later than **from**; an ISO8601 Month(2014-11), Date (2014-11-17) or DateTime         (2014-11-17T12:00:00Z)
     * @param {string} [to] Optional — only return transactions with booking date prior or equal to **to**; an ISO8601 Date, Month or DateTime
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listTransactions(accessId: string, accountId: string, maxAge?: number, limit?: number, offset?: number, from?: string, to?: string, options?: any): FetchArgs;
    /**
     * Retrieve all transactions for **patternId**
     * @summary List transactions for pattern
     * @param {string} accessId The **accessId** for which to retrieve transactions
     * @param {string} accountId The **accountId** for which to retrieve transactions
     * @param {string} patternId The **patternId** for which to retrieve transactions
     * @param {number} [maxAge] Optional - defines maximum age (in seconds) of cached account data provided by the bank.       A \&quot;maxAge\&quot; of 3600 will not trigger an update of transactions when the last refresh was       performed 2000 seconds ago.
     * @param {number} [limit] Optional — limit the number of returned transactions
     * @param {number} [offset] Optional — skip the first **offset** transactions in result
     * @param {string} [from] Optional — only return transactions with a booking date later than **from**; an ISO8601 Month(2014-11), Date (2014-11-17) or DateTime         (2014-11-17T12:00:00Z)
     * @param {string} [to] Optional — only return transactions with a booking date prior or equal to **to**; an ISO8601 Date, Month or DateTime
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listTransactionsForPattern(accessId: string, accountId: string, patternId: string, maxAge?: number, limit?: number, offset?: number, from?: string, to?: string, options?: any): FetchArgs;
};
/**
 * TransactionApi - functional programming interface
 * @export
 */
export declare const TransactionApiFp: (configuration?: Configuration) => {
    /**
     * Returns the transaction identified by **transactionId** in relation to **accountId**.
     * @summary Get transaction
     * @param {string} accessId The **accessId** for the transaction to retrieve
     * @param {string} accountId The **accountId** for the transaction to retrieve
     * @param {string} transactionId The **transactionId** for the pattern to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTransaction(accessId: string, accountId: string, transactionId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Transaction>;
    /**
     * Retrieve all transactions for **accountId**
     * @summary List transactions for account
     * @param {string} accessId The **accessId** for which to retrieve transactions
     * @param {string} accountId The **accountId** for which to retrieve transactions
     * @param {number} [maxAge] Optional - defines maximum age (in seconds) of cached account data provided by the bank.          A \&quot;maxAge\&quot; of 3600 will not trigger an update of transactions, when the last refresh was          performed 2000 seconds ago.
     * @param {number} [limit] Optional — limit the number of returned transactions
     * @param {number} [offset] Optional — skip the first **offset** transactions in the result
     * @param {string} [from] Optional — only return transactions with booking date later than **from**; an ISO8601 Month(2014-11), Date (2014-11-17) or DateTime         (2014-11-17T12:00:00Z)
     * @param {string} [to] Optional — only return transactions with booking date prior or equal to **to**; an ISO8601 Date, Month or DateTime
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listTransactions(accessId: string, accountId: string, maxAge?: number, limit?: number, offset?: number, from?: string, to?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Transaction[]>;
    /**
     * Retrieve all transactions for **patternId**
     * @summary List transactions for pattern
     * @param {string} accessId The **accessId** for which to retrieve transactions
     * @param {string} accountId The **accountId** for which to retrieve transactions
     * @param {string} patternId The **patternId** for which to retrieve transactions
     * @param {number} [maxAge] Optional - defines maximum age (in seconds) of cached account data provided by the bank.       A \&quot;maxAge\&quot; of 3600 will not trigger an update of transactions when the last refresh was       performed 2000 seconds ago.
     * @param {number} [limit] Optional — limit the number of returned transactions
     * @param {number} [offset] Optional — skip the first **offset** transactions in result
     * @param {string} [from] Optional — only return transactions with a booking date later than **from**; an ISO8601 Month(2014-11), Date (2014-11-17) or DateTime         (2014-11-17T12:00:00Z)
     * @param {string} [to] Optional — only return transactions with a booking date prior or equal to **to**; an ISO8601 Date, Month or DateTime
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listTransactionsForPattern(accessId: string, accountId: string, patternId: string, maxAge?: number, limit?: number, offset?: number, from?: string, to?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Transaction[]>;
};
/**
 * TransactionApi - factory interface
 * @export
 */
export declare const TransactionApiFactory: (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) => {
    /**
     * Returns the transaction identified by **transactionId** in relation to **accountId**.
     * @summary Get transaction
     * @param {string} accessId The **accessId** for the transaction to retrieve
     * @param {string} accountId The **accountId** for the transaction to retrieve
     * @param {string} transactionId The **transactionId** for the pattern to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTransaction(accessId: string, accountId: string, transactionId: string, options?: any): Promise<Transaction>;
    /**
     * Retrieve all transactions for **accountId**
     * @summary List transactions for account
     * @param {string} accessId The **accessId** for which to retrieve transactions
     * @param {string} accountId The **accountId** for which to retrieve transactions
     * @param {number} [maxAge] Optional - defines maximum age (in seconds) of cached account data provided by the bank.          A \&quot;maxAge\&quot; of 3600 will not trigger an update of transactions, when the last refresh was          performed 2000 seconds ago.
     * @param {number} [limit] Optional — limit the number of returned transactions
     * @param {number} [offset] Optional — skip the first **offset** transactions in the result
     * @param {string} [from] Optional — only return transactions with booking date later than **from**; an ISO8601 Month(2014-11), Date (2014-11-17) or DateTime         (2014-11-17T12:00:00Z)
     * @param {string} [to] Optional — only return transactions with booking date prior or equal to **to**; an ISO8601 Date, Month or DateTime
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listTransactions(accessId: string, accountId: string, maxAge?: number, limit?: number, offset?: number, from?: string, to?: string, options?: any): Promise<Transaction[]>;
    /**
     * Retrieve all transactions for **patternId**
     * @summary List transactions for pattern
     * @param {string} accessId The **accessId** for which to retrieve transactions
     * @param {string} accountId The **accountId** for which to retrieve transactions
     * @param {string} patternId The **patternId** for which to retrieve transactions
     * @param {number} [maxAge] Optional - defines maximum age (in seconds) of cached account data provided by the bank.       A \&quot;maxAge\&quot; of 3600 will not trigger an update of transactions when the last refresh was       performed 2000 seconds ago.
     * @param {number} [limit] Optional — limit the number of returned transactions
     * @param {number} [offset] Optional — skip the first **offset** transactions in result
     * @param {string} [from] Optional — only return transactions with a booking date later than **from**; an ISO8601 Month(2014-11), Date (2014-11-17) or DateTime         (2014-11-17T12:00:00Z)
     * @param {string} [to] Optional — only return transactions with a booking date prior or equal to **to**; an ISO8601 Date, Month or DateTime
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listTransactionsForPattern(accessId: string, accountId: string, patternId: string, maxAge?: number, limit?: number, offset?: number, from?: string, to?: string, options?: any): Promise<Transaction[]>;
};
/**
 * TransactionApi - object-oriented interface
 * @export
 * @class TransactionApi
 * @extends {BaseAPI}
 */
export declare class TransactionApi extends BaseAPI {
    /**
     * Returns the transaction identified by **transactionId** in relation to **accountId**.
     * @summary Get transaction
     * @param {string} accessId The **accessId** for the transaction to retrieve
     * @param {string} accountId The **accountId** for the transaction to retrieve
     * @param {string} transactionId The **transactionId** for the pattern to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionApi
     */
    getTransaction(accessId: string, accountId: string, transactionId: string, options?: any): Promise<Transaction>;
    /**
     * Retrieve all transactions for **accountId**
     * @summary List transactions for account
     * @param {string} accessId The **accessId** for which to retrieve transactions
     * @param {string} accountId The **accountId** for which to retrieve transactions
     * @param {number} [maxAge] Optional - defines maximum age (in seconds) of cached account data provided by the bank.          A \&quot;maxAge\&quot; of 3600 will not trigger an update of transactions, when the last refresh was          performed 2000 seconds ago.
     * @param {number} [limit] Optional — limit the number of returned transactions
     * @param {number} [offset] Optional — skip the first **offset** transactions in the result
     * @param {string} [from] Optional — only return transactions with booking date later than **from**; an ISO8601 Month(2014-11), Date (2014-11-17) or DateTime         (2014-11-17T12:00:00Z)
     * @param {string} [to] Optional — only return transactions with booking date prior or equal to **to**; an ISO8601 Date, Month or DateTime
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionApi
     */
    listTransactions(accessId: string, accountId: string, maxAge?: number, limit?: number, offset?: number, from?: string, to?: string, options?: any): Promise<Transaction[]>;
    /**
     * Retrieve all transactions for **patternId**
     * @summary List transactions for pattern
     * @param {string} accessId The **accessId** for which to retrieve transactions
     * @param {string} accountId The **accountId** for which to retrieve transactions
     * @param {string} patternId The **patternId** for which to retrieve transactions
     * @param {number} [maxAge] Optional - defines maximum age (in seconds) of cached account data provided by the bank.       A \&quot;maxAge\&quot; of 3600 will not trigger an update of transactions when the last refresh was       performed 2000 seconds ago.
     * @param {number} [limit] Optional — limit the number of returned transactions
     * @param {number} [offset] Optional — skip the first **offset** transactions in result
     * @param {string} [from] Optional — only return transactions with a booking date later than **from**; an ISO8601 Month(2014-11), Date (2014-11-17) or DateTime         (2014-11-17T12:00:00Z)
     * @param {string} [to] Optional — only return transactions with a booking date prior or equal to **to**; an ISO8601 Date, Month or DateTime
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionApi
     */
    listTransactionsForPattern(accessId: string, accountId: string, patternId: string, maxAge?: number, limit?: number, offset?: number, from?: string, to?: string, options?: any): Promise<Transaction[]>;
}
/**
 * TransactionPatternApi - fetch parameter creator
 * @export
 */
export declare const TransactionPatternApiFetchParamCreator: (configuration?: Configuration) => {
    /**
     * Disabling the transaction pattern results in ignoring the pattern in the forecast. The transaction pattern still exists and relationships to transactions are not modified.
     * @summary Enable a transaction pattern
     * @param {string} accessId The **accessId** for which to activate the pattern
     * @param {string} accountId The **accountId** for which to activate the pattern
     * @param {string} patternId The **patternId** to (de)activate
     * @param {boolean} activated If &#x60;true&#x60;, the pattern will be used for forecast calculations;         &#x60;false&#x60; will be ignored.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    activateTransactionPattern(accessId: string, accountId: string, patternId: string, activated: boolean, options?: any): FetchArgs;
    /**
     * Delete the transaction pattern identified by the **patternId**. All associated transactions will be updated to {{patternId = null}}.
     * @summary Delete transaction pattern
     * @param {string} accessId The **accessId** for the transaction pattern to delete
     * @param {string} accountId The **accountId** for the transaction pattern to delete
     * @param {string} patternId The **patternId** to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteTransactionPattern(accessId: string, accountId: string, patternId: string, options?: any): FetchArgs;
    /**
     * Returns the transaction pattern identified by **patternId** in relation to  **accountId**.
     * @summary Get transaction pattern
     * @param {string} accessId The **accessId** for the pattern to retrieve
     * @param {string} accountId The **accoundId** for the pattern to retrieve
     * @param {string} patternId The **patternId** for the pattern to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTransactionPattern(accessId: string, accountId: string, patternId: string, options?: any): FetchArgs;
    /**
     * Returns all transaction patterns for **accountId**. Transaction patterns are recurring transactions automatically identified by the server or manually created via [create transaction pattern](#!/Transaction_pattern/postTransactionPattern).
     * @summary List transaction patterns for account
     * @param {string} accessId The **accessId** for which to retrieve transaction patterns
     * @param {string} accountId The **accountId** for which to retrieve transaction patterns
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listTransactionPatterns(accessId: string, accountId: string, options?: any): FetchArgs;
    /**
     * Create a new pattern for an **accountId**. The **cycle** can be `MONTHLY`, `QUARTERLY`, `SEMI_ANNUALLY` or `ANNUALLY`. The **day** can be between `1` and `366`, depending on **cycle**:  | cycle | day range | example | | --- | --- | --- | | `MONTHLY` | `1`-`31`  | every 29th of the month => `29` | | `QUARTERLY` | `1`-`92`  | 23rd of February (23rd of May, etc.) => `54` (31 [complete first month] + 23 [days in second month]) | | `SEMI_ANNUALLY` | `1`-`184` | 1st of May and 1st of November => `121` (for first half of year: 31 + 28 + 31 + 30 + 1) | | `ANNUALLY` | `1`-`366` | 24th of December => `358` |  If a similar pattern already exists, you will receive an HTTP status code 409.
     * @summary Create a new pattern
     * @param {string} accessId The **accessId** with which the newly created pattern is associated
     * @param {string} accountId The **accountId** with which the newly created pattern is associated
     * @param {TransactionPattern} transactionPatternDto The transaction pattern to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postTransactionPattern(accessId: string, accountId: string, transactionPatternDto: TransactionPattern, options?: any): FetchArgs;
};
/**
 * TransactionPatternApi - functional programming interface
 * @export
 */
export declare const TransactionPatternApiFp: (configuration?: Configuration) => {
    /**
     * Disabling the transaction pattern results in ignoring the pattern in the forecast. The transaction pattern still exists and relationships to transactions are not modified.
     * @summary Enable a transaction pattern
     * @param {string} accessId The **accessId** for which to activate the pattern
     * @param {string} accountId The **accountId** for which to activate the pattern
     * @param {string} patternId The **patternId** to (de)activate
     * @param {boolean} activated If &#x60;true&#x60;, the pattern will be used for forecast calculations;         &#x60;false&#x60; will be ignored.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    activateTransactionPattern(accessId: string, accountId: string, patternId: string, activated: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TransactionPattern>;
    /**
     * Delete the transaction pattern identified by the **patternId**. All associated transactions will be updated to {{patternId = null}}.
     * @summary Delete transaction pattern
     * @param {string} accessId The **accessId** for the transaction pattern to delete
     * @param {string} accountId The **accountId** for the transaction pattern to delete
     * @param {string} patternId The **patternId** to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteTransactionPattern(accessId: string, accountId: string, patternId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response>;
    /**
     * Returns the transaction pattern identified by **patternId** in relation to  **accountId**.
     * @summary Get transaction pattern
     * @param {string} accessId The **accessId** for the pattern to retrieve
     * @param {string} accountId The **accoundId** for the pattern to retrieve
     * @param {string} patternId The **patternId** for the pattern to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTransactionPattern(accessId: string, accountId: string, patternId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TransactionPattern>;
    /**
     * Returns all transaction patterns for **accountId**. Transaction patterns are recurring transactions automatically identified by the server or manually created via [create transaction pattern](#!/Transaction_pattern/postTransactionPattern).
     * @summary List transaction patterns for account
     * @param {string} accessId The **accessId** for which to retrieve transaction patterns
     * @param {string} accountId The **accountId** for which to retrieve transaction patterns
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listTransactionPatterns(accessId: string, accountId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TransactionPattern[]>;
    /**
     * Create a new pattern for an **accountId**. The **cycle** can be `MONTHLY`, `QUARTERLY`, `SEMI_ANNUALLY` or `ANNUALLY`. The **day** can be between `1` and `366`, depending on **cycle**:  | cycle | day range | example | | --- | --- | --- | | `MONTHLY` | `1`-`31`  | every 29th of the month => `29` | | `QUARTERLY` | `1`-`92`  | 23rd of February (23rd of May, etc.) => `54` (31 [complete first month] + 23 [days in second month]) | | `SEMI_ANNUALLY` | `1`-`184` | 1st of May and 1st of November => `121` (for first half of year: 31 + 28 + 31 + 30 + 1) | | `ANNUALLY` | `1`-`366` | 24th of December => `358` |  If a similar pattern already exists, you will receive an HTTP status code 409.
     * @summary Create a new pattern
     * @param {string} accessId The **accessId** with which the newly created pattern is associated
     * @param {string} accountId The **accountId** with which the newly created pattern is associated
     * @param {TransactionPattern} transactionPatternDto The transaction pattern to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postTransactionPattern(accessId: string, accountId: string, transactionPatternDto: TransactionPattern, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TransactionPattern>;
};
/**
 * TransactionPatternApi - factory interface
 * @export
 */
export declare const TransactionPatternApiFactory: (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) => {
    /**
     * Disabling the transaction pattern results in ignoring the pattern in the forecast. The transaction pattern still exists and relationships to transactions are not modified.
     * @summary Enable a transaction pattern
     * @param {string} accessId The **accessId** for which to activate the pattern
     * @param {string} accountId The **accountId** for which to activate the pattern
     * @param {string} patternId The **patternId** to (de)activate
     * @param {boolean} activated If &#x60;true&#x60;, the pattern will be used for forecast calculations;         &#x60;false&#x60; will be ignored.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    activateTransactionPattern(accessId: string, accountId: string, patternId: string, activated: boolean, options?: any): Promise<TransactionPattern>;
    /**
     * Delete the transaction pattern identified by the **patternId**. All associated transactions will be updated to {{patternId = null}}.
     * @summary Delete transaction pattern
     * @param {string} accessId The **accessId** for the transaction pattern to delete
     * @param {string} accountId The **accountId** for the transaction pattern to delete
     * @param {string} patternId The **patternId** to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteTransactionPattern(accessId: string, accountId: string, patternId: string, options?: any): Promise<Response>;
    /**
     * Returns the transaction pattern identified by **patternId** in relation to  **accountId**.
     * @summary Get transaction pattern
     * @param {string} accessId The **accessId** for the pattern to retrieve
     * @param {string} accountId The **accoundId** for the pattern to retrieve
     * @param {string} patternId The **patternId** for the pattern to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTransactionPattern(accessId: string, accountId: string, patternId: string, options?: any): Promise<TransactionPattern>;
    /**
     * Returns all transaction patterns for **accountId**. Transaction patterns are recurring transactions automatically identified by the server or manually created via [create transaction pattern](#!/Transaction_pattern/postTransactionPattern).
     * @summary List transaction patterns for account
     * @param {string} accessId The **accessId** for which to retrieve transaction patterns
     * @param {string} accountId The **accountId** for which to retrieve transaction patterns
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listTransactionPatterns(accessId: string, accountId: string, options?: any): Promise<TransactionPattern[]>;
    /**
     * Create a new pattern for an **accountId**. The **cycle** can be `MONTHLY`, `QUARTERLY`, `SEMI_ANNUALLY` or `ANNUALLY`. The **day** can be between `1` and `366`, depending on **cycle**:  | cycle | day range | example | | --- | --- | --- | | `MONTHLY` | `1`-`31`  | every 29th of the month => `29` | | `QUARTERLY` | `1`-`92`  | 23rd of February (23rd of May, etc.) => `54` (31 [complete first month] + 23 [days in second month]) | | `SEMI_ANNUALLY` | `1`-`184` | 1st of May and 1st of November => `121` (for first half of year: 31 + 28 + 31 + 30 + 1) | | `ANNUALLY` | `1`-`366` | 24th of December => `358` |  If a similar pattern already exists, you will receive an HTTP status code 409.
     * @summary Create a new pattern
     * @param {string} accessId The **accessId** with which the newly created pattern is associated
     * @param {string} accountId The **accountId** with which the newly created pattern is associated
     * @param {TransactionPattern} transactionPatternDto The transaction pattern to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postTransactionPattern(accessId: string, accountId: string, transactionPatternDto: TransactionPattern, options?: any): Promise<TransactionPattern>;
};
/**
 * TransactionPatternApi - object-oriented interface
 * @export
 * @class TransactionPatternApi
 * @extends {BaseAPI}
 */
export declare class TransactionPatternApi extends BaseAPI {
    /**
     * Disabling the transaction pattern results in ignoring the pattern in the forecast. The transaction pattern still exists and relationships to transactions are not modified.
     * @summary Enable a transaction pattern
     * @param {string} accessId The **accessId** for which to activate the pattern
     * @param {string} accountId The **accountId** for which to activate the pattern
     * @param {string} patternId The **patternId** to (de)activate
     * @param {boolean} activated If &#x60;true&#x60;, the pattern will be used for forecast calculations;         &#x60;false&#x60; will be ignored.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionPatternApi
     */
    activateTransactionPattern(accessId: string, accountId: string, patternId: string, activated: boolean, options?: any): Promise<TransactionPattern>;
    /**
     * Delete the transaction pattern identified by the **patternId**. All associated transactions will be updated to {{patternId = null}}.
     * @summary Delete transaction pattern
     * @param {string} accessId The **accessId** for the transaction pattern to delete
     * @param {string} accountId The **accountId** for the transaction pattern to delete
     * @param {string} patternId The **patternId** to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionPatternApi
     */
    deleteTransactionPattern(accessId: string, accountId: string, patternId: string, options?: any): Promise<Response>;
    /**
     * Returns the transaction pattern identified by **patternId** in relation to  **accountId**.
     * @summary Get transaction pattern
     * @param {string} accessId The **accessId** for the pattern to retrieve
     * @param {string} accountId The **accoundId** for the pattern to retrieve
     * @param {string} patternId The **patternId** for the pattern to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionPatternApi
     */
    getTransactionPattern(accessId: string, accountId: string, patternId: string, options?: any): Promise<TransactionPattern>;
    /**
     * Returns all transaction patterns for **accountId**. Transaction patterns are recurring transactions automatically identified by the server or manually created via [create transaction pattern](#!/Transaction_pattern/postTransactionPattern).
     * @summary List transaction patterns for account
     * @param {string} accessId The **accessId** for which to retrieve transaction patterns
     * @param {string} accountId The **accountId** for which to retrieve transaction patterns
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionPatternApi
     */
    listTransactionPatterns(accessId: string, accountId: string, options?: any): Promise<TransactionPattern[]>;
    /**
     * Create a new pattern for an **accountId**. The **cycle** can be `MONTHLY`, `QUARTERLY`, `SEMI_ANNUALLY` or `ANNUALLY`. The **day** can be between `1` and `366`, depending on **cycle**:  | cycle | day range | example | | --- | --- | --- | | `MONTHLY` | `1`-`31`  | every 29th of the month => `29` | | `QUARTERLY` | `1`-`92`  | 23rd of February (23rd of May, etc.) => `54` (31 [complete first month] + 23 [days in second month]) | | `SEMI_ANNUALLY` | `1`-`184` | 1st of May and 1st of November => `121` (for first half of year: 31 + 28 + 31 + 30 + 1) | | `ANNUALLY` | `1`-`366` | 24th of December => `358` |  If a similar pattern already exists, you will receive an HTTP status code 409.
     * @summary Create a new pattern
     * @param {string} accessId The **accessId** with which the newly created pattern is associated
     * @param {string} accountId The **accountId** with which the newly created pattern is associated
     * @param {TransactionPattern} transactionPatternDto The transaction pattern to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionPatternApi
     */
    postTransactionPattern(accessId: string, accountId: string, transactionPatternDto: TransactionPattern, options?: any): Promise<TransactionPattern>;
}
/**
 * TransactionSummaryApi - fetch parameter creator
 * @export
 */
export declare const TransactionSummaryApiFetchParamCreator: (configuration?: Configuration) => {
    /**
     * Retrieve account summaries and provide a sum for incoming and outgoing transactions
     * @summary List account summaries
     * @param {string} accessId The **accessId** for which to list the summaries
     * @param {string} accountId The **accountId** for which to list the summaries
     * @param {number} [limit] Optional — limit the number of returned summary entries
     * @param {number} [offset] Optional — skip the first **offset** summary entries in the result
     * @param {string} [from] Optional — only return summary entries later than **from**; an         ISO8601 Date (2014-11-17)
     * @param {string} [to] Optional — only return summary entries prior or equal to         **to**; an ISO8601 Date
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listSummary(accessId: string, accountId: string, limit?: number, offset?: number, from?: string, to?: string, options?: any): FetchArgs;
};
/**
 * TransactionSummaryApi - functional programming interface
 * @export
 */
export declare const TransactionSummaryApiFp: (configuration?: Configuration) => {
    /**
     * Retrieve account summaries and provide a sum for incoming and outgoing transactions
     * @summary List account summaries
     * @param {string} accessId The **accessId** for which to list the summaries
     * @param {string} accountId The **accountId** for which to list the summaries
     * @param {number} [limit] Optional — limit the number of returned summary entries
     * @param {number} [offset] Optional — skip the first **offset** summary entries in the result
     * @param {string} [from] Optional — only return summary entries later than **from**; an         ISO8601 Date (2014-11-17)
     * @param {string} [to] Optional — only return summary entries prior or equal to         **to**; an ISO8601 Date
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listSummary(accessId: string, accountId: string, limit?: number, offset?: number, from?: string, to?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MonthlySummary[]>;
};
/**
 * TransactionSummaryApi - factory interface
 * @export
 */
export declare const TransactionSummaryApiFactory: (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) => {
    /**
     * Retrieve account summaries and provide a sum for incoming and outgoing transactions
     * @summary List account summaries
     * @param {string} accessId The **accessId** for which to list the summaries
     * @param {string} accountId The **accountId** for which to list the summaries
     * @param {number} [limit] Optional — limit the number of returned summary entries
     * @param {number} [offset] Optional — skip the first **offset** summary entries in the result
     * @param {string} [from] Optional — only return summary entries later than **from**; an         ISO8601 Date (2014-11-17)
     * @param {string} [to] Optional — only return summary entries prior or equal to         **to**; an ISO8601 Date
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listSummary(accessId: string, accountId: string, limit?: number, offset?: number, from?: string, to?: string, options?: any): Promise<MonthlySummary[]>;
};
/**
 * TransactionSummaryApi - object-oriented interface
 * @export
 * @class TransactionSummaryApi
 * @extends {BaseAPI}
 */
export declare class TransactionSummaryApi extends BaseAPI {
    /**
     * Retrieve account summaries and provide a sum for incoming and outgoing transactions
     * @summary List account summaries
     * @param {string} accessId The **accessId** for which to list the summaries
     * @param {string} accountId The **accountId** for which to list the summaries
     * @param {number} [limit] Optional — limit the number of returned summary entries
     * @param {number} [offset] Optional — skip the first **offset** summary entries in the result
     * @param {string} [from] Optional — only return summary entries later than **from**; an         ISO8601 Date (2014-11-17)
     * @param {string} [to] Optional — only return summary entries prior or equal to         **to**; an ISO8601 Date
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionSummaryApi
     */
    listSummary(accessId: string, accountId: string, limit?: number, offset?: number, from?: string, to?: string, options?: any): Promise<MonthlySummary[]>;
}
/**
 * TransferApi - fetch parameter creator
 * @export
 */
export declare const TransferApiFetchParamCreator: (configuration?: Configuration) => {
    /**
     * <p>**Please note:** <ul>      <li>The IBAN of the receiving account needs to exist, even if it is located in Sandbank. Otherwise the transfer will fail.      <li>The returned JSON document represents the task that covers the transfer process as a result of a subsequent TAN request.  </ul>
     * @summary Create a new transfer
     * @param {string} accessId The **id** of the access corresponding to accounts to be used
     * @param {string} accountId The **id** for the account
     * @param {Transfer} transfer Transfer to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postTransfer(accessId: string, accountId: string, transfer: Transfer, options?: any): FetchArgs;
};
/**
 * TransferApi - functional programming interface
 * @export
 */
export declare const TransferApiFp: (configuration?: Configuration) => {
    /**
     * <p>**Please note:** <ul>      <li>The IBAN of the receiving account needs to exist, even if it is located in Sandbank. Otherwise the transfer will fail.      <li>The returned JSON document represents the task that covers the transfer process as a result of a subsequent TAN request.  </ul>
     * @summary Create a new transfer
     * @param {string} accessId The **id** of the access corresponding to accounts to be used
     * @param {string} accountId The **id** for the account
     * @param {Transfer} transfer Transfer to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postTransfer(accessId: string, accountId: string, transfer: Transfer, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TransferTask>;
};
/**
 * TransferApi - factory interface
 * @export
 */
export declare const TransferApiFactory: (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) => {
    /**
     * <p>**Please note:** <ul>      <li>The IBAN of the receiving account needs to exist, even if it is located in Sandbank. Otherwise the transfer will fail.      <li>The returned JSON document represents the task that covers the transfer process as a result of a subsequent TAN request.  </ul>
     * @summary Create a new transfer
     * @param {string} accessId The **id** of the access corresponding to accounts to be used
     * @param {string} accountId The **id** for the account
     * @param {Transfer} transfer Transfer to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postTransfer(accessId: string, accountId: string, transfer: Transfer, options?: any): Promise<TransferTask>;
};
/**
 * TransferApi - object-oriented interface
 * @export
 * @class TransferApi
 * @extends {BaseAPI}
 */
export declare class TransferApi extends BaseAPI {
    /**
     * <p>**Please note:** <ul>      <li>The IBAN of the receiving account needs to exist, even if it is located in Sandbank. Otherwise the transfer will fail.      <li>The returned JSON document represents the task that covers the transfer process as a result of a subsequent TAN request.  </ul>
     * @summary Create a new transfer
     * @param {string} accessId The **id** of the access corresponding to accounts to be used
     * @param {string} accountId The **id** for the account
     * @param {Transfer} transfer Transfer to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransferApi
     */
    postTransfer(accessId: string, accountId: string, transfer: Transfer, options?: any): Promise<TransferTask>;
}
