/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * 
 * [AHOI cookbook](/ahoi/docs/cookbook/index.html)  [Data Privacy](/sandboxmanager/#/privacy)  [Terms of Service](/sandboxmanager/#/terms)  [Imprint](https://sparkassen-hub.com/impressum/)  &copy; 2016&dash;2017 Starfinanz - Ein Unternehmen der Finanz Informatik
 *
 * OpenAPI spec version: 2.1.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "https://localhost/ahoi/api/v2".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *  
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 * 
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = portableFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 * 
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface Access
 */
export interface Access {
    /**
     * Internal ID of this access (generated value)
     * @type {string}
     * @memberof Access
     */
    id?: string;
    /**
     * Identifier of the provider to which this access belongs
     * @type {string}
     * @memberof Access
     */
    providerId: string;
    /**
     * Authentication data for the given provider as a map of InputFieldId to String (e.g., `{\"USERNAME\", \"yourName\"}`)  The fields necessary for the access are determined by the   InputField descriptions of the related provider. The access fields will not be returned when accesses are read from the API.
     * @type {AccessFieldsMap}
     * @memberof Access
     */
    accessFields: AccessFieldsMap;
    /**
     * The state reflects the validity of the access credentials. The state can change after communicating with the provider.  It can be OK (access credentials are valid); `ACCESS_LOCKED` (access is locked: This can happen when, for example, someone tried to login to your account by  using an incorrect PIN too many times or if your account was used for illegal purposes — automatic refresh will be disabled); or `ACCESS_WRONG` (access wrong: Saved  credentials are incorrect and no communication with the provider is possible — automatic refresh will be disabled).
     * @type {string}
     * @memberof Access
     */
    validationState?: Access.ValidationStateEnum;
    /**
     * Discriminator for subtypes. At the moment only `BankAccess` is supported.
     * @type {string}
     * @memberof Access
     */
    type: string;
}

/**
 * @export
 * @namespace Access
 */
export namespace Access {
    /**
     * @export
     * @enum {string}
     */
    export enum ValidationStateEnum {
        OK = <any> 'OK',
        ACCESSLOCKED = <any> 'ACCESS_LOCKED',
        ACCESSWRONG = <any> 'ACCESS_WRONG'
    }
}

/**
 * 
 * @export
 * @interface AccessDescription
 */
export interface AccessDescription {
    /**
     * Information text by the provider as a description for required user actions during the account setup (e.g.,   \"Provided your financial institution has not given you a separate username, please enter  your account number as your username. Depending on your financial institution,  additional information such as a customer number can be entered. Most of the time  entering this information is optional.\")
     * @type {string}
     * @memberof AccessDescription
     */
    infoText?: string;
    /**
     * Information to describe and facilitate validation of an access
     * @type {Array<InputFieldDescription>}
     * @memberof AccessDescription
     */
    fieldDescriptions?: Array<InputFieldDescription>;
}

/**
 * 
 * @export
 * @interface AccessFieldsMap
 */
export interface AccessFieldsMap {
    /**
     * Should be filled with the username if the Provider object signals this as mandatory.
     * @type {string}
     * @memberof AccessFieldsMap
     */
    USERNAME?: string;
    /**
     * Should be filled with the customer number if the Provider object signals this as mandatory.
     * @type {string}
     * @memberof AccessFieldsMap
     */
    CUSTOMERNUMBER?: string;
    /**
     * Should be filled with the PIN if the Provider object signals this as mandatory. In some special production scenarios the pin has to be encrypted. We will inform you when to use the extended encryption.
     * @type {string}
     * @memberof AccessFieldsMap
     */
    PIN?: string;
}

/**
 * 
 * @export
 * @interface Account
 */
export interface Account {
    /**
     * Internal ID of this account (generated value)
     * @type {string}
     * @memberof Account
     */
    id: string;
    /**
     * Account name returned by bank provider (e.g., \"Giro Account\")
     * @type {string}
     * @memberof Account
     */
    name: string;
    /**
     * Account userDefinedName. This value can be set to define a custom name used in AHOI (e.g., \"My Giro Account\").  Can be changed by using the _account_ resource.
     * @type {string}
     * @memberof Account
     */
    userDefinedName?: string;
    /**
     * Account owner returned by bank provider (e.g., \"Max Mustermann\")
     * @type {string}
     * @memberof Account
     */
    owner: string;
    /**
     * Identifier of the provider to which this account belongs
     * @type {string}
     * @memberof Account
     */
    providerId: string;
    /**
     * An account kind is a classification of its structure and its possibilities.   This is typically defined by the bank provider.
     * @type {string}
     * @memberof Account
     */
    kind: Account.KindEnum;
    /**
     * Interval that indicates the freguency at which the account is updated.   This interval is read-only and is determined by the server depending on the last use of the API. The range is between every hour, daily and monthly.
     * @type {number}
     * @memberof Account
     */
    automaticRefreshInterval: number;
    /**
     * Discriminator for subtypes. At the moment only `BankAccount` is supported.
     * @type {string}
     * @memberof Account
     */
    type: string;
}

/**
 * @export
 * @namespace Account
 */
export namespace Account {
    /**
     * @export
     * @enum {string}
     */
    export enum KindEnum {
        GIRO = <any> 'GIRO',
        SPAR = <any> 'SPAR',
        FESTGELD = <any> 'FESTGELD',
        DEPOT = <any> 'DEPOT',
        DARLEHEN = <any> 'DARLEHEN',
        KREDITKARTE = <any> 'KREDITKARTE',
        BAUSPAR = <any> 'BAUSPAR',
        VLSPAR = <any> 'VL_SPAR',
        VLBAUSPAR = <any> 'VL_BAUSPAR',
        VLWERTPAPIERSPARVERTRAG = <any> 'VL_WERTPAPIERSPARVERTRAG',
        XXX = <any> 'XXX'
    }
}

/**
 * 
 * @export
 * @interface AdditionalInformation
 */
export interface AdditionalInformation {
    /**
     * DTO ID in UUID form
     * @type {string}
     * @memberof AdditionalInformation
     */
    id: string;
    /**
     * Discriminator for subtypes. At the moment only `Category` and `Contractor` are supported.
     * @type {string}
     * @memberof AdditionalInformation
     */
    type: string;
}

/**
 * 
 * @export
 * @interface Amount
 */
export interface Amount {
    /**
     * Amount value (in smallest unit; e.g., euro cents)
     * @type {number}
     * @memberof Amount
     */
    value: number;
    /**
     * Amount currency (ISO-4217; e.g., \"EUR\")
     * @type {string}
     * @memberof Amount
     */
    currency: string;
}

/**
 * 
 * @export
 * @interface Balance
 */
export interface Balance {
    /**
     * Balance amount
     * @type {Amount}
     * @memberof Balance
     */
    amount: Amount;
    /**
     * Date of balance (ISO 8601: \"yyyy-MM-dd'T'HH:mm:ssX\")
     * @type {Date}
     * @memberof Balance
     */
    date: Date;
}

/**
 * 
 * @export
 * @interface Challenge
 */
export interface Challenge {
    /**
     * Text of the challenge
     * @type {string}
     * @memberof Challenge
     */
    challenge?: string;
    /**
     * Additional information for authorization purposes (e.g., IBAN, BIC, amount of transfer transaction)
     * @type {string}
     * @memberof Challenge
     */
    additionalInformation?: string;
    /**
     * Only `TanChallengeDto` is supported.
     * @type {string}
     * @memberof Challenge
     */
    type: string;
}

/**
 * 
 * @export
 * @interface ChallengeResponse
 */
export interface ChallengeResponse {
    /**
     * Contains the challange to be used for task authorization
     * @type {string}
     * @memberof ChallengeResponse
     */
    response: string;
    /**
     * Only `TanChallengeResponseDto` is supported
     * @type {string}
     * @memberof ChallengeResponse
     */
    type: string;
}

/**
 * 
 * @export
 * @interface Contract
 */
export interface Contract {
    /**
     * Name of the contractor
     * @type {string}
     * @memberof Contract
     */
    contractorName?: string;
    /**
     * Name of assigned category
     * @type {string}
     * @memberof Contract
     */
    categoryName?: string;
    /**
     * Detected amount of the transaction
     * @type {Amount}
     * @memberof Contract
     */
    averageAmount?: Amount;
    /**
     * Interval in which a transaction is repeated
     * @type {string}
     * @memberof Contract
     */
    paymentInterval?: Contract.PaymentIntervalEnum;
    /**
     * Type of the contract
     * @type {string}
     * @memberof Contract
     */
    type?: Contract.TypeEnum;
    /**
     * First booking date detected
     * @type {string}
     * @memberof Contract
     */
    firstKnownBookingDate?: string;
    /**
     * Most recent booking date detected
     * @type {string}
     * @memberof Contract
     */
    lastKnownBookingDate?: string;
    /**
     * Estimated next booking date in the future
     * @type {string}
     * @memberof Contract
     */
    estimatedNextBookingDate?: string;
    /**
     * Estimated amount of the next booking
     * @type {Amount}
     * @memberof Contract
     */
    estimatedNextAmount?: Amount;
    /**
     * Some more details of a contract
     * @type {ContractDetailsMap}
     * @memberof Contract
     */
    contractDetails?: ContractDetailsMap;
}

/**
 * @export
 * @namespace Contract
 */
export namespace Contract {
    /**
     * @export
     * @enum {string}
     */
    export enum PaymentIntervalEnum {
        WEEKLY = <any> 'WEEKLY',
        BIWEEKLY = <any> 'BIWEEKLY',
        MONTHLY = <any> 'MONTHLY',
        QUARTERLY = <any> 'QUARTERLY',
        SEMIANNUAL = <any> 'SEMIANNUAL',
        ANNUAL = <any> 'ANNUAL',
        BIENNIAL = <any> 'BIENNIAL'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        SUBSCRIPTION = <any> 'SUBSCRIPTION',
        RENT = <any> 'RENT',
        RENTREVENUES = <any> 'RENT_REVENUES',
        SALARY = <any> 'SALARY',
        SALARYSIDEJOB = <any> 'SALARY_SIDE_JOB',
        PRIVATEPENSION = <any> 'PRIVATE_PENSION',
        PENSION = <any> 'PENSION',
        RIESTERRETIREMENTPLANPAYMENTS = <any> 'RIESTER_RETIREMENT_PLAN_PAYMENTS',
        RIESTERRETIREMENTPLANPAYOUTS = <any> 'RIESTER_RETIREMENT_PLAN_PAYOUTS'
    }
}

/**
 * 
 * @export
 * @interface ContractDetailsMap
 */
export interface ContractDetailsMap {
    /**
     * The customer number corresponding to the contract.
     * @type {string}
     * @memberof ContractDetailsMap
     */
    CUSTOMER_NUMBER?: string;
    /**
     * The contract number of the contract.
     * @type {string}
     * @memberof ContractDetailsMap
     */
    CONTRACT_NUMBER?: string;
    /**
     * The invoice number corresponding to the contract.
     * @type {string}
     * @memberof ContractDetailsMap
     */
    INVOICE_NUMBER?: string;
    /**
     * The license plate corresponding to the contract.
     * @type {string}
     * @memberof ContractDetailsMap
     */
    LICENSE_PLATE?: string;
    /**
     * The policy number corresponding to the contract.
     * @type {string}
     * @memberof ContractDetailsMap
     */
    POLICY_NUMBER?: string;
}

/**
 * 
 * @export
 * @interface Forecast
 */
export interface Forecast {
    /**
     * Balance forecast
     * @type {Balance}
     * @memberof Forecast
     */
    forecastBalance: Balance;
    /**
     * ID of account to which this entry belongs
     * @type {string}
     * @memberof Forecast
     */
    accountId: string;
}

/**
 * 
 * @export
 * @interface InputFieldDescription
 */
export interface InputFieldDescription {
    /**
     * Internal id for this field description
     * @type {string}
     * @memberof InputFieldDescription
     */
    id: InputFieldDescription.IdEnum;
    /**
     * Label for this field description (e.g., 'PIN', 'Login name', 'Customer No.')
     * @type {string}
     * @memberof InputFieldDescription
     */
    label: string;
    /**
     * Flag that indicates whether the given field value must be masked when entered on the client side or encrypted when persisting  on the server side
     * @type {boolean}
     * @memberof InputFieldDescription
     */
    masked: boolean;
    /**
     * Format of field value  Can be DEFINITELYNUMERIC (Format is definitely numeric), DEFINITELYALPHANUMERIC (Format is definitely alphanumeric),  PROBABLYALPHANUMERIC (Format is probably alphanumeric; numeric is unlikely but possible), PROBABLYNUMERIC (Format is probably  numeric; alphanumeric is unlikely but possible) or UNSPECIFIED (Default. No hint available).
     * @type {string}
     * @memberof InputFieldDescription
     */
    format: InputFieldDescription.FormatEnum;
    /**
     * Minimum length of field value (0 = no limit)
     * @type {number}
     * @memberof InputFieldDescription
     */
    lengthMin?: number;
    /**
     * Maximum length of field value (0 = no limit)
     * @type {number}
     * @memberof InputFieldDescription
     */
    lengthMax?: number;
}

/**
 * @export
 * @namespace InputFieldDescription
 */
export namespace InputFieldDescription {
    /**
     * @export
     * @enum {string}
     */
    export enum IdEnum {
        USERNAME = <any> 'USERNAME',
        CUSTOMERNUMBER = <any> 'CUSTOMERNUMBER',
        PIN = <any> 'PIN',
        TAN = <any> 'TAN'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum FormatEnum {
        UNSPECIFIED = <any> 'UNSPECIFIED',
        PROBABLYNUMERIC = <any> 'PROBABLYNUMERIC',
        DEFINITELYNUMERIC = <any> 'DEFINITELYNUMERIC',
        PROBABLYALPHANUMERIC = <any> 'PROBABLYALPHANUMERIC',
        DEFINITELYALPHANUMERIC = <any> 'DEFINITELYALPHANUMERIC'
    }
}

/**
 * 
 * @export
 * @interface JwkJwkPublicKey
 */
export interface JwkJwkPublicKey {
    /**
     * Key type, in this context RSA only
     * @type {string}
     * @memberof JwkJwkPublicKey
     */
    kty?: string;
    /**
     * Algorithm, in this context RSA-OAEP (RSA_2048_SHA1) only.
     * @type {string}
     * @memberof JwkJwkPublicKey
     */
    alg?: string;
    /**
     * Public key modulus BigInteger as Base64URL encoded
     * @type {string}
     * @memberof JwkJwkPublicKey
     */
    n?: string;
    /**
     * Public key exponent BigInteger as Base64URL encoded
     * @type {string}
     * @memberof JwkJwkPublicKey
     */
    e?: string;
    /**
     * Public key ID (i.e., a random UUID per key)
     * @type {string}
     * @memberof JwkJwkPublicKey
     */
    kid?: string;
}

/**
 * 
 * @export
 * @interface MonthlySummary
 */
export interface MonthlySummary {
    /**
     * MonthlySummary id in UUID form
     * @type {string}
     * @memberof MonthlySummary
     */
    id: string;
    /**
     * The month this entry belongs to (year-month in the ISO-8601: \"yyyy-MM\")
     * @type {string}
     * @memberof MonthlySummary
     */
    month: string;
    /**
     * Id of account this entry belongs to
     * @type {string}
     * @memberof MonthlySummary
     */
    accountId: string;
    /**
     * Sum of all incoming transactions for this month
     * @type {Amount}
     * @memberof MonthlySummary
     */
    income: Amount;
    /**
     * Sum of all outgoing transactions for this month
     * @type {Amount}
     * @memberof MonthlySummary
     */
    outgoings: Amount;
    /**
     * Balance at end of month
     * @type {Amount}
     * @memberof MonthlySummary
     */
    balance: Amount;
}

/**
 * 
 * @export
 * @interface Provider
 */
export interface Provider {
    /**
     * UUID of this provider. A constant to identify provider even when, for  example, their bank code changes (provided type is BankProvider)
     * @type {string}
     * @memberof Provider
     */
    id: string;
    /**
     * Name of this provider (e.g., \"Hamburger Bank\")
     * @type {string}
     * @memberof Provider
     */
    name: string;
    /**
     * Location of this provider (e.g., \"Hamburg\")
     * @type {string}
     * @memberof Provider
     */
    location: string;
    /**
     * Description of the access for the account setup (e.g., UI input fields).
     * @type {AccessDescription}
     * @memberof Provider
     */
    accessDescription?: AccessDescription;
    /**
     * Whether this bank is supported by AHOI API (i.e., whether you can use a connection to this provider).
     * @type {boolean}
     * @memberof Provider
     */
    supported: boolean;
    /**
     * Discriminator for subtypes. At the moment only `BankProvider` is supported.
     * @type {string}
     * @memberof Provider
     */
    type: string;
}

/**
 * 
 * @export
 * @interface RegistrationPublicKey
 */
export interface RegistrationPublicKey {
    /**
     * UUID of the public key for reference in the \"X-Ahoi-Session-Security\" header
     * @type {string}
     * @memberof RegistrationPublicKey
     */
    keyId: string;
    /**
     * Timestamp in ISO-8601 format defining when the public key expires
     * @type {string}
     * @memberof RegistrationPublicKey
     */
    validUntil: string;
    /**
     * Contains the Base64URL-encoded value and the encoding algorithm of the key
     * @type {SelfDescribedValue}
     * @memberof RegistrationPublicKey
     */
    publicKey: SelfDescribedValue;
    /**
     * Contains the Base64 URL-encoded signature of the key and the encoding algorithm of the signature
     * @type {SelfDescribedValue}
     * @memberof RegistrationPublicKey
     */
    publicKeySignature: SelfDescribedValue;
}

/**
 * 
 * @export
 * @interface RegistrationResponse
 */
export interface RegistrationResponse {
    /**
     * Contains the installation ID
     * @type {string}
     * @memberof RegistrationResponse
     */
    installation?: string;
}

/**
 * 
 * @export
 * @interface ResponseObjectMap
 */
export interface ResponseObjectMap {
    /**
     * The username for the authorization.
     * @type {string}
     * @memberof ResponseObjectMap
     */
    USERNAME?: string;
    /**
     * The username for the authorization.
     * @type {string}
     * @memberof ResponseObjectMap
     */
    CUSTOMERNUMBER?: string;
    /**
     * The PIN for the authorization
     * @type {string}
     * @memberof ResponseObjectMap
     */
    PIN?: string;
    /**
     * The TAN for the authorization.
     * @type {string}
     * @memberof ResponseObjectMap
     */
    TAN?: string;
}

/**
 * 
 * @export
 * @interface Security
 */
export interface Security {
    /**
     * Internal ID of this security (generated value)
     * @type {string}
     * @memberof Security
     */
    id: string;
    /**
     * Wertpapierkennnummer  (German) securities identification number
     * @type {string}
     * @memberof Security
     */
    wkn?: string;
    /**
     * International Securities Identification Number
     * @type {string}
     * @memberof Security
     */
    isin?: string;
    /**
     * Name
     * @type {string}
     * @memberof Security
     */
    name?: string;
    /**
     * Price
     * @type {Amount}
     * @memberof Security
     */
    price?: Amount;
    /**
     * Source of price:   **LMAR - Local Market**   Source of price quotation is the market.     **THEO -Theoretical**   Source of price quotation is a theoretical value based on the market yield.     **VEND- Vendor**   Source of price quotation is an external vendor.
     * @type {string}
     * @memberof Security
     */
    priceSource?: Security.PriceSourceEnum;
    /**
     * api.dto.model.com-starfinanz-ahoi-dto-v2-SecurityDto.properties.quotationDate.description
     * @type {string}
     * @memberof Security
     */
    quotationDate?: string;
    /**
     * Market name/location if **priceSource** is *LMAR*
     * @type {string}
     * @memberof Security
     */
    location?: string;
    /**
     * Price qualifier:    **MRKT** - Market Price   Last reported/known price of a financial instrument in a market.    **INDC** - Indicative Price   Estimated price, for example, for valuation purposes.
     * @type {string}
     * @memberof Security
     */
    priceQualifier?: Security.PriceQualifierEnum;
    /**
     * Balance
     * @type {string}
     * @memberof Security
     */
    quantity?: string;
    /**
     * Holding value
     * @type {Amount}
     * @memberof Security
     */
    amount?: Amount;
    /**
     * Holding value in divergent currency
     * @type {Amount}
     * @memberof Security
     */
    amountDivCurr?: Amount;
    /**
     * Acquisition date
     * @type {string}
     * @memberof Security
     */
    acquisitionDate?: string;
    /**
     * Acquisition price
     * @type {Amount}
     * @memberof Security
     */
    acquisitionPrice?: Amount;
    /**
     * Due date
     * @type {string}
     * @memberof Security
     */
    dueDate?: string;
}

/**
 * @export
 * @namespace Security
 */
export namespace Security {
    /**
     * @export
     * @enum {string}
     */
    export enum PriceSourceEnum {
        LMAR = <any> 'LMAR',
        THEO = <any> 'THEO',
        VEND = <any> 'VEND'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum PriceQualifierEnum {
        MRKT = <any> 'MRKT',
        INDC = <any> 'INDC'
    }
}

/**
 * 
 * @export
 * @interface SelfDescribedValue
 */
export interface SelfDescribedValue {
    /**
     * Key or signature value itself
     * @type {string}
     * @memberof SelfDescribedValue
     */
    value: string;
    /**
     * Specification of the encryption algorithm
     * @type {string}
     * @memberof SelfDescribedValue
     */
    specification: string;
}

/**
 * 
 * @export
 * @interface TanMedia
 */
export interface TanMedia {
    /**
     * ID of this TAN media
     * @type {string}
     * @memberof TanMedia
     */
    tanMediaId: string;
    /**
     * Name of TANMedia (e.g., \"iTan\")
     * @type {string}
     * @memberof TanMedia
     */
    name: string;
    /**
     * Description of TANMedia (e.g., phone number or card number used for given type)
     * @type {string}
     * @memberof TanMedia
     */
    description: string;
}

/**
 * 
 * @export
 * @interface TanScheme
 */
export interface TanScheme {
    /**
     * Internal ID of this TAN scheme (generated value)
     * @type {string}
     * @memberof TanScheme
     */
    schemeId?: string;
    /**
     * Name of the TAN scheme used
     * @type {string}
     * @memberof TanScheme
     */
    name?: string;
    /**
     * List of available TAN media for this scheme
     * @type {Array<TanMedia>}
     * @memberof TanScheme
     */
    tanMediaList?: Array<TanMedia>;
}

/**
 * 
 * @export
 * @interface Task
 */
export interface Task {
    /**
     * Represents the state of this task
     * @type {string}
     * @memberof Task
     */
    state?: Task.StateEnum;
    /**
     * UUID of this task to be used for identification on further task actions
     * @type {string}
     * @memberof Task
     */
    id?: string;
    /**
     * Discriminator for subtypes. At the moment only `TransferTask` is supported.
     * @type {string}
     * @memberof Task
     */
    type: string;
}

/**
 * @export
 * @namespace Task
 */
export namespace Task {
    /**
     * @export
     * @enum {string}
     */
    export enum StateEnum {
        UNKNOWN = <any> 'UNKNOWN',
        INITIAL = <any> 'INITIAL',
        DONE = <any> 'DONE',
        FAILED = <any> 'FAILED',
        AUTHORIZATIONPENDING = <any> 'AUTHORIZATION_PENDING',
        AUTHORIZATIONWRONG = <any> 'AUTHORIZATION_WRONG'
    }
}

/**
 * 
 * @export
 * @interface Transaction
 */
export interface Transaction {
    /**
     * Internal ID of this transaction (generated value)
     * @type {string}
     * @memberof Transaction
     */
    id: string;
    /**
     * Identifier of the transactionPattern to which this transaction belongs
     * @type {string}
     * @memberof Transaction
     */
    transactionPatternId?: string;
    /**
     * api.dto.model.com-starfinanz-ahoi-dto-v2-TransactionDto.properties.additionalInformation.description
     * @type {Array<AdditionalInformation>}
     * @memberof Transaction
     */
    additionalInformation?: Array<AdditionalInformation>;
    /**
     * Discriminator for subtypes. At the moment only `GiroTransaction` is supported.
     * @type {string}
     * @memberof Transaction
     */
    type: string;
}

/**
 * 
 * @export
 * @interface TransactionPattern
 */
export interface TransactionPattern {
    /**
     * Internal ID of this transactionPattern (generated value)
     * @type {string}
     * @memberof TransactionPattern
     */
    id?: string;
    /**
     * The state of this pattern  can be `ACTIVE` (default) or `INACTIVE` (user has disabled it)
     * @type {string}
     * @memberof TransactionPattern
     */
    state: TransactionPattern.StateEnum;
    /**
     * Frequency of occurrence for this pattern
     * @type {string}
     * @memberof TransactionPattern
     */
    cycle: TransactionPattern.CycleEnum;
    /**
     * Origin of creation can be `FINDER` (automatically found) or `MANUAL` (created by user). Cannot be set with creation or update.
     * @type {string}
     * @memberof TransactionPattern
     */
    origin?: TransactionPattern.OriginEnum;
    /**
     * Day in the cycle this pattern occurs
     * @type {number}
     * @memberof TransactionPattern
     */
    day: number;
    /**
     * Name of owner of related account (debtor or creditor)
     * @type {string}
     * @memberof TransactionPattern
     */
    relatedAccountOwner: string;
    /**
     * Amount value
     * @type {Amount}
     * @memberof TransactionPattern
     */
    amount: Amount;
    /**
     * Account number or IBAN of related account (debtor or creditor)
     * @type {string}
     * @memberof TransactionPattern
     */
    accountNumber: string;
    /**
     * Bank code number or BIC of related account (debtor or creditor)
     * @type {string}
     * @memberof TransactionPattern
     */
    bankCode: string;
    /**
     * Kind of transaction (e.g., \"Lastschrift\" or \"Dauerauftrag\")
     * @type {string}
     * @memberof TransactionPattern
     */
    kind?: string;
}

/**
 * @export
 * @namespace TransactionPattern
 */
export namespace TransactionPattern {
    /**
     * @export
     * @enum {string}
     */
    export enum StateEnum {
        INACTIVE = <any> 'INACTIVE',
        ACTIVE = <any> 'ACTIVE'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum CycleEnum {
        MONTHLY = <any> 'MONTHLY',
        QUARTERLY = <any> 'QUARTERLY',
        SEMIANNUALLY = <any> 'SEMI_ANNUALLY',
        ANNUALLY = <any> 'ANNUALLY'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum OriginEnum {
        FINDER = <any> 'FINDER',
        MANUAL = <any> 'MANUAL'
    }
}

/**
 * 
 * @export
 * @interface Transfer
 */
export interface Transfer {
    /**
     * IBAN - International Bank Account Number (defined in ISO 13616-1)
     * @type {string}
     * @memberof Transfer
     */
    iban: string;
    /**
     * BIC - Business Identifier Code (defined in ISO-9362)
     * @type {string}
     * @memberof Transfer
     */
    bic?: string;
    /**
     * Name - Name of the creditor
     * @type {string}
     * @memberof Transfer
     */
    name: string;
    /**
     * Amount to be transfered
     * @type {Amount}
     * @memberof Transfer
     */
    amount: Amount;
    /**
     * Purpose
     * @type {string}
     * @memberof Transfer
     */
    purpose?: string;
}

/**
 * 
 * @export
 * @interface BankAccess
 */
export interface BankAccess extends Access {
}

/**
 * @export
 * @namespace BankAccess
 */
export namespace BankAccess {
}

/**
 * 
 * @export
 * @interface BankAccount
 */
export interface BankAccount extends Account {
    /**
     * Account number (national)
     * @type {string}
     * @memberof BankAccount
     */
    number: string;
    /**
     * Bank code (i.e., routing number) (BLZ, national, 8 digits)
     * @type {string}
     * @memberof BankAccount
     */
    bankCodeNumber: string;
    /**
     * Business Identifier Code (BIC; ISO 9362)
     * @type {string}
     * @memberof BankAccount
     */
    bic: string;
    /**
     * International Bank Account Number (IBAN; ISO 13616-1)
     * @type {string}
     * @memberof BankAccount
     */
    iban: string;
    /**
     * Account currency (ISO 4217) (e.g., \"EUR\")
     * @type {string}
     * @memberof BankAccount
     */
    currency: string;
    /**
     * Current balance. This value is set whenever the account is refreshed.
     * @type {Balance}
     * @memberof BankAccount
     */
    balance: Balance;
}

/**
 * @export
 * @namespace BankAccount
 */
export namespace BankAccount {
}

/**
 * 
 * @export
 * @interface BankProvider
 */
export interface BankProvider extends Provider {
    /**
     * Bank code (i.e., routing number) (BLZ, national 8 digits)
     * @type {string}
     * @memberof BankProvider
     */
    bankCode: string;
    /**
     * Business Identifier Code (defined in ISO-9362)
     * @type {string}
     * @memberof BankProvider
     */
    bic: string;
}

/**
 * 
 * @export
 * @interface Category
 */
export interface Category extends AdditionalInformation {
    /**
     * Parent category id in UUID form
     * @type {string}
     * @memberof Category
     */
    parent?: string;
    /**
     * Category name
     * @type {string}
     * @memberof Category
     */
    name: string;
    /**
     * Origin id (i.e., the id within the origin id service)
     * @type {string}
     * @memberof Category
     */
    originId?: string;
    /**
     * Origin name
     * @type {string}
     * @memberof Category
     */
    origin: string;
}

/**
 * 
 * @export
 * @interface Contractor
 */
export interface Contractor extends AdditionalInformation {
    /**
     * api.dto.model.com-starfinanz-ahoi-dto-v2-ContractorDto.properties.contractorId.description
     * @type {number}
     * @memberof Contractor
     */
    contractorId?: number;
}

/**
 * 
 * @export
 * @interface ForecastTransaction
 */
export interface ForecastTransaction {
    /**
     * Balance forecast
     * @type {Balance}
     * @memberof ForecastTransaction
     */
    forecastBalance: Balance;
    /**
     * Id of account this entry belongs to
     * @type {string}
     * @memberof ForecastTransaction
     */
    accountId: string;
    /**
     * List of unappliedTransaction
     * @type {Array<Transaction>}
     * @memberof ForecastTransaction
     */
    transactions: Array<Transaction>;
}

/**
 * 
 * @export
 * @interface GiroTransaction
 */
export interface GiroTransaction extends Transaction {
    /**
     * Amount value
     * @type {Amount}
     * @memberof GiroTransaction
     */
    amount: Amount;
    /**
     * Booking date (ISO 8601: \"yyyy-MM-dd'T'HH:mm:ssX\")
     * @type {Date}
     * @memberof GiroTransaction
     */
    bookingDate: Date;
    /**
     * Value date (ISO 8601: \"yyyy-MM-dd'T'HH:mm:ssX\")
     * @type {Date}
     * @memberof GiroTransaction
     */
    valueDate: Date;
    /**
     * Creditor's name
     * @type {string}
     * @memberof GiroTransaction
     */
    creditor: string;
    /**
     * Creditor's bank code (i.e. routing number) or BIC
     * @type {string}
     * @memberof GiroTransaction
     */
    creditorBankCode?: string;
    /**
     * Creditor's account number or IBAN
     * @type {string}
     * @memberof GiroTransaction
     */
    creditorAccountNumber?: string;
    /**
     * Debtor's name
     * @type {string}
     * @memberof GiroTransaction
     */
    debtor: string;
    /**
     * Debtor's bank code (i.e. routing number) or BIC
     * @type {string}
     * @memberof GiroTransaction
     */
    debtorBankCode?: string;
    /**
     * Debtor's account number or IBAN
     * @type {string}
     * @memberof GiroTransaction
     */
    debtorAccountNumber?: string;
    /**
     * Purpose (as given by the provider)
     * @type {string}
     * @memberof GiroTransaction
     */
    purpose: string;
    /**
     * Cleaned purpose. Some SEPA information is filtered out (e.g., \"KREF+-1434947533-2...\")
     * @type {string}
     * @memberof GiroTransaction
     */
    cleanPurpose?: string;
    /**
     * Flag to identify if the transaction is marked as pre-booked
     * @type {boolean}
     * @memberof GiroTransaction
     */
    prebooked: boolean;
    /**
     * Booking key for transaction
     * @type {string}
     * @memberof GiroTransaction
     */
    bookingKey: string;
}

/**
 * 
 * @export
 * @interface TanChallenge
 */
export interface TanChallenge extends Challenge {
    /**
     * api.dto.model.com-starfinanz-ahoi-dto-v2-TanChallengeDto.properties.challengeType.description
     * @type {string}
     * @memberof TanChallenge
     */
    challengeType?: TanChallenge.ChallengeTypeEnum;
    /**
     * Currently resource URI pointing to TAN UI input component
     * @type {string}
     * @memberof TanChallenge
     */
    tanGuiUrl?: string;
}

/**
 * @export
 * @namespace TanChallenge
 */
export namespace TanChallenge {
    /**
     * @export
     * @enum {string}
     */
    export enum ChallengeTypeEnum {
        UNKNOWN = <any> 'UNKNOWN',
        ITAN = <any> 'ITAN',
        CHIPTAN = <any> 'CHIPTAN',
        OPTICALV3 = <any> 'OPTICAL_V3',
        OPTICALV4 = <any> 'OPTICAL_V4',
        PHOTOTAN = <any> 'PHOTOTAN'
    }
}

/**
 * 
 * @export
 * @interface TanChallengeResponse
 */
export interface TanChallengeResponse extends ChallengeResponse {
}

/**
 * 
 * @export
 * @interface TransferTask
 */
export interface TransferTask extends Task {
}

/**
 * @export
 * @namespace TransferTask
 */
export namespace TransferTask {
}


/**
 * AccessApi - fetch parameter creator
 * @export
 */
export const AccessApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete access with **accessId** and all related accounts
         * @summary Delete access
         * @param {string} accessId The **id** for the access to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccess(accessId: string, options: any = {}): FetchArgs {
            // verify required parameter 'accessId' is not null or undefined
            if (accessId === null || accessId === undefined) {
                throw new RequiredError('accessId','Required parameter accessId was null or undefined when calling deleteAccess.');
            }
            const localVarPath = `/accesses/{accessId}`
                .replace(`{${"accessId"}}`, encodeURIComponent(String(accessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the access with **accessId**. The retrieved object does not contain sensitive information such as the PIN.
         * @summary Get access
         * @param {string} accessId The **id** for the access to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccess(accessId: string, options: any = {}): FetchArgs {
            // verify required parameter 'accessId' is not null or undefined
            if (accessId === null || accessId === undefined) {
                throw new RequiredError('accessId','Required parameter accessId was null or undefined when calling getAccess.');
            }
            const localVarPath = `/accesses/{accessId}`
                .replace(`{${"accessId"}}`, encodeURIComponent(String(accessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all registered accesses for the authenticated user. The access fields contain confidential information (e.g., PIN) that will not be returned.
         * @summary List accesses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccesses(options: any = {}): FetchArgs {
            const localVarPath = `/accesses`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new access and setup all associated accounts and transactions. This will also trigger the creation of monthly transaction summaries, the analysis of all accounts for recurring transactions, and the calculation of the balance forecast.   If the credentials were invalid, the validation state is set accordingly.    It is possible to have multiple accesses for one user.
         * @summary Create a new access
         * @param {Access} accessDto A valid BankAccess object containing the required             **accessFields** as indicated by the provider object and the             **providerId**.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAccess(accessDto: Access, options: any = {}): FetchArgs {
            // verify required parameter 'accessDto' is not null or undefined
            if (accessDto === null || accessDto === undefined) {
                throw new RequiredError('accessDto','Required parameter accessDto was null or undefined when calling postAccess.');
            }
            const localVarPath = `/accesses`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Access" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(accessDto || {}) : (accessDto || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the access credentials in **accessFields**. If the access does not exist, the **accessId** does not match the **id** in **accessDto**, or the **providerId** is not the same, status code 404 is returned. If another access with the same login data already exists, status code 409 is returned.  The updated access is validated by setting up an account. Status code 200 does not imply that the credentials are correct. To check this, the client should obtain access.
         * @summary Update access
         * @param {string} accessId The **id** for the access to update
         * @param {Access} accessDto The access object that contains the changed credentials in             **accessFields**. Other fields cannot be edited.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putAccess(accessId: string, accessDto: Access, options: any = {}): FetchArgs {
            // verify required parameter 'accessId' is not null or undefined
            if (accessId === null || accessId === undefined) {
                throw new RequiredError('accessId','Required parameter accessId was null or undefined when calling putAccess.');
            }
            // verify required parameter 'accessDto' is not null or undefined
            if (accessDto === null || accessDto === undefined) {
                throw new RequiredError('accessDto','Required parameter accessDto was null or undefined when calling putAccess.');
            }
            const localVarPath = `/accesses/{accessId}`
                .replace(`{${"accessId"}}`, encodeURIComponent(String(accessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Access" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(accessDto || {}) : (accessDto || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccessApi - functional programming interface
 * @export
 */
export const AccessApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Delete access with **accessId** and all related accounts
         * @summary Delete access
         * @param {string} accessId The **id** for the access to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccess(accessId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AccessApiFetchParamCreator(configuration).deleteAccess(accessId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve the access with **accessId**. The retrieved object does not contain sensitive information such as the PIN.
         * @summary Get access
         * @param {string} accessId The **id** for the access to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccess(accessId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Access> {
            const localVarFetchArgs = AccessApiFetchParamCreator(configuration).getAccess(accessId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns all registered accesses for the authenticated user. The access fields contain confidential information (e.g., PIN) that will not be returned.
         * @summary List accesses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccesses(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Access>> {
            const localVarFetchArgs = AccessApiFetchParamCreator(configuration).getAccesses(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create a new access and setup all associated accounts and transactions. This will also trigger the creation of monthly transaction summaries, the analysis of all accounts for recurring transactions, and the calculation of the balance forecast.   If the credentials were invalid, the validation state is set accordingly.    It is possible to have multiple accesses for one user.
         * @summary Create a new access
         * @param {Access} accessDto A valid BankAccess object containing the required             **accessFields** as indicated by the provider object and the             **providerId**.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAccess(accessDto: Access, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Access> {
            const localVarFetchArgs = AccessApiFetchParamCreator(configuration).postAccess(accessDto, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update the access credentials in **accessFields**. If the access does not exist, the **accessId** does not match the **id** in **accessDto**, or the **providerId** is not the same, status code 404 is returned. If another access with the same login data already exists, status code 409 is returned.  The updated access is validated by setting up an account. Status code 200 does not imply that the credentials are correct. To check this, the client should obtain access.
         * @summary Update access
         * @param {string} accessId The **id** for the access to update
         * @param {Access} accessDto The access object that contains the changed credentials in             **accessFields**. Other fields cannot be edited.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putAccess(accessId: string, accessDto: Access, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Access> {
            const localVarFetchArgs = AccessApiFetchParamCreator(configuration).putAccess(accessId, accessDto, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AccessApi - factory interface
 * @export
 */
export const AccessApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Delete access with **accessId** and all related accounts
         * @summary Delete access
         * @param {string} accessId The **id** for the access to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccess(accessId: string, options?: any) {
            return AccessApiFp(configuration).deleteAccess(accessId, options)(fetch, basePath);
        },
        /**
         * Retrieve the access with **accessId**. The retrieved object does not contain sensitive information such as the PIN.
         * @summary Get access
         * @param {string} accessId The **id** for the access to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccess(accessId: string, options?: any) {
            return AccessApiFp(configuration).getAccess(accessId, options)(fetch, basePath);
        },
        /**
         * Returns all registered accesses for the authenticated user. The access fields contain confidential information (e.g., PIN) that will not be returned.
         * @summary List accesses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccesses(options?: any) {
            return AccessApiFp(configuration).getAccesses(options)(fetch, basePath);
        },
        /**
         * Create a new access and setup all associated accounts and transactions. This will also trigger the creation of monthly transaction summaries, the analysis of all accounts for recurring transactions, and the calculation of the balance forecast.   If the credentials were invalid, the validation state is set accordingly.    It is possible to have multiple accesses for one user.
         * @summary Create a new access
         * @param {Access} accessDto A valid BankAccess object containing the required             **accessFields** as indicated by the provider object and the             **providerId**.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAccess(accessDto: Access, options?: any) {
            return AccessApiFp(configuration).postAccess(accessDto, options)(fetch, basePath);
        },
        /**
         * Update the access credentials in **accessFields**. If the access does not exist, the **accessId** does not match the **id** in **accessDto**, or the **providerId** is not the same, status code 404 is returned. If another access with the same login data already exists, status code 409 is returned.  The updated access is validated by setting up an account. Status code 200 does not imply that the credentials are correct. To check this, the client should obtain access.
         * @summary Update access
         * @param {string} accessId The **id** for the access to update
         * @param {Access} accessDto The access object that contains the changed credentials in             **accessFields**. Other fields cannot be edited.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putAccess(accessId: string, accessDto: Access, options?: any) {
            return AccessApiFp(configuration).putAccess(accessId, accessDto, options)(fetch, basePath);
        },
    };
};

/**
 * AccessApi - object-oriented interface
 * @export
 * @class AccessApi
 * @extends {BaseAPI}
 */
export class AccessApi extends BaseAPI {
    /**
     * Delete access with **accessId** and all related accounts
     * @summary Delete access
     * @param {string} accessId The **id** for the access to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessApi
     */
    public deleteAccess(accessId: string, options?: any) {
        return AccessApiFp(this.configuration).deleteAccess(accessId, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve the access with **accessId**. The retrieved object does not contain sensitive information such as the PIN.
     * @summary Get access
     * @param {string} accessId The **id** for the access to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessApi
     */
    public getAccess(accessId: string, options?: any) {
        return AccessApiFp(this.configuration).getAccess(accessId, options)(this.fetch, this.basePath);
    }

    /**
     * Returns all registered accesses for the authenticated user. The access fields contain confidential information (e.g., PIN) that will not be returned.
     * @summary List accesses
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessApi
     */
    public getAccesses(options?: any) {
        return AccessApiFp(this.configuration).getAccesses(options)(this.fetch, this.basePath);
    }

    /**
     * Create a new access and setup all associated accounts and transactions. This will also trigger the creation of monthly transaction summaries, the analysis of all accounts for recurring transactions, and the calculation of the balance forecast.   If the credentials were invalid, the validation state is set accordingly.    It is possible to have multiple accesses for one user.
     * @summary Create a new access
     * @param {Access} accessDto A valid BankAccess object containing the required             **accessFields** as indicated by the provider object and the             **providerId**.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessApi
     */
    public postAccess(accessDto: Access, options?: any) {
        return AccessApiFp(this.configuration).postAccess(accessDto, options)(this.fetch, this.basePath);
    }

    /**
     * Update the access credentials in **accessFields**. If the access does not exist, the **accessId** does not match the **id** in **accessDto**, or the **providerId** is not the same, status code 404 is returned. If another access with the same login data already exists, status code 409 is returned.  The updated access is validated by setting up an account. Status code 200 does not imply that the credentials are correct. To check this, the client should obtain access.
     * @summary Update access
     * @param {string} accessId The **id** for the access to update
     * @param {Access} accessDto The access object that contains the changed credentials in             **accessFields**. Other fields cannot be edited.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessApi
     */
    public putAccess(accessId: string, accessDto: Access, options?: any) {
        return AccessApiFp(this.configuration).putAccess(accessId, accessDto, options)(this.fetch, this.basePath);
    }

}

/**
 * AccountApi - fetch parameter creator
 * @export
 */
export const AccountApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete the account identified by **accountId**
         * @summary Delete account
         * @param {string} accessId The **accessId** for the account to delete
         * @param {string} accountId The **id** for the account to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccount(accessId: string, accountId: string, options: any = {}): FetchArgs {
            // verify required parameter 'accessId' is not null or undefined
            if (accessId === null || accessId === undefined) {
                throw new RequiredError('accessId','Required parameter accessId was null or undefined when calling deleteAccount.');
            }
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new RequiredError('accountId','Required parameter accountId was null or undefined when calling deleteAccount.');
            }
            const localVarPath = `/accesses/{accessId}/accounts/{accountId}`
                .replace(`{${"accessId"}}`, encodeURIComponent(String(accessId)))
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the account identified by **accountId**
         * @summary Get account
         * @param {string} accessId The **accessId** for the account to retrieve
         * @param {string} accountId The **id** for the account to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccount(accessId: string, accountId: string, options: any = {}): FetchArgs {
            // verify required parameter 'accessId' is not null or undefined
            if (accessId === null || accessId === undefined) {
                throw new RequiredError('accessId','Required parameter accessId was null or undefined when calling getAccount.');
            }
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new RequiredError('accountId','Required parameter accountId was null or undefined when calling getAccount.');
            }
            const localVarPath = `/accesses/{accessId}/accounts/{accountId}`
                .replace(`{${"accessId"}}`, encodeURIComponent(String(accessId)))
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all accounts for the current user under the **accessId**
         * @summary List accounts
         * @param {string} accessId The **id** for the access for which to retrieve all accounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccounts(accessId: string, options: any = {}): FetchArgs {
            // verify required parameter 'accessId' is not null or undefined
            if (accessId === null || accessId === undefined) {
                throw new RequiredError('accessId','Required parameter accessId was null or undefined when calling getAccounts.');
            }
            const localVarPath = `/accesses/{accessId}/accounts`
                .replace(`{${"accessId"}}`, encodeURIComponent(String(accessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the account name used in AHOI. Name must be URL encoded.
         * @summary Update account name
         * @param {string} accessId The **accessId** for which the user-defined account name should be altered
         * @param {string} accountId The **id** for which the user-defined account name should be altered
         * @param {string} name The new URL-encoded name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccount(accessId: string, accountId: string, name: string, options: any = {}): FetchArgs {
            // verify required parameter 'accessId' is not null or undefined
            if (accessId === null || accessId === undefined) {
                throw new RequiredError('accessId','Required parameter accessId was null or undefined when calling updateAccount.');
            }
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new RequiredError('accountId','Required parameter accountId was null or undefined when calling updateAccount.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling updateAccount.');
            }
            const localVarPath = `/accesses/{accessId}/accounts/{accountId}/userdefinedname/{name}`
                .replace(`{${"accessId"}}`, encodeURIComponent(String(accessId)))
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountApi - functional programming interface
 * @export
 */
export const AccountApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Delete the account identified by **accountId**
         * @summary Delete account
         * @param {string} accessId The **accessId** for the account to delete
         * @param {string} accountId The **id** for the account to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccount(accessId: string, accountId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AccountApiFetchParamCreator(configuration).deleteAccount(accessId, accountId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns the account identified by **accountId**
         * @summary Get account
         * @param {string} accessId The **accessId** for the account to retrieve
         * @param {string} accountId The **id** for the account to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccount(accessId: string, accountId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Account> {
            const localVarFetchArgs = AccountApiFetchParamCreator(configuration).getAccount(accessId, accountId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve all accounts for the current user under the **accessId**
         * @summary List accounts
         * @param {string} accessId The **id** for the access for which to retrieve all accounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccounts(accessId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Account>> {
            const localVarFetchArgs = AccountApiFetchParamCreator(configuration).getAccounts(accessId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update the account name used in AHOI. Name must be URL encoded.
         * @summary Update account name
         * @param {string} accessId The **accessId** for which the user-defined account name should be altered
         * @param {string} accountId The **id** for which the user-defined account name should be altered
         * @param {string} name The new URL-encoded name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccount(accessId: string, accountId: string, name: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Account> {
            const localVarFetchArgs = AccountApiFetchParamCreator(configuration).updateAccount(accessId, accountId, name, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AccountApi - factory interface
 * @export
 */
export const AccountApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Delete the account identified by **accountId**
         * @summary Delete account
         * @param {string} accessId The **accessId** for the account to delete
         * @param {string} accountId The **id** for the account to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccount(accessId: string, accountId: string, options?: any) {
            return AccountApiFp(configuration).deleteAccount(accessId, accountId, options)(fetch, basePath);
        },
        /**
         * Returns the account identified by **accountId**
         * @summary Get account
         * @param {string} accessId The **accessId** for the account to retrieve
         * @param {string} accountId The **id** for the account to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccount(accessId: string, accountId: string, options?: any) {
            return AccountApiFp(configuration).getAccount(accessId, accountId, options)(fetch, basePath);
        },
        /**
         * Retrieve all accounts for the current user under the **accessId**
         * @summary List accounts
         * @param {string} accessId The **id** for the access for which to retrieve all accounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccounts(accessId: string, options?: any) {
            return AccountApiFp(configuration).getAccounts(accessId, options)(fetch, basePath);
        },
        /**
         * Update the account name used in AHOI. Name must be URL encoded.
         * @summary Update account name
         * @param {string} accessId The **accessId** for which the user-defined account name should be altered
         * @param {string} accountId The **id** for which the user-defined account name should be altered
         * @param {string} name The new URL-encoded name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccount(accessId: string, accountId: string, name: string, options?: any) {
            return AccountApiFp(configuration).updateAccount(accessId, accountId, name, options)(fetch, basePath);
        },
    };
};

/**
 * AccountApi - object-oriented interface
 * @export
 * @class AccountApi
 * @extends {BaseAPI}
 */
export class AccountApi extends BaseAPI {
    /**
     * Delete the account identified by **accountId**
     * @summary Delete account
     * @param {string} accessId The **accessId** for the account to delete
     * @param {string} accountId The **id** for the account to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public deleteAccount(accessId: string, accountId: string, options?: any) {
        return AccountApiFp(this.configuration).deleteAccount(accessId, accountId, options)(this.fetch, this.basePath);
    }

    /**
     * Returns the account identified by **accountId**
     * @summary Get account
     * @param {string} accessId The **accessId** for the account to retrieve
     * @param {string} accountId The **id** for the account to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public getAccount(accessId: string, accountId: string, options?: any) {
        return AccountApiFp(this.configuration).getAccount(accessId, accountId, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve all accounts for the current user under the **accessId**
     * @summary List accounts
     * @param {string} accessId The **id** for the access for which to retrieve all accounts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public getAccounts(accessId: string, options?: any) {
        return AccountApiFp(this.configuration).getAccounts(accessId, options)(this.fetch, this.basePath);
    }

    /**
     * Update the account name used in AHOI. Name must be URL encoded.
     * @summary Update account name
     * @param {string} accessId The **accessId** for which the user-defined account name should be altered
     * @param {string} accountId The **id** for which the user-defined account name should be altered
     * @param {string} name The new URL-encoded name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public updateAccount(accessId: string, accountId: string, name: string, options?: any) {
        return AccountApiFp(this.configuration).updateAccount(accessId, accountId, name, options)(this.fetch, this.basePath);
    }

}

/**
 * CategoryApi - fetch parameter creator
 * @export
 */
export const CategoryApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Supported origins are: FINLYTICS
         * @summary Retrieve all categories for given origin
         * @param {string} origin identifier of a supported origin
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategories(origin: string, options: any = {}): FetchArgs {
            // verify required parameter 'origin' is not null or undefined
            if (origin === null || origin === undefined) {
                throw new RequiredError('origin','Required parameter origin was null or undefined when calling getCategories.');
            }
            const localVarPath = `/categories`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (origin !== undefined) {
                localVarQueryParameter['origin'] = origin;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CategoryApi - functional programming interface
 * @export
 */
export const CategoryApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Supported origins are: FINLYTICS
         * @summary Retrieve all categories for given origin
         * @param {string} origin identifier of a supported origin
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategories(origin: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Category>> {
            const localVarFetchArgs = CategoryApiFetchParamCreator(configuration).getCategories(origin, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CategoryApi - factory interface
 * @export
 */
export const CategoryApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Supported origins are: FINLYTICS
         * @summary Retrieve all categories for given origin
         * @param {string} origin identifier of a supported origin
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategories(origin: string, options?: any) {
            return CategoryApiFp(configuration).getCategories(origin, options)(fetch, basePath);
        },
    };
};

/**
 * CategoryApi - object-oriented interface
 * @export
 * @class CategoryApi
 * @extends {BaseAPI}
 */
export class CategoryApi extends BaseAPI {
    /**
     * Supported origins are: FINLYTICS
     * @summary Retrieve all categories for given origin
     * @param {string} origin identifier of a supported origin
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryApi
     */
    public getCategories(origin: string, options?: any) {
        return CategoryApiFp(this.configuration).getCategories(origin, options)(this.fetch, this.basePath);
    }

}

/**
 * ContractApi - fetch parameter creator
 * @export
 */
export const ContractApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * api.resource.contracts.getContractList.description
         * @summary Fetches contract list of current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContractList(options: any = {}): FetchArgs {
            const localVarPath = `/contracts`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContractApi - functional programming interface
 * @export
 */
export const ContractApiFp = function(configuration?: Configuration) {
    return {
        /**
         * api.resource.contracts.getContractList.description
         * @summary Fetches contract list of current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContractList(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Contract>> {
            const localVarFetchArgs = ContractApiFetchParamCreator(configuration).getContractList(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ContractApi - factory interface
 * @export
 */
export const ContractApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * api.resource.contracts.getContractList.description
         * @summary Fetches contract list of current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContractList(options?: any) {
            return ContractApiFp(configuration).getContractList(options)(fetch, basePath);
        },
    };
};

/**
 * ContractApi - object-oriented interface
 * @export
 * @class ContractApi
 * @extends {BaseAPI}
 */
export class ContractApi extends BaseAPI {
    /**
     * api.resource.contracts.getContractList.description
     * @summary Fetches contract list of current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractApi
     */
    public getContractList(options?: any) {
        return ContractApiFp(this.configuration).getContractList(options)(this.fetch, this.basePath);
    }

}

/**
 * ForecastApi - fetch parameter creator
 * @export
 */
export const ForecastApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * The current month is determined by the most recent refresh.
         * @summary Get balance forecast
         * @param {string} accessId The **accessId** for which to retrieve forecasts
         * @param {string} accountId The **accountId** for which to retrieve forecasts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForecast(accessId: string, accountId: string, options: any = {}): FetchArgs {
            // verify required parameter 'accessId' is not null or undefined
            if (accessId === null || accessId === undefined) {
                throw new RequiredError('accessId','Required parameter accessId was null or undefined when calling getForecast.');
            }
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new RequiredError('accountId','Required parameter accountId was null or undefined when calling getForecast.');
            }
            const localVarPath = `/accesses/{accessId}/accounts/{accountId}/forecast`
                .replace(`{${"accessId"}}`, encodeURIComponent(String(accessId)))
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The current month is determined by the most recent refresh of transactions. The request  also retrieves the transactions expected to be applied until the  end of the current month.
         * @summary Get forecast transactions
         * @param {string} accessId The **accessId** for the forecast
         * @param {string} accountId The **id** for the account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForecastTransactions(accessId: string, accountId: string, options: any = {}): FetchArgs {
            // verify required parameter 'accessId' is not null or undefined
            if (accessId === null || accessId === undefined) {
                throw new RequiredError('accessId','Required parameter accessId was null or undefined when calling getForecastTransactions.');
            }
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new RequiredError('accountId','Required parameter accountId was null or undefined when calling getForecastTransactions.');
            }
            const localVarPath = `/accesses/{accessId}/accounts/{accountId}/forecast/transactions`
                .replace(`{${"accessId"}}`, encodeURIComponent(String(accessId)))
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ForecastApi - functional programming interface
 * @export
 */
export const ForecastApiFp = function(configuration?: Configuration) {
    return {
        /**
         * The current month is determined by the most recent refresh.
         * @summary Get balance forecast
         * @param {string} accessId The **accessId** for which to retrieve forecasts
         * @param {string} accountId The **accountId** for which to retrieve forecasts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForecast(accessId: string, accountId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Forecast> {
            const localVarFetchArgs = ForecastApiFetchParamCreator(configuration).getForecast(accessId, accountId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * The current month is determined by the most recent refresh of transactions. The request  also retrieves the transactions expected to be applied until the  end of the current month.
         * @summary Get forecast transactions
         * @param {string} accessId The **accessId** for the forecast
         * @param {string} accountId The **id** for the account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForecastTransactions(accessId: string, accountId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ForecastTransaction> {
            const localVarFetchArgs = ForecastApiFetchParamCreator(configuration).getForecastTransactions(accessId, accountId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ForecastApi - factory interface
 * @export
 */
export const ForecastApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * The current month is determined by the most recent refresh.
         * @summary Get balance forecast
         * @param {string} accessId The **accessId** for which to retrieve forecasts
         * @param {string} accountId The **accountId** for which to retrieve forecasts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForecast(accessId: string, accountId: string, options?: any) {
            return ForecastApiFp(configuration).getForecast(accessId, accountId, options)(fetch, basePath);
        },
        /**
         * The current month is determined by the most recent refresh of transactions. The request  also retrieves the transactions expected to be applied until the  end of the current month.
         * @summary Get forecast transactions
         * @param {string} accessId The **accessId** for the forecast
         * @param {string} accountId The **id** for the account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForecastTransactions(accessId: string, accountId: string, options?: any) {
            return ForecastApiFp(configuration).getForecastTransactions(accessId, accountId, options)(fetch, basePath);
        },
    };
};

/**
 * ForecastApi - object-oriented interface
 * @export
 * @class ForecastApi
 * @extends {BaseAPI}
 */
export class ForecastApi extends BaseAPI {
    /**
     * The current month is determined by the most recent refresh.
     * @summary Get balance forecast
     * @param {string} accessId The **accessId** for which to retrieve forecasts
     * @param {string} accountId The **accountId** for which to retrieve forecasts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ForecastApi
     */
    public getForecast(accessId: string, accountId: string, options?: any) {
        return ForecastApiFp(this.configuration).getForecast(accessId, accountId, options)(this.fetch, this.basePath);
    }

    /**
     * The current month is determined by the most recent refresh of transactions. The request  also retrieves the transactions expected to be applied until the  end of the current month.
     * @summary Get forecast transactions
     * @param {string} accessId The **accessId** for the forecast
     * @param {string} accountId The **id** for the account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ForecastApi
     */
    public getForecastTransactions(accessId: string, accountId: string, options?: any) {
        return ForecastApiFp(this.configuration).getForecastTransactions(accessId, accountId, options)(this.fetch, this.basePath);
    }

}

/**
 * ProviderApi - fetch parameter creator
 * @export
 */
export const ProviderApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve a single provider identified by **providerId**
         * @summary Get provider
         * @param {string} providerId The **providerId** to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProvider(providerId: string, options: any = {}): FetchArgs {
            // verify required parameter 'providerId' is not null or undefined
            if (providerId === null || providerId === undefined) {
                throw new RequiredError('providerId','Required parameter providerId was null or undefined when calling getProvider.');
            }
            const localVarPath = `/providers/{providerId}`
                .replace(`{${"providerId"}}`, encodeURIComponent(String(providerId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of bank providers. A **providerid** is required to create an _access_. To retrieve the necessary access fields, you need to query the specific `provider/{providerId}`. For performance reasons they are kept separate. 
         * @summary List bank providers
         * @param {string} [bankCode] Optional — if length &#x3D; 8, the response will also contain data describing             the fields required for account setup
         * @param {boolean} [supported] Optional — response should only contain providers supported for account             setup via this API
         * @param {string} [query] Optional — search parameters for BankCode, BIC, Location, Name. Will be ignored             if the bankCode query parameter is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProviders(bankCode?: string, supported?: boolean, query?: string, options: any = {}): FetchArgs {
            const localVarPath = `/providers`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (bankCode !== undefined) {
                localVarQueryParameter['bankCode'] = bankCode;
            }

            if (supported !== undefined) {
                localVarQueryParameter['supported'] = supported;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProviderApi - functional programming interface
 * @export
 */
export const ProviderApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Retrieve a single provider identified by **providerId**
         * @summary Get provider
         * @param {string} providerId The **providerId** to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProvider(providerId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Provider> {
            const localVarFetchArgs = ProviderApiFetchParamCreator(configuration).getProvider(providerId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve a list of bank providers. A **providerid** is required to create an _access_. To retrieve the necessary access fields, you need to query the specific `provider/{providerId}`. For performance reasons they are kept separate. 
         * @summary List bank providers
         * @param {string} [bankCode] Optional — if length &#x3D; 8, the response will also contain data describing             the fields required for account setup
         * @param {boolean} [supported] Optional — response should only contain providers supported for account             setup via this API
         * @param {string} [query] Optional — search parameters for BankCode, BIC, Location, Name. Will be ignored             if the bankCode query parameter is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProviders(bankCode?: string, supported?: boolean, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Provider>> {
            const localVarFetchArgs = ProviderApiFetchParamCreator(configuration).getProviders(bankCode, supported, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ProviderApi - factory interface
 * @export
 */
export const ProviderApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Retrieve a single provider identified by **providerId**
         * @summary Get provider
         * @param {string} providerId The **providerId** to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProvider(providerId: string, options?: any) {
            return ProviderApiFp(configuration).getProvider(providerId, options)(fetch, basePath);
        },
        /**
         * Retrieve a list of bank providers. A **providerid** is required to create an _access_. To retrieve the necessary access fields, you need to query the specific `provider/{providerId}`. For performance reasons they are kept separate. 
         * @summary List bank providers
         * @param {string} [bankCode] Optional — if length &#x3D; 8, the response will also contain data describing             the fields required for account setup
         * @param {boolean} [supported] Optional — response should only contain providers supported for account             setup via this API
         * @param {string} [query] Optional — search parameters for BankCode, BIC, Location, Name. Will be ignored             if the bankCode query parameter is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProviders(bankCode?: string, supported?: boolean, query?: string, options?: any) {
            return ProviderApiFp(configuration).getProviders(bankCode, supported, query, options)(fetch, basePath);
        },
    };
};

/**
 * ProviderApi - object-oriented interface
 * @export
 * @class ProviderApi
 * @extends {BaseAPI}
 */
export class ProviderApi extends BaseAPI {
    /**
     * Retrieve a single provider identified by **providerId**
     * @summary Get provider
     * @param {string} providerId The **providerId** to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderApi
     */
    public getProvider(providerId: string, options?: any) {
        return ProviderApiFp(this.configuration).getProvider(providerId, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve a list of bank providers. A **providerid** is required to create an _access_. To retrieve the necessary access fields, you need to query the specific `provider/{providerId}`. For performance reasons they are kept separate. 
     * @summary List bank providers
     * @param {string} [bankCode] Optional — if length &#x3D; 8, the response will also contain data describing             the fields required for account setup
     * @param {boolean} [supported] Optional — response should only contain providers supported for account             setup via this API
     * @param {string} [query] Optional — search parameters for BankCode, BIC, Location, Name. Will be ignored             if the bankCode query parameter is set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderApi
     */
    public getProviders(bankCode?: string, supported?: boolean, query?: string, options?: any) {
        return ProviderApiFp(this.configuration).getProviders(bankCode, supported, query, options)(this.fetch, this.basePath);
    }

}

/**
 * QuickStartApi - fetch parameter creator
 * @export
 */
export const QuickStartApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve a single provider identified by **providerId**
         * @summary Get provider
         * @param {string} providerId The **providerId** to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProvider(providerId: string, options: any = {}): FetchArgs {
            // verify required parameter 'providerId' is not null or undefined
            if (providerId === null || providerId === undefined) {
                throw new RequiredError('providerId','Required parameter providerId was null or undefined when calling getProvider.');
            }
            const localVarPath = `/providers/{providerId}`
                .replace(`{${"providerId"}}`, encodeURIComponent(String(providerId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of bank providers. A **providerid** is required to create an _access_. To retrieve the necessary access fields, you need to query the specific `provider/{providerId}`. For performance reasons they are kept separate. 
         * @summary List bank providers
         * @param {string} [bankCode] Optional — if length &#x3D; 8, the response will also contain data describing             the fields required for account setup
         * @param {boolean} [supported] Optional — response should only contain providers supported for account             setup via this API
         * @param {string} [query] Optional — search parameters for BankCode, BIC, Location, Name. Will be ignored             if the bankCode query parameter is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProviders(bankCode?: string, supported?: boolean, query?: string, options: any = {}): FetchArgs {
            const localVarPath = `/providers`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (bankCode !== undefined) {
                localVarQueryParameter['bankCode'] = bankCode;
            }

            if (supported !== undefined) {
                localVarQueryParameter['supported'] = supported;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new access and setup all associated accounts and transactions. This will also trigger the creation of monthly transaction summaries, the analysis of all accounts for recurring transactions, and the calculation of the balance forecast.   If the credentials were invalid, the validation state is set accordingly.    It is possible to have multiple accesses for one user.
         * @summary Create a new access
         * @param {Access} accessDto A valid BankAccess object containing the required             **accessFields** as indicated by the provider object and the             **providerId**.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAccess(accessDto: Access, options: any = {}): FetchArgs {
            // verify required parameter 'accessDto' is not null or undefined
            if (accessDto === null || accessDto === undefined) {
                throw new RequiredError('accessDto','Required parameter accessDto was null or undefined when calling postAccess.');
            }
            const localVarPath = `/accesses`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Access" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(accessDto || {}) : (accessDto || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Registers a user with AHOI
         * @summary User registration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register(options: any = {}): FetchArgs {
            const localVarPath = `/registration`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QuickStartApi - functional programming interface
 * @export
 */
export const QuickStartApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Retrieve a single provider identified by **providerId**
         * @summary Get provider
         * @param {string} providerId The **providerId** to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProvider(providerId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Provider> {
            const localVarFetchArgs = QuickStartApiFetchParamCreator(configuration).getProvider(providerId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve a list of bank providers. A **providerid** is required to create an _access_. To retrieve the necessary access fields, you need to query the specific `provider/{providerId}`. For performance reasons they are kept separate. 
         * @summary List bank providers
         * @param {string} [bankCode] Optional — if length &#x3D; 8, the response will also contain data describing             the fields required for account setup
         * @param {boolean} [supported] Optional — response should only contain providers supported for account             setup via this API
         * @param {string} [query] Optional — search parameters for BankCode, BIC, Location, Name. Will be ignored             if the bankCode query parameter is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProviders(bankCode?: string, supported?: boolean, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Provider>> {
            const localVarFetchArgs = QuickStartApiFetchParamCreator(configuration).getProviders(bankCode, supported, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create a new access and setup all associated accounts and transactions. This will also trigger the creation of monthly transaction summaries, the analysis of all accounts for recurring transactions, and the calculation of the balance forecast.   If the credentials were invalid, the validation state is set accordingly.    It is possible to have multiple accesses for one user.
         * @summary Create a new access
         * @param {Access} accessDto A valid BankAccess object containing the required             **accessFields** as indicated by the provider object and the             **providerId**.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAccess(accessDto: Access, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Access> {
            const localVarFetchArgs = QuickStartApiFetchParamCreator(configuration).postAccess(accessDto, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Registers a user with AHOI
         * @summary User registration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RegistrationResponse> {
            const localVarFetchArgs = QuickStartApiFetchParamCreator(configuration).register(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * QuickStartApi - factory interface
 * @export
 */
export const QuickStartApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Retrieve a single provider identified by **providerId**
         * @summary Get provider
         * @param {string} providerId The **providerId** to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProvider(providerId: string, options?: any) {
            return QuickStartApiFp(configuration).getProvider(providerId, options)(fetch, basePath);
        },
        /**
         * Retrieve a list of bank providers. A **providerid** is required to create an _access_. To retrieve the necessary access fields, you need to query the specific `provider/{providerId}`. For performance reasons they are kept separate. 
         * @summary List bank providers
         * @param {string} [bankCode] Optional — if length &#x3D; 8, the response will also contain data describing             the fields required for account setup
         * @param {boolean} [supported] Optional — response should only contain providers supported for account             setup via this API
         * @param {string} [query] Optional — search parameters for BankCode, BIC, Location, Name. Will be ignored             if the bankCode query parameter is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProviders(bankCode?: string, supported?: boolean, query?: string, options?: any) {
            return QuickStartApiFp(configuration).getProviders(bankCode, supported, query, options)(fetch, basePath);
        },
        /**
         * Create a new access and setup all associated accounts and transactions. This will also trigger the creation of monthly transaction summaries, the analysis of all accounts for recurring transactions, and the calculation of the balance forecast.   If the credentials were invalid, the validation state is set accordingly.    It is possible to have multiple accesses for one user.
         * @summary Create a new access
         * @param {Access} accessDto A valid BankAccess object containing the required             **accessFields** as indicated by the provider object and the             **providerId**.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAccess(accessDto: Access, options?: any) {
            return QuickStartApiFp(configuration).postAccess(accessDto, options)(fetch, basePath);
        },
        /**
         * Registers a user with AHOI
         * @summary User registration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register(options?: any) {
            return QuickStartApiFp(configuration).register(options)(fetch, basePath);
        },
    };
};

/**
 * QuickStartApi - object-oriented interface
 * @export
 * @class QuickStartApi
 * @extends {BaseAPI}
 */
export class QuickStartApi extends BaseAPI {
    /**
     * Retrieve a single provider identified by **providerId**
     * @summary Get provider
     * @param {string} providerId The **providerId** to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuickStartApi
     */
    public getProvider(providerId: string, options?: any) {
        return QuickStartApiFp(this.configuration).getProvider(providerId, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve a list of bank providers. A **providerid** is required to create an _access_. To retrieve the necessary access fields, you need to query the specific `provider/{providerId}`. For performance reasons they are kept separate. 
     * @summary List bank providers
     * @param {string} [bankCode] Optional — if length &#x3D; 8, the response will also contain data describing             the fields required for account setup
     * @param {boolean} [supported] Optional — response should only contain providers supported for account             setup via this API
     * @param {string} [query] Optional — search parameters for BankCode, BIC, Location, Name. Will be ignored             if the bankCode query parameter is set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuickStartApi
     */
    public getProviders(bankCode?: string, supported?: boolean, query?: string, options?: any) {
        return QuickStartApiFp(this.configuration).getProviders(bankCode, supported, query, options)(this.fetch, this.basePath);
    }

    /**
     * Create a new access and setup all associated accounts and transactions. This will also trigger the creation of monthly transaction summaries, the analysis of all accounts for recurring transactions, and the calculation of the balance forecast.   If the credentials were invalid, the validation state is set accordingly.    It is possible to have multiple accesses for one user.
     * @summary Create a new access
     * @param {Access} accessDto A valid BankAccess object containing the required             **accessFields** as indicated by the provider object and the             **providerId**.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuickStartApi
     */
    public postAccess(accessDto: Access, options?: any) {
        return QuickStartApiFp(this.configuration).postAccess(accessDto, options)(this.fetch, this.basePath);
    }

    /**
     * Registers a user with AHOI
     * @summary User registration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuickStartApi
     */
    public register(options?: any) {
        return QuickStartApiFp(this.configuration).register(options)(this.fetch, this.basePath);
    }

}

/**
 * RegistrationApi - fetch parameter creator
 * @export
 */
export const RegistrationApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * api.resource.registration.deleteRegistration.description
         * @summary Delete the user context for the current token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRegistration(options: any = {}): FetchArgs {
            const localVarPath = `/registration`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A valid API public key will be returned in JWK format to be used to encrypt registration data. Only needed with extended encryption.
         * @summary Request API JWK public key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJsonWebKey(options: any = {}): FetchArgs {
            const localVarPath = `/registration/jwk`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A valid API public key will be returned to be used to encrypt registration data. Only needed with extended encryption.
         * @summary Request API public key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRegistrationPublicKey(options: any = {}): FetchArgs {
            const localVarPath = `/registration/keys`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Registers a user with AHOI
         * @summary User registration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register(options: any = {}): FetchArgs {
            const localVarPath = `/registration`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RegistrationApi - functional programming interface
 * @export
 */
export const RegistrationApiFp = function(configuration?: Configuration) {
    return {
        /**
         * api.resource.registration.deleteRegistration.description
         * @summary Delete the user context for the current token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRegistration(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = RegistrationApiFetchParamCreator(configuration).deleteRegistration(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * A valid API public key will be returned in JWK format to be used to encrypt registration data. Only needed with extended encryption.
         * @summary Request API JWK public key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJsonWebKey(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<JwkJwkPublicKey> {
            const localVarFetchArgs = RegistrationApiFetchParamCreator(configuration).getJsonWebKey(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * A valid API public key will be returned to be used to encrypt registration data. Only needed with extended encryption.
         * @summary Request API public key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRegistrationPublicKey(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RegistrationPublicKey> {
            const localVarFetchArgs = RegistrationApiFetchParamCreator(configuration).getRegistrationPublicKey(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Registers a user with AHOI
         * @summary User registration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RegistrationResponse> {
            const localVarFetchArgs = RegistrationApiFetchParamCreator(configuration).register(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * RegistrationApi - factory interface
 * @export
 */
export const RegistrationApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * api.resource.registration.deleteRegistration.description
         * @summary Delete the user context for the current token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRegistration(options?: any) {
            return RegistrationApiFp(configuration).deleteRegistration(options)(fetch, basePath);
        },
        /**
         * A valid API public key will be returned in JWK format to be used to encrypt registration data. Only needed with extended encryption.
         * @summary Request API JWK public key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJsonWebKey(options?: any) {
            return RegistrationApiFp(configuration).getJsonWebKey(options)(fetch, basePath);
        },
        /**
         * A valid API public key will be returned to be used to encrypt registration data. Only needed with extended encryption.
         * @summary Request API public key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRegistrationPublicKey(options?: any) {
            return RegistrationApiFp(configuration).getRegistrationPublicKey(options)(fetch, basePath);
        },
        /**
         * Registers a user with AHOI
         * @summary User registration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register(options?: any) {
            return RegistrationApiFp(configuration).register(options)(fetch, basePath);
        },
    };
};

/**
 * RegistrationApi - object-oriented interface
 * @export
 * @class RegistrationApi
 * @extends {BaseAPI}
 */
export class RegistrationApi extends BaseAPI {
    /**
     * api.resource.registration.deleteRegistration.description
     * @summary Delete the user context for the current token.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegistrationApi
     */
    public deleteRegistration(options?: any) {
        return RegistrationApiFp(this.configuration).deleteRegistration(options)(this.fetch, this.basePath);
    }

    /**
     * A valid API public key will be returned in JWK format to be used to encrypt registration data. Only needed with extended encryption.
     * @summary Request API JWK public key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegistrationApi
     */
    public getJsonWebKey(options?: any) {
        return RegistrationApiFp(this.configuration).getJsonWebKey(options)(this.fetch, this.basePath);
    }

    /**
     * A valid API public key will be returned to be used to encrypt registration data. Only needed with extended encryption.
     * @summary Request API public key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegistrationApi
     */
    public getRegistrationPublicKey(options?: any) {
        return RegistrationApiFp(this.configuration).getRegistrationPublicKey(options)(this.fetch, this.basePath);
    }

    /**
     * Registers a user with AHOI
     * @summary User registration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegistrationApi
     */
    public register(options?: any) {
        return RegistrationApiFp(this.configuration).register(options)(this.fetch, this.basePath);
    }

}

/**
 * SecurityApi - fetch parameter creator
 * @export
 */
export const SecurityApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * api.resource.accesses.accessId.accounts.accountId.securities.securityId.getSecurity.description
         * @summary Get security
         * @param {string} accessId api.resource.accesses.accessId.accounts.accountId.securities.securityId.getSecurity.parameter.accessId.description
         * @param {string} accountId The **accountId** for which to retrieve securities
         * @param {string} securityId The **securityId** for the security to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSecurity(accessId: string, accountId: string, securityId: string, options: any = {}): FetchArgs {
            // verify required parameter 'accessId' is not null or undefined
            if (accessId === null || accessId === undefined) {
                throw new RequiredError('accessId','Required parameter accessId was null or undefined when calling getSecurity.');
            }
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new RequiredError('accountId','Required parameter accountId was null or undefined when calling getSecurity.');
            }
            // verify required parameter 'securityId' is not null or undefined
            if (securityId === null || securityId === undefined) {
                throw new RequiredError('securityId','Required parameter securityId was null or undefined when calling getSecurity.');
            }
            const localVarPath = `/accesses/{accessId}/accounts/{accountId}/securities/{securityId}`
                .replace(`{${"accessId"}}`, encodeURIComponent(String(accessId)))
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"securityId"}}`, encodeURIComponent(String(securityId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * api.resource.accesses.accessId.accounts.accountId.securities.listSecurities.description
         * @summary List securities for account
         * @param {string} accessId api.resource.accesses.accessId.accounts.accountId.securities.listSecurities.parameter.accessId.description
         * @param {string} accountId The **accountId** for which to retrieve securities
         * @param {number} [maxAge] Optional - defines maximum age (in seconds) of cached account data provided by the bank.         A \&quot;maxAge\&quot; of 3600 will not trigger an update of the account securities when the last         refresh was performed 2000 seconds ago.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSecurities(accessId: string, accountId: string, maxAge?: number, options: any = {}): FetchArgs {
            // verify required parameter 'accessId' is not null or undefined
            if (accessId === null || accessId === undefined) {
                throw new RequiredError('accessId','Required parameter accessId was null or undefined when calling listSecurities.');
            }
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new RequiredError('accountId','Required parameter accountId was null or undefined when calling listSecurities.');
            }
            const localVarPath = `/accesses/{accessId}/accounts/{accountId}/securities`
                .replace(`{${"accessId"}}`, encodeURIComponent(String(accessId)))
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (maxAge !== undefined) {
                localVarQueryParameter['max-age'] = maxAge;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SecurityApi - functional programming interface
 * @export
 */
export const SecurityApiFp = function(configuration?: Configuration) {
    return {
        /**
         * api.resource.accesses.accessId.accounts.accountId.securities.securityId.getSecurity.description
         * @summary Get security
         * @param {string} accessId api.resource.accesses.accessId.accounts.accountId.securities.securityId.getSecurity.parameter.accessId.description
         * @param {string} accountId The **accountId** for which to retrieve securities
         * @param {string} securityId The **securityId** for the security to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSecurity(accessId: string, accountId: string, securityId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Security> {
            const localVarFetchArgs = SecurityApiFetchParamCreator(configuration).getSecurity(accessId, accountId, securityId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * api.resource.accesses.accessId.accounts.accountId.securities.listSecurities.description
         * @summary List securities for account
         * @param {string} accessId api.resource.accesses.accessId.accounts.accountId.securities.listSecurities.parameter.accessId.description
         * @param {string} accountId The **accountId** for which to retrieve securities
         * @param {number} [maxAge] Optional - defines maximum age (in seconds) of cached account data provided by the bank.         A \&quot;maxAge\&quot; of 3600 will not trigger an update of the account securities when the last         refresh was performed 2000 seconds ago.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSecurities(accessId: string, accountId: string, maxAge?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Security>> {
            const localVarFetchArgs = SecurityApiFetchParamCreator(configuration).listSecurities(accessId, accountId, maxAge, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SecurityApi - factory interface
 * @export
 */
export const SecurityApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * api.resource.accesses.accessId.accounts.accountId.securities.securityId.getSecurity.description
         * @summary Get security
         * @param {string} accessId api.resource.accesses.accessId.accounts.accountId.securities.securityId.getSecurity.parameter.accessId.description
         * @param {string} accountId The **accountId** for which to retrieve securities
         * @param {string} securityId The **securityId** for the security to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSecurity(accessId: string, accountId: string, securityId: string, options?: any) {
            return SecurityApiFp(configuration).getSecurity(accessId, accountId, securityId, options)(fetch, basePath);
        },
        /**
         * api.resource.accesses.accessId.accounts.accountId.securities.listSecurities.description
         * @summary List securities for account
         * @param {string} accessId api.resource.accesses.accessId.accounts.accountId.securities.listSecurities.parameter.accessId.description
         * @param {string} accountId The **accountId** for which to retrieve securities
         * @param {number} [maxAge] Optional - defines maximum age (in seconds) of cached account data provided by the bank.         A \&quot;maxAge\&quot; of 3600 will not trigger an update of the account securities when the last         refresh was performed 2000 seconds ago.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSecurities(accessId: string, accountId: string, maxAge?: number, options?: any) {
            return SecurityApiFp(configuration).listSecurities(accessId, accountId, maxAge, options)(fetch, basePath);
        },
    };
};

/**
 * SecurityApi - object-oriented interface
 * @export
 * @class SecurityApi
 * @extends {BaseAPI}
 */
export class SecurityApi extends BaseAPI {
    /**
     * api.resource.accesses.accessId.accounts.accountId.securities.securityId.getSecurity.description
     * @summary Get security
     * @param {string} accessId api.resource.accesses.accessId.accounts.accountId.securities.securityId.getSecurity.parameter.accessId.description
     * @param {string} accountId The **accountId** for which to retrieve securities
     * @param {string} securityId The **securityId** for the security to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecurityApi
     */
    public getSecurity(accessId: string, accountId: string, securityId: string, options?: any) {
        return SecurityApiFp(this.configuration).getSecurity(accessId, accountId, securityId, options)(this.fetch, this.basePath);
    }

    /**
     * api.resource.accesses.accessId.accounts.accountId.securities.listSecurities.description
     * @summary List securities for account
     * @param {string} accessId api.resource.accesses.accessId.accounts.accountId.securities.listSecurities.parameter.accessId.description
     * @param {string} accountId The **accountId** for which to retrieve securities
     * @param {number} [maxAge] Optional - defines maximum age (in seconds) of cached account data provided by the bank.         A \&quot;maxAge\&quot; of 3600 will not trigger an update of the account securities when the last         refresh was performed 2000 seconds ago.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecurityApi
     */
    public listSecurities(accessId: string, accountId: string, maxAge?: number, options?: any) {
        return SecurityApiFp(this.configuration).listSecurities(accessId, accountId, maxAge, options)(this.fetch, this.basePath);
    }

}

/**
 * TANSchemesApi - fetch parameter creator
 * @export
 */
export const TANSchemesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the currently selected TAN media for the access
         * @summary Get current TAN media
         * @param {string} accessId The **accessId** for which to retrieve the current TAN media
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentTanMedia(accessId: string, options: any = {}): FetchArgs {
            // verify required parameter 'accessId' is not null or undefined
            if (accessId === null || accessId === undefined) {
                throw new RequiredError('accessId','Required parameter accessId was null or undefined when calling getCurrentTanMedia.');
            }
            const localVarPath = `/accesses/{accessId}/currenttanmedia`
                .replace(`{${"accessId"}}`, encodeURIComponent(String(accessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the currently selected TAN scheme for the access
         * @summary Get current TAN scheme.
         * @param {string} accessId The **accessId** for which to retrieve the current TAN scheme
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentTanScheme(accessId: string, options: any = {}): FetchArgs {
            // verify required parameter 'accessId' is not null or undefined
            if (accessId === null || accessId === undefined) {
                throw new RequiredError('accessId','Required parameter accessId was null or undefined when calling getCurrentTanScheme.');
            }
            const localVarPath = `/accesses/{accessId}/currenttanscheme`
                .replace(`{${"accessId"}}`, encodeURIComponent(String(accessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves all available TAN schemes for access
         * @summary List TAN schemes for access
         * @param {string} accessId The **id** for the access for which to retrieve the TAN list
         * @param {number} [maxAge] Optional - defines maximum age (in seconds) of cached account data provided by the bank.      A \&quot;maxAge\&quot; of 3600 will not trigger an update of TAN schemes when the last refresh was      performed 2000 seconds ago.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTanSchemes(accessId: string, maxAge?: number, options: any = {}): FetchArgs {
            // verify required parameter 'accessId' is not null or undefined
            if (accessId === null || accessId === undefined) {
                throw new RequiredError('accessId','Required parameter accessId was null or undefined when calling getTanSchemes.');
            }
            const localVarPath = `/accesses/{accessId}/tanschemes`
                .replace(`{${"accessId"}}`, encodeURIComponent(String(accessId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (maxAge !== undefined) {
                localVarQueryParameter['max-age'] = maxAge;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the access with a new currentTanMedia
         * @summary Update current TAN media
         * @param {string} accessId The **accessId** for which to set the current TAN media
         * @param {string} tanMediaId The **id** for the TAN media that should be set as the new currentTanMedia
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putCurrentTanMedia(accessId: string, tanMediaId: string, options: any = {}): FetchArgs {
            // verify required parameter 'accessId' is not null or undefined
            if (accessId === null || accessId === undefined) {
                throw new RequiredError('accessId','Required parameter accessId was null or undefined when calling putCurrentTanMedia.');
            }
            // verify required parameter 'tanMediaId' is not null or undefined
            if (tanMediaId === null || tanMediaId === undefined) {
                throw new RequiredError('tanMediaId','Required parameter tanMediaId was null or undefined when calling putCurrentTanMedia.');
            }
            const localVarPath = `/accesses/{accessId}/currenttanmedia/{tanMediaId}`
                .replace(`{${"accessId"}}`, encodeURIComponent(String(accessId)))
                .replace(`{${"tanMediaId"}}`, encodeURIComponent(String(tanMediaId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the access with a new currentTanScheme
         * @summary Update current TAN scheme
         * @param {string} accessId The **accessId** for which to set the current TAN scheme
         * @param {string} tanSchemeId The **id** for the TAN scheme that should be set as the new currentTanScheme
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putCurrentTanScheme(accessId: string, tanSchemeId: string, options: any = {}): FetchArgs {
            // verify required parameter 'accessId' is not null or undefined
            if (accessId === null || accessId === undefined) {
                throw new RequiredError('accessId','Required parameter accessId was null or undefined when calling putCurrentTanScheme.');
            }
            // verify required parameter 'tanSchemeId' is not null or undefined
            if (tanSchemeId === null || tanSchemeId === undefined) {
                throw new RequiredError('tanSchemeId','Required parameter tanSchemeId was null or undefined when calling putCurrentTanScheme.');
            }
            const localVarPath = `/accesses/{accessId}/currenttanscheme/{tanSchemeId}`
                .replace(`{${"accessId"}}`, encodeURIComponent(String(accessId)))
                .replace(`{${"tanSchemeId"}}`, encodeURIComponent(String(tanSchemeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TANSchemesApi - functional programming interface
 * @export
 */
export const TANSchemesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Returns the currently selected TAN media for the access
         * @summary Get current TAN media
         * @param {string} accessId The **accessId** for which to retrieve the current TAN media
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentTanMedia(accessId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TanMedia> {
            const localVarFetchArgs = TANSchemesApiFetchParamCreator(configuration).getCurrentTanMedia(accessId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns the currently selected TAN scheme for the access
         * @summary Get current TAN scheme.
         * @param {string} accessId The **accessId** for which to retrieve the current TAN scheme
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentTanScheme(accessId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TanScheme> {
            const localVarFetchArgs = TANSchemesApiFetchParamCreator(configuration).getCurrentTanScheme(accessId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves all available TAN schemes for access
         * @summary List TAN schemes for access
         * @param {string} accessId The **id** for the access for which to retrieve the TAN list
         * @param {number} [maxAge] Optional - defines maximum age (in seconds) of cached account data provided by the bank.      A \&quot;maxAge\&quot; of 3600 will not trigger an update of TAN schemes when the last refresh was      performed 2000 seconds ago.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTanSchemes(accessId: string, maxAge?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<TanScheme>> {
            const localVarFetchArgs = TANSchemesApiFetchParamCreator(configuration).getTanSchemes(accessId, maxAge, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update the access with a new currentTanMedia
         * @summary Update current TAN media
         * @param {string} accessId The **accessId** for which to set the current TAN media
         * @param {string} tanMediaId The **id** for the TAN media that should be set as the new currentTanMedia
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putCurrentTanMedia(accessId: string, tanMediaId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Access> {
            const localVarFetchArgs = TANSchemesApiFetchParamCreator(configuration).putCurrentTanMedia(accessId, tanMediaId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update the access with a new currentTanScheme
         * @summary Update current TAN scheme
         * @param {string} accessId The **accessId** for which to set the current TAN scheme
         * @param {string} tanSchemeId The **id** for the TAN scheme that should be set as the new currentTanScheme
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putCurrentTanScheme(accessId: string, tanSchemeId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Access> {
            const localVarFetchArgs = TANSchemesApiFetchParamCreator(configuration).putCurrentTanScheme(accessId, tanSchemeId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * TANSchemesApi - factory interface
 * @export
 */
export const TANSchemesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Returns the currently selected TAN media for the access
         * @summary Get current TAN media
         * @param {string} accessId The **accessId** for which to retrieve the current TAN media
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentTanMedia(accessId: string, options?: any) {
            return TANSchemesApiFp(configuration).getCurrentTanMedia(accessId, options)(fetch, basePath);
        },
        /**
         * Returns the currently selected TAN scheme for the access
         * @summary Get current TAN scheme.
         * @param {string} accessId The **accessId** for which to retrieve the current TAN scheme
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentTanScheme(accessId: string, options?: any) {
            return TANSchemesApiFp(configuration).getCurrentTanScheme(accessId, options)(fetch, basePath);
        },
        /**
         * Retrieves all available TAN schemes for access
         * @summary List TAN schemes for access
         * @param {string} accessId The **id** for the access for which to retrieve the TAN list
         * @param {number} [maxAge] Optional - defines maximum age (in seconds) of cached account data provided by the bank.      A \&quot;maxAge\&quot; of 3600 will not trigger an update of TAN schemes when the last refresh was      performed 2000 seconds ago.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTanSchemes(accessId: string, maxAge?: number, options?: any) {
            return TANSchemesApiFp(configuration).getTanSchemes(accessId, maxAge, options)(fetch, basePath);
        },
        /**
         * Update the access with a new currentTanMedia
         * @summary Update current TAN media
         * @param {string} accessId The **accessId** for which to set the current TAN media
         * @param {string} tanMediaId The **id** for the TAN media that should be set as the new currentTanMedia
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putCurrentTanMedia(accessId: string, tanMediaId: string, options?: any) {
            return TANSchemesApiFp(configuration).putCurrentTanMedia(accessId, tanMediaId, options)(fetch, basePath);
        },
        /**
         * Update the access with a new currentTanScheme
         * @summary Update current TAN scheme
         * @param {string} accessId The **accessId** for which to set the current TAN scheme
         * @param {string} tanSchemeId The **id** for the TAN scheme that should be set as the new currentTanScheme
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putCurrentTanScheme(accessId: string, tanSchemeId: string, options?: any) {
            return TANSchemesApiFp(configuration).putCurrentTanScheme(accessId, tanSchemeId, options)(fetch, basePath);
        },
    };
};

/**
 * TANSchemesApi - object-oriented interface
 * @export
 * @class TANSchemesApi
 * @extends {BaseAPI}
 */
export class TANSchemesApi extends BaseAPI {
    /**
     * Returns the currently selected TAN media for the access
     * @summary Get current TAN media
     * @param {string} accessId The **accessId** for which to retrieve the current TAN media
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TANSchemesApi
     */
    public getCurrentTanMedia(accessId: string, options?: any) {
        return TANSchemesApiFp(this.configuration).getCurrentTanMedia(accessId, options)(this.fetch, this.basePath);
    }

    /**
     * Returns the currently selected TAN scheme for the access
     * @summary Get current TAN scheme.
     * @param {string} accessId The **accessId** for which to retrieve the current TAN scheme
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TANSchemesApi
     */
    public getCurrentTanScheme(accessId: string, options?: any) {
        return TANSchemesApiFp(this.configuration).getCurrentTanScheme(accessId, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves all available TAN schemes for access
     * @summary List TAN schemes for access
     * @param {string} accessId The **id** for the access for which to retrieve the TAN list
     * @param {number} [maxAge] Optional - defines maximum age (in seconds) of cached account data provided by the bank.      A \&quot;maxAge\&quot; of 3600 will not trigger an update of TAN schemes when the last refresh was      performed 2000 seconds ago.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TANSchemesApi
     */
    public getTanSchemes(accessId: string, maxAge?: number, options?: any) {
        return TANSchemesApiFp(this.configuration).getTanSchemes(accessId, maxAge, options)(this.fetch, this.basePath);
    }

    /**
     * Update the access with a new currentTanMedia
     * @summary Update current TAN media
     * @param {string} accessId The **accessId** for which to set the current TAN media
     * @param {string} tanMediaId The **id** for the TAN media that should be set as the new currentTanMedia
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TANSchemesApi
     */
    public putCurrentTanMedia(accessId: string, tanMediaId: string, options?: any) {
        return TANSchemesApiFp(this.configuration).putCurrentTanMedia(accessId, tanMediaId, options)(this.fetch, this.basePath);
    }

    /**
     * Update the access with a new currentTanScheme
     * @summary Update current TAN scheme
     * @param {string} accessId The **accessId** for which to set the current TAN scheme
     * @param {string} tanSchemeId The **id** for the TAN scheme that should be set as the new currentTanScheme
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TANSchemesApi
     */
    public putCurrentTanScheme(accessId: string, tanSchemeId: string, options?: any) {
        return TANSchemesApiFp(this.configuration).putCurrentTanScheme(accessId, tanSchemeId, options)(this.fetch, this.basePath);
    }

}

/**
 * TaskApi - fetch parameter creator
 * @export
 */
export const TaskApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This is the third required step when executing a TAN-aware  banking task (e.g., a SEPA transfer).
         * @summary Fetch task challenges
         * @param {string} taskId The **id** of the task
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChallenge(taskId: string, options: any = {}): FetchArgs {
            // verify required parameter 'taskId' is not null or undefined
            if (taskId === null || taskId === undefined) {
                throw new RequiredError('taskId','Required parameter taskId was null or undefined when calling getChallenge.');
            }
            const localVarPath = `/tasks/{taskId}/challenges`
                .replace(`{${"taskId"}}`, encodeURIComponent(String(taskId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this to poll for  status changes (e.g., steps two and five of the SEPA transfer process) or to query the state  after receiving a callback from AHOI.
         * @summary Fetch state of task
         * @param {string} taskId The **id** of the task for which to retrieve the status.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTask(taskId: string, options: any = {}): FetchArgs {
            // verify required parameter 'taskId' is not null or undefined
            if (taskId === null || taskId === undefined) {
                throw new RequiredError('taskId','Required parameter taskId was null or undefined when calling getTask.');
            }
            const localVarPath = `/tasks/{taskId}`
                .replace(`{${"taskId"}}`, encodeURIComponent(String(taskId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The SEPA transfer initiated using the _Transfer_ resource requires this starting with step four.
         * @summary Authorize a task
         * @param {string} taskId The **id** of the task
         * @param {ChallengeResponse} challengeResponse The response to process
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postChallengeResponse(taskId: string, challengeResponse: ChallengeResponse, options: any = {}): FetchArgs {
            // verify required parameter 'taskId' is not null or undefined
            if (taskId === null || taskId === undefined) {
                throw new RequiredError('taskId','Required parameter taskId was null or undefined when calling postChallengeResponse.');
            }
            // verify required parameter 'challengeResponse' is not null or undefined
            if (challengeResponse === null || challengeResponse === undefined) {
                throw new RequiredError('challengeResponse','Required parameter challengeResponse was null or undefined when calling postChallengeResponse.');
            }
            const localVarPath = `/tasks/{taskId}/authorizations`
                .replace(`{${"taskId"}}`, encodeURIComponent(String(taskId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ChallengeResponse" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(challengeResponse || {}) : (challengeResponse || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TaskApi - functional programming interface
 * @export
 */
export const TaskApiFp = function(configuration?: Configuration) {
    return {
        /**
         * This is the third required step when executing a TAN-aware  banking task (e.g., a SEPA transfer).
         * @summary Fetch task challenges
         * @param {string} taskId The **id** of the task
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChallenge(taskId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Challenge> {
            const localVarFetchArgs = TaskApiFetchParamCreator(configuration).getChallenge(taskId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Use this to poll for  status changes (e.g., steps two and five of the SEPA transfer process) or to query the state  after receiving a callback from AHOI.
         * @summary Fetch state of task
         * @param {string} taskId The **id** of the task for which to retrieve the status.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTask(taskId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Task> {
            const localVarFetchArgs = TaskApiFetchParamCreator(configuration).getTask(taskId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * The SEPA transfer initiated using the _Transfer_ resource requires this starting with step four.
         * @summary Authorize a task
         * @param {string} taskId The **id** of the task
         * @param {ChallengeResponse} challengeResponse The response to process
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postChallengeResponse(taskId: string, challengeResponse: ChallengeResponse, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Task> {
            const localVarFetchArgs = TaskApiFetchParamCreator(configuration).postChallengeResponse(taskId, challengeResponse, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * TaskApi - factory interface
 * @export
 */
export const TaskApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * This is the third required step when executing a TAN-aware  banking task (e.g., a SEPA transfer).
         * @summary Fetch task challenges
         * @param {string} taskId The **id** of the task
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChallenge(taskId: string, options?: any) {
            return TaskApiFp(configuration).getChallenge(taskId, options)(fetch, basePath);
        },
        /**
         * Use this to poll for  status changes (e.g., steps two and five of the SEPA transfer process) or to query the state  after receiving a callback from AHOI.
         * @summary Fetch state of task
         * @param {string} taskId The **id** of the task for which to retrieve the status.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTask(taskId: string, options?: any) {
            return TaskApiFp(configuration).getTask(taskId, options)(fetch, basePath);
        },
        /**
         * The SEPA transfer initiated using the _Transfer_ resource requires this starting with step four.
         * @summary Authorize a task
         * @param {string} taskId The **id** of the task
         * @param {ChallengeResponse} challengeResponse The response to process
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postChallengeResponse(taskId: string, challengeResponse: ChallengeResponse, options?: any) {
            return TaskApiFp(configuration).postChallengeResponse(taskId, challengeResponse, options)(fetch, basePath);
        },
    };
};

/**
 * TaskApi - object-oriented interface
 * @export
 * @class TaskApi
 * @extends {BaseAPI}
 */
export class TaskApi extends BaseAPI {
    /**
     * This is the third required step when executing a TAN-aware  banking task (e.g., a SEPA transfer).
     * @summary Fetch task challenges
     * @param {string} taskId The **id** of the task
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public getChallenge(taskId: string, options?: any) {
        return TaskApiFp(this.configuration).getChallenge(taskId, options)(this.fetch, this.basePath);
    }

    /**
     * Use this to poll for  status changes (e.g., steps two and five of the SEPA transfer process) or to query the state  after receiving a callback from AHOI.
     * @summary Fetch state of task
     * @param {string} taskId The **id** of the task for which to retrieve the status.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public getTask(taskId: string, options?: any) {
        return TaskApiFp(this.configuration).getTask(taskId, options)(this.fetch, this.basePath);
    }

    /**
     * The SEPA transfer initiated using the _Transfer_ resource requires this starting with step four.
     * @summary Authorize a task
     * @param {string} taskId The **id** of the task
     * @param {ChallengeResponse} challengeResponse The response to process
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public postChallengeResponse(taskId: string, challengeResponse: ChallengeResponse, options?: any) {
        return TaskApiFp(this.configuration).postChallengeResponse(taskId, challengeResponse, options)(this.fetch, this.basePath);
    }

}

/**
 * TransactionApi - fetch parameter creator
 * @export
 */
export const TransactionApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the transaction identified by **transactionId** in relation to **accountId**.
         * @summary Get transaction
         * @param {string} accessId The **accessId** for the transaction to retrieve
         * @param {string} accountId The **accountId** for the transaction to retrieve
         * @param {string} transactionId The **transactionId** for the pattern to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransaction(accessId: string, accountId: string, transactionId: string, options: any = {}): FetchArgs {
            // verify required parameter 'accessId' is not null or undefined
            if (accessId === null || accessId === undefined) {
                throw new RequiredError('accessId','Required parameter accessId was null or undefined when calling getTransaction.');
            }
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new RequiredError('accountId','Required parameter accountId was null or undefined when calling getTransaction.');
            }
            // verify required parameter 'transactionId' is not null or undefined
            if (transactionId === null || transactionId === undefined) {
                throw new RequiredError('transactionId','Required parameter transactionId was null or undefined when calling getTransaction.');
            }
            const localVarPath = `/accesses/{accessId}/accounts/{accountId}/transactions/{transactionId}`
                .replace(`{${"accessId"}}`, encodeURIComponent(String(accessId)))
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"transactionId"}}`, encodeURIComponent(String(transactionId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all transactions for **accountId**
         * @summary List transactions for account
         * @param {string} accessId The **accessId** for which to retrieve transactions
         * @param {string} accountId The **accountId** for which to retrieve transactions
         * @param {number} [maxAge] Optional - defines maximum age (in seconds) of cached account data provided by the bank.          A \&quot;maxAge\&quot; of 3600 will not trigger an update of transactions, when the last refresh was          performed 2000 seconds ago.
         * @param {number} [limit] Optional — limit the number of returned transactions
         * @param {number} [offset] Optional — skip the first **offset** transactions in the result
         * @param {string} [from] Optional — only return transactions with booking date later than **from**; an ISO8601 Month(2014-11), Date (2014-11-17) or DateTime         (2014-11-17T12:00:00Z)
         * @param {string} [to] Optional — only return transactions with booking date prior or equal to **to**; an ISO8601 Date, Month or DateTime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactions(accessId: string, accountId: string, maxAge?: number, limit?: number, offset?: number, from?: string, to?: string, options: any = {}): FetchArgs {
            // verify required parameter 'accessId' is not null or undefined
            if (accessId === null || accessId === undefined) {
                throw new RequiredError('accessId','Required parameter accessId was null or undefined when calling listTransactions.');
            }
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new RequiredError('accountId','Required parameter accountId was null or undefined when calling listTransactions.');
            }
            const localVarPath = `/accesses/{accessId}/accounts/{accountId}/transactions`
                .replace(`{${"accessId"}}`, encodeURIComponent(String(accessId)))
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (maxAge !== undefined) {
                localVarQueryParameter['max-age'] = maxAge;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all transactions for **patternId**
         * @summary List transactions for pattern
         * @param {string} accessId The **accessId** for which to retrieve transactions
         * @param {string} accountId The **accountId** for which to retrieve transactions
         * @param {string} patternId The **patternId** for which to retrieve transactions
         * @param {number} [maxAge] Optional - defines maximum age (in seconds) of cached account data provided by the bank.       A \&quot;maxAge\&quot; of 3600 will not trigger an update of transactions when the last refresh was       performed 2000 seconds ago.
         * @param {number} [limit] Optional — limit the number of returned transactions
         * @param {number} [offset] Optional — skip the first **offset** transactions in result
         * @param {string} [from] Optional — only return transactions with a booking date later than **from**; an ISO8601 Month(2014-11), Date (2014-11-17) or DateTime         (2014-11-17T12:00:00Z)
         * @param {string} [to] Optional — only return transactions with a booking date prior or equal to **to**; an ISO8601 Date, Month or DateTime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactionsForPattern(accessId: string, accountId: string, patternId: string, maxAge?: number, limit?: number, offset?: number, from?: string, to?: string, options: any = {}): FetchArgs {
            // verify required parameter 'accessId' is not null or undefined
            if (accessId === null || accessId === undefined) {
                throw new RequiredError('accessId','Required parameter accessId was null or undefined when calling listTransactionsForPattern.');
            }
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new RequiredError('accountId','Required parameter accountId was null or undefined when calling listTransactionsForPattern.');
            }
            // verify required parameter 'patternId' is not null or undefined
            if (patternId === null || patternId === undefined) {
                throw new RequiredError('patternId','Required parameter patternId was null or undefined when calling listTransactionsForPattern.');
            }
            const localVarPath = `/accesses/{accessId}/accounts/{accountId}/transactionpatterns/{patternId}/transactions`
                .replace(`{${"accessId"}}`, encodeURIComponent(String(accessId)))
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"patternId"}}`, encodeURIComponent(String(patternId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (maxAge !== undefined) {
                localVarQueryParameter['max-age'] = maxAge;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TransactionApi - functional programming interface
 * @export
 */
export const TransactionApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Returns the transaction identified by **transactionId** in relation to **accountId**.
         * @summary Get transaction
         * @param {string} accessId The **accessId** for the transaction to retrieve
         * @param {string} accountId The **accountId** for the transaction to retrieve
         * @param {string} transactionId The **transactionId** for the pattern to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransaction(accessId: string, accountId: string, transactionId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Transaction> {
            const localVarFetchArgs = TransactionApiFetchParamCreator(configuration).getTransaction(accessId, accountId, transactionId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve all transactions for **accountId**
         * @summary List transactions for account
         * @param {string} accessId The **accessId** for which to retrieve transactions
         * @param {string} accountId The **accountId** for which to retrieve transactions
         * @param {number} [maxAge] Optional - defines maximum age (in seconds) of cached account data provided by the bank.          A \&quot;maxAge\&quot; of 3600 will not trigger an update of transactions, when the last refresh was          performed 2000 seconds ago.
         * @param {number} [limit] Optional — limit the number of returned transactions
         * @param {number} [offset] Optional — skip the first **offset** transactions in the result
         * @param {string} [from] Optional — only return transactions with booking date later than **from**; an ISO8601 Month(2014-11), Date (2014-11-17) or DateTime         (2014-11-17T12:00:00Z)
         * @param {string} [to] Optional — only return transactions with booking date prior or equal to **to**; an ISO8601 Date, Month or DateTime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactions(accessId: string, accountId: string, maxAge?: number, limit?: number, offset?: number, from?: string, to?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Transaction>> {
            const localVarFetchArgs = TransactionApiFetchParamCreator(configuration).listTransactions(accessId, accountId, maxAge, limit, offset, from, to, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve all transactions for **patternId**
         * @summary List transactions for pattern
         * @param {string} accessId The **accessId** for which to retrieve transactions
         * @param {string} accountId The **accountId** for which to retrieve transactions
         * @param {string} patternId The **patternId** for which to retrieve transactions
         * @param {number} [maxAge] Optional - defines maximum age (in seconds) of cached account data provided by the bank.       A \&quot;maxAge\&quot; of 3600 will not trigger an update of transactions when the last refresh was       performed 2000 seconds ago.
         * @param {number} [limit] Optional — limit the number of returned transactions
         * @param {number} [offset] Optional — skip the first **offset** transactions in result
         * @param {string} [from] Optional — only return transactions with a booking date later than **from**; an ISO8601 Month(2014-11), Date (2014-11-17) or DateTime         (2014-11-17T12:00:00Z)
         * @param {string} [to] Optional — only return transactions with a booking date prior or equal to **to**; an ISO8601 Date, Month or DateTime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactionsForPattern(accessId: string, accountId: string, patternId: string, maxAge?: number, limit?: number, offset?: number, from?: string, to?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Transaction>> {
            const localVarFetchArgs = TransactionApiFetchParamCreator(configuration).listTransactionsForPattern(accessId, accountId, patternId, maxAge, limit, offset, from, to, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * TransactionApi - factory interface
 * @export
 */
export const TransactionApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Returns the transaction identified by **transactionId** in relation to **accountId**.
         * @summary Get transaction
         * @param {string} accessId The **accessId** for the transaction to retrieve
         * @param {string} accountId The **accountId** for the transaction to retrieve
         * @param {string} transactionId The **transactionId** for the pattern to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransaction(accessId: string, accountId: string, transactionId: string, options?: any) {
            return TransactionApiFp(configuration).getTransaction(accessId, accountId, transactionId, options)(fetch, basePath);
        },
        /**
         * Retrieve all transactions for **accountId**
         * @summary List transactions for account
         * @param {string} accessId The **accessId** for which to retrieve transactions
         * @param {string} accountId The **accountId** for which to retrieve transactions
         * @param {number} [maxAge] Optional - defines maximum age (in seconds) of cached account data provided by the bank.          A \&quot;maxAge\&quot; of 3600 will not trigger an update of transactions, when the last refresh was          performed 2000 seconds ago.
         * @param {number} [limit] Optional — limit the number of returned transactions
         * @param {number} [offset] Optional — skip the first **offset** transactions in the result
         * @param {string} [from] Optional — only return transactions with booking date later than **from**; an ISO8601 Month(2014-11), Date (2014-11-17) or DateTime         (2014-11-17T12:00:00Z)
         * @param {string} [to] Optional — only return transactions with booking date prior or equal to **to**; an ISO8601 Date, Month or DateTime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactions(accessId: string, accountId: string, maxAge?: number, limit?: number, offset?: number, from?: string, to?: string, options?: any) {
            return TransactionApiFp(configuration).listTransactions(accessId, accountId, maxAge, limit, offset, from, to, options)(fetch, basePath);
        },
        /**
         * Retrieve all transactions for **patternId**
         * @summary List transactions for pattern
         * @param {string} accessId The **accessId** for which to retrieve transactions
         * @param {string} accountId The **accountId** for which to retrieve transactions
         * @param {string} patternId The **patternId** for which to retrieve transactions
         * @param {number} [maxAge] Optional - defines maximum age (in seconds) of cached account data provided by the bank.       A \&quot;maxAge\&quot; of 3600 will not trigger an update of transactions when the last refresh was       performed 2000 seconds ago.
         * @param {number} [limit] Optional — limit the number of returned transactions
         * @param {number} [offset] Optional — skip the first **offset** transactions in result
         * @param {string} [from] Optional — only return transactions with a booking date later than **from**; an ISO8601 Month(2014-11), Date (2014-11-17) or DateTime         (2014-11-17T12:00:00Z)
         * @param {string} [to] Optional — only return transactions with a booking date prior or equal to **to**; an ISO8601 Date, Month or DateTime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactionsForPattern(accessId: string, accountId: string, patternId: string, maxAge?: number, limit?: number, offset?: number, from?: string, to?: string, options?: any) {
            return TransactionApiFp(configuration).listTransactionsForPattern(accessId, accountId, patternId, maxAge, limit, offset, from, to, options)(fetch, basePath);
        },
    };
};

/**
 * TransactionApi - object-oriented interface
 * @export
 * @class TransactionApi
 * @extends {BaseAPI}
 */
export class TransactionApi extends BaseAPI {
    /**
     * Returns the transaction identified by **transactionId** in relation to **accountId**.
     * @summary Get transaction
     * @param {string} accessId The **accessId** for the transaction to retrieve
     * @param {string} accountId The **accountId** for the transaction to retrieve
     * @param {string} transactionId The **transactionId** for the pattern to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionApi
     */
    public getTransaction(accessId: string, accountId: string, transactionId: string, options?: any) {
        return TransactionApiFp(this.configuration).getTransaction(accessId, accountId, transactionId, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve all transactions for **accountId**
     * @summary List transactions for account
     * @param {string} accessId The **accessId** for which to retrieve transactions
     * @param {string} accountId The **accountId** for which to retrieve transactions
     * @param {number} [maxAge] Optional - defines maximum age (in seconds) of cached account data provided by the bank.          A \&quot;maxAge\&quot; of 3600 will not trigger an update of transactions, when the last refresh was          performed 2000 seconds ago.
     * @param {number} [limit] Optional — limit the number of returned transactions
     * @param {number} [offset] Optional — skip the first **offset** transactions in the result
     * @param {string} [from] Optional — only return transactions with booking date later than **from**; an ISO8601 Month(2014-11), Date (2014-11-17) or DateTime         (2014-11-17T12:00:00Z)
     * @param {string} [to] Optional — only return transactions with booking date prior or equal to **to**; an ISO8601 Date, Month or DateTime
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionApi
     */
    public listTransactions(accessId: string, accountId: string, maxAge?: number, limit?: number, offset?: number, from?: string, to?: string, options?: any) {
        return TransactionApiFp(this.configuration).listTransactions(accessId, accountId, maxAge, limit, offset, from, to, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve all transactions for **patternId**
     * @summary List transactions for pattern
     * @param {string} accessId The **accessId** for which to retrieve transactions
     * @param {string} accountId The **accountId** for which to retrieve transactions
     * @param {string} patternId The **patternId** for which to retrieve transactions
     * @param {number} [maxAge] Optional - defines maximum age (in seconds) of cached account data provided by the bank.       A \&quot;maxAge\&quot; of 3600 will not trigger an update of transactions when the last refresh was       performed 2000 seconds ago.
     * @param {number} [limit] Optional — limit the number of returned transactions
     * @param {number} [offset] Optional — skip the first **offset** transactions in result
     * @param {string} [from] Optional — only return transactions with a booking date later than **from**; an ISO8601 Month(2014-11), Date (2014-11-17) or DateTime         (2014-11-17T12:00:00Z)
     * @param {string} [to] Optional — only return transactions with a booking date prior or equal to **to**; an ISO8601 Date, Month or DateTime
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionApi
     */
    public listTransactionsForPattern(accessId: string, accountId: string, patternId: string, maxAge?: number, limit?: number, offset?: number, from?: string, to?: string, options?: any) {
        return TransactionApiFp(this.configuration).listTransactionsForPattern(accessId, accountId, patternId, maxAge, limit, offset, from, to, options)(this.fetch, this.basePath);
    }

}

/**
 * TransactionPatternApi - fetch parameter creator
 * @export
 */
export const TransactionPatternApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Disabling the transaction pattern results in ignoring the pattern in the forecast. The transaction pattern still exists and relationships to transactions are not modified.
         * @summary Enable a transaction pattern
         * @param {string} accessId The **accessId** for which to activate the pattern
         * @param {string} accountId The **accountId** for which to activate the pattern
         * @param {string} patternId The **patternId** to (de)activate
         * @param {boolean} activated If &#x60;true&#x60;, the pattern will be used for forecast calculations;         &#x60;false&#x60; will be ignored.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateTransactionPattern(accessId: string, accountId: string, patternId: string, activated: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'accessId' is not null or undefined
            if (accessId === null || accessId === undefined) {
                throw new RequiredError('accessId','Required parameter accessId was null or undefined when calling activateTransactionPattern.');
            }
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new RequiredError('accountId','Required parameter accountId was null or undefined when calling activateTransactionPattern.');
            }
            // verify required parameter 'patternId' is not null or undefined
            if (patternId === null || patternId === undefined) {
                throw new RequiredError('patternId','Required parameter patternId was null or undefined when calling activateTransactionPattern.');
            }
            // verify required parameter 'activated' is not null or undefined
            if (activated === null || activated === undefined) {
                throw new RequiredError('activated','Required parameter activated was null or undefined when calling activateTransactionPattern.');
            }
            const localVarPath = `/accesses/{accessId}/accounts/{accountId}/transactionpatterns/{patternId}/active/{activated}`
                .replace(`{${"accessId"}}`, encodeURIComponent(String(accessId)))
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"patternId"}}`, encodeURIComponent(String(patternId)))
                .replace(`{${"activated"}}`, encodeURIComponent(String(activated)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete the transaction pattern identified by the **patternId**. All associated transactions will be updated to {{patternId = null}}.
         * @summary Delete transaction pattern
         * @param {string} accessId The **accessId** for the transaction pattern to delete
         * @param {string} accountId The **accountId** for the transaction pattern to delete
         * @param {string} patternId The **patternId** to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTransactionPattern(accessId: string, accountId: string, patternId: string, options: any = {}): FetchArgs {
            // verify required parameter 'accessId' is not null or undefined
            if (accessId === null || accessId === undefined) {
                throw new RequiredError('accessId','Required parameter accessId was null or undefined when calling deleteTransactionPattern.');
            }
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new RequiredError('accountId','Required parameter accountId was null or undefined when calling deleteTransactionPattern.');
            }
            // verify required parameter 'patternId' is not null or undefined
            if (patternId === null || patternId === undefined) {
                throw new RequiredError('patternId','Required parameter patternId was null or undefined when calling deleteTransactionPattern.');
            }
            const localVarPath = `/accesses/{accessId}/accounts/{accountId}/transactionpatterns/{patternId}`
                .replace(`{${"accessId"}}`, encodeURIComponent(String(accessId)))
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"patternId"}}`, encodeURIComponent(String(patternId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the transaction pattern identified by **patternId** in relation to  **accountId**.
         * @summary Get transaction pattern
         * @param {string} accessId The **accessId** for the pattern to retrieve
         * @param {string} accountId The **accoundId** for the pattern to retrieve
         * @param {string} patternId The **patternId** for the pattern to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionPattern(accessId: string, accountId: string, patternId: string, options: any = {}): FetchArgs {
            // verify required parameter 'accessId' is not null or undefined
            if (accessId === null || accessId === undefined) {
                throw new RequiredError('accessId','Required parameter accessId was null or undefined when calling getTransactionPattern.');
            }
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new RequiredError('accountId','Required parameter accountId was null or undefined when calling getTransactionPattern.');
            }
            // verify required parameter 'patternId' is not null or undefined
            if (patternId === null || patternId === undefined) {
                throw new RequiredError('patternId','Required parameter patternId was null or undefined when calling getTransactionPattern.');
            }
            const localVarPath = `/accesses/{accessId}/accounts/{accountId}/transactionpatterns/{patternId}`
                .replace(`{${"accessId"}}`, encodeURIComponent(String(accessId)))
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"patternId"}}`, encodeURIComponent(String(patternId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all transaction patterns for **accountId**. Transaction patterns are recurring transactions automatically identified by the server or manually created via [create transaction pattern](#!/Transaction_pattern/postTransactionPattern).
         * @summary List transaction patterns for account
         * @param {string} accessId The **accessId** for which to retrieve transaction patterns
         * @param {string} accountId The **accountId** for which to retrieve transaction patterns
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactionPatterns(accessId: string, accountId: string, options: any = {}): FetchArgs {
            // verify required parameter 'accessId' is not null or undefined
            if (accessId === null || accessId === undefined) {
                throw new RequiredError('accessId','Required parameter accessId was null or undefined when calling listTransactionPatterns.');
            }
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new RequiredError('accountId','Required parameter accountId was null or undefined when calling listTransactionPatterns.');
            }
            const localVarPath = `/accesses/{accessId}/accounts/{accountId}/transactionpatterns`
                .replace(`{${"accessId"}}`, encodeURIComponent(String(accessId)))
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new pattern for an **accountId**. The **cycle** can be `MONTHLY`, `QUARTERLY`, `SEMI_ANNUALLY` or `ANNUALLY`. The **day** can be between `1` and `366`, depending on **cycle**:  | cycle | day range | example | | --- | --- | --- | | `MONTHLY` | `1`-`31`  | every 29th of the month => `29` | | `QUARTERLY` | `1`-`92`  | 23rd of February (23rd of May, etc.) => `54` (31 [complete first month] + 23 [days in second month]) | | `SEMI_ANNUALLY` | `1`-`184` | 1st of May and 1st of November => `121` (for first half of year: 31 + 28 + 31 + 30 + 1) | | `ANNUALLY` | `1`-`366` | 24th of December => `358` |  If a similar pattern already exists, you will receive an HTTP status code 409.
         * @summary Create a new pattern
         * @param {string} accessId The **accessId** with which the newly created pattern is associated
         * @param {string} accountId The **accountId** with which the newly created pattern is associated
         * @param {TransactionPattern} transactionPatternDto The transaction pattern to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTransactionPattern(accessId: string, accountId: string, transactionPatternDto: TransactionPattern, options: any = {}): FetchArgs {
            // verify required parameter 'accessId' is not null or undefined
            if (accessId === null || accessId === undefined) {
                throw new RequiredError('accessId','Required parameter accessId was null or undefined when calling postTransactionPattern.');
            }
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new RequiredError('accountId','Required parameter accountId was null or undefined when calling postTransactionPattern.');
            }
            // verify required parameter 'transactionPatternDto' is not null or undefined
            if (transactionPatternDto === null || transactionPatternDto === undefined) {
                throw new RequiredError('transactionPatternDto','Required parameter transactionPatternDto was null or undefined when calling postTransactionPattern.');
            }
            const localVarPath = `/accesses/{accessId}/accounts/{accountId}/transactionpatterns`
                .replace(`{${"accessId"}}`, encodeURIComponent(String(accessId)))
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TransactionPattern" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(transactionPatternDto || {}) : (transactionPatternDto || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TransactionPatternApi - functional programming interface
 * @export
 */
export const TransactionPatternApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Disabling the transaction pattern results in ignoring the pattern in the forecast. The transaction pattern still exists and relationships to transactions are not modified.
         * @summary Enable a transaction pattern
         * @param {string} accessId The **accessId** for which to activate the pattern
         * @param {string} accountId The **accountId** for which to activate the pattern
         * @param {string} patternId The **patternId** to (de)activate
         * @param {boolean} activated If &#x60;true&#x60;, the pattern will be used for forecast calculations;         &#x60;false&#x60; will be ignored.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateTransactionPattern(accessId: string, accountId: string, patternId: string, activated: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TransactionPattern> {
            const localVarFetchArgs = TransactionPatternApiFetchParamCreator(configuration).activateTransactionPattern(accessId, accountId, patternId, activated, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete the transaction pattern identified by the **patternId**. All associated transactions will be updated to {{patternId = null}}.
         * @summary Delete transaction pattern
         * @param {string} accessId The **accessId** for the transaction pattern to delete
         * @param {string} accountId The **accountId** for the transaction pattern to delete
         * @param {string} patternId The **patternId** to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTransactionPattern(accessId: string, accountId: string, patternId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = TransactionPatternApiFetchParamCreator(configuration).deleteTransactionPattern(accessId, accountId, patternId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns the transaction pattern identified by **patternId** in relation to  **accountId**.
         * @summary Get transaction pattern
         * @param {string} accessId The **accessId** for the pattern to retrieve
         * @param {string} accountId The **accoundId** for the pattern to retrieve
         * @param {string} patternId The **patternId** for the pattern to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionPattern(accessId: string, accountId: string, patternId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TransactionPattern> {
            const localVarFetchArgs = TransactionPatternApiFetchParamCreator(configuration).getTransactionPattern(accessId, accountId, patternId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns all transaction patterns for **accountId**. Transaction patterns are recurring transactions automatically identified by the server or manually created via [create transaction pattern](#!/Transaction_pattern/postTransactionPattern).
         * @summary List transaction patterns for account
         * @param {string} accessId The **accessId** for which to retrieve transaction patterns
         * @param {string} accountId The **accountId** for which to retrieve transaction patterns
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactionPatterns(accessId: string, accountId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<TransactionPattern>> {
            const localVarFetchArgs = TransactionPatternApiFetchParamCreator(configuration).listTransactionPatterns(accessId, accountId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create a new pattern for an **accountId**. The **cycle** can be `MONTHLY`, `QUARTERLY`, `SEMI_ANNUALLY` or `ANNUALLY`. The **day** can be between `1` and `366`, depending on **cycle**:  | cycle | day range | example | | --- | --- | --- | | `MONTHLY` | `1`-`31`  | every 29th of the month => `29` | | `QUARTERLY` | `1`-`92`  | 23rd of February (23rd of May, etc.) => `54` (31 [complete first month] + 23 [days in second month]) | | `SEMI_ANNUALLY` | `1`-`184` | 1st of May and 1st of November => `121` (for first half of year: 31 + 28 + 31 + 30 + 1) | | `ANNUALLY` | `1`-`366` | 24th of December => `358` |  If a similar pattern already exists, you will receive an HTTP status code 409.
         * @summary Create a new pattern
         * @param {string} accessId The **accessId** with which the newly created pattern is associated
         * @param {string} accountId The **accountId** with which the newly created pattern is associated
         * @param {TransactionPattern} transactionPatternDto The transaction pattern to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTransactionPattern(accessId: string, accountId: string, transactionPatternDto: TransactionPattern, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TransactionPattern> {
            const localVarFetchArgs = TransactionPatternApiFetchParamCreator(configuration).postTransactionPattern(accessId, accountId, transactionPatternDto, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * TransactionPatternApi - factory interface
 * @export
 */
export const TransactionPatternApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Disabling the transaction pattern results in ignoring the pattern in the forecast. The transaction pattern still exists and relationships to transactions are not modified.
         * @summary Enable a transaction pattern
         * @param {string} accessId The **accessId** for which to activate the pattern
         * @param {string} accountId The **accountId** for which to activate the pattern
         * @param {string} patternId The **patternId** to (de)activate
         * @param {boolean} activated If &#x60;true&#x60;, the pattern will be used for forecast calculations;         &#x60;false&#x60; will be ignored.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateTransactionPattern(accessId: string, accountId: string, patternId: string, activated: boolean, options?: any) {
            return TransactionPatternApiFp(configuration).activateTransactionPattern(accessId, accountId, patternId, activated, options)(fetch, basePath);
        },
        /**
         * Delete the transaction pattern identified by the **patternId**. All associated transactions will be updated to {{patternId = null}}.
         * @summary Delete transaction pattern
         * @param {string} accessId The **accessId** for the transaction pattern to delete
         * @param {string} accountId The **accountId** for the transaction pattern to delete
         * @param {string} patternId The **patternId** to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTransactionPattern(accessId: string, accountId: string, patternId: string, options?: any) {
            return TransactionPatternApiFp(configuration).deleteTransactionPattern(accessId, accountId, patternId, options)(fetch, basePath);
        },
        /**
         * Returns the transaction pattern identified by **patternId** in relation to  **accountId**.
         * @summary Get transaction pattern
         * @param {string} accessId The **accessId** for the pattern to retrieve
         * @param {string} accountId The **accoundId** for the pattern to retrieve
         * @param {string} patternId The **patternId** for the pattern to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionPattern(accessId: string, accountId: string, patternId: string, options?: any) {
            return TransactionPatternApiFp(configuration).getTransactionPattern(accessId, accountId, patternId, options)(fetch, basePath);
        },
        /**
         * Returns all transaction patterns for **accountId**. Transaction patterns are recurring transactions automatically identified by the server or manually created via [create transaction pattern](#!/Transaction_pattern/postTransactionPattern).
         * @summary List transaction patterns for account
         * @param {string} accessId The **accessId** for which to retrieve transaction patterns
         * @param {string} accountId The **accountId** for which to retrieve transaction patterns
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactionPatterns(accessId: string, accountId: string, options?: any) {
            return TransactionPatternApiFp(configuration).listTransactionPatterns(accessId, accountId, options)(fetch, basePath);
        },
        /**
         * Create a new pattern for an **accountId**. The **cycle** can be `MONTHLY`, `QUARTERLY`, `SEMI_ANNUALLY` or `ANNUALLY`. The **day** can be between `1` and `366`, depending on **cycle**:  | cycle | day range | example | | --- | --- | --- | | `MONTHLY` | `1`-`31`  | every 29th of the month => `29` | | `QUARTERLY` | `1`-`92`  | 23rd of February (23rd of May, etc.) => `54` (31 [complete first month] + 23 [days in second month]) | | `SEMI_ANNUALLY` | `1`-`184` | 1st of May and 1st of November => `121` (for first half of year: 31 + 28 + 31 + 30 + 1) | | `ANNUALLY` | `1`-`366` | 24th of December => `358` |  If a similar pattern already exists, you will receive an HTTP status code 409.
         * @summary Create a new pattern
         * @param {string} accessId The **accessId** with which the newly created pattern is associated
         * @param {string} accountId The **accountId** with which the newly created pattern is associated
         * @param {TransactionPattern} transactionPatternDto The transaction pattern to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTransactionPattern(accessId: string, accountId: string, transactionPatternDto: TransactionPattern, options?: any) {
            return TransactionPatternApiFp(configuration).postTransactionPattern(accessId, accountId, transactionPatternDto, options)(fetch, basePath);
        },
    };
};

/**
 * TransactionPatternApi - object-oriented interface
 * @export
 * @class TransactionPatternApi
 * @extends {BaseAPI}
 */
export class TransactionPatternApi extends BaseAPI {
    /**
     * Disabling the transaction pattern results in ignoring the pattern in the forecast. The transaction pattern still exists and relationships to transactions are not modified.
     * @summary Enable a transaction pattern
     * @param {string} accessId The **accessId** for which to activate the pattern
     * @param {string} accountId The **accountId** for which to activate the pattern
     * @param {string} patternId The **patternId** to (de)activate
     * @param {boolean} activated If &#x60;true&#x60;, the pattern will be used for forecast calculations;         &#x60;false&#x60; will be ignored.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionPatternApi
     */
    public activateTransactionPattern(accessId: string, accountId: string, patternId: string, activated: boolean, options?: any) {
        return TransactionPatternApiFp(this.configuration).activateTransactionPattern(accessId, accountId, patternId, activated, options)(this.fetch, this.basePath);
    }

    /**
     * Delete the transaction pattern identified by the **patternId**. All associated transactions will be updated to {{patternId = null}}.
     * @summary Delete transaction pattern
     * @param {string} accessId The **accessId** for the transaction pattern to delete
     * @param {string} accountId The **accountId** for the transaction pattern to delete
     * @param {string} patternId The **patternId** to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionPatternApi
     */
    public deleteTransactionPattern(accessId: string, accountId: string, patternId: string, options?: any) {
        return TransactionPatternApiFp(this.configuration).deleteTransactionPattern(accessId, accountId, patternId, options)(this.fetch, this.basePath);
    }

    /**
     * Returns the transaction pattern identified by **patternId** in relation to  **accountId**.
     * @summary Get transaction pattern
     * @param {string} accessId The **accessId** for the pattern to retrieve
     * @param {string} accountId The **accoundId** for the pattern to retrieve
     * @param {string} patternId The **patternId** for the pattern to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionPatternApi
     */
    public getTransactionPattern(accessId: string, accountId: string, patternId: string, options?: any) {
        return TransactionPatternApiFp(this.configuration).getTransactionPattern(accessId, accountId, patternId, options)(this.fetch, this.basePath);
    }

    /**
     * Returns all transaction patterns for **accountId**. Transaction patterns are recurring transactions automatically identified by the server or manually created via [create transaction pattern](#!/Transaction_pattern/postTransactionPattern).
     * @summary List transaction patterns for account
     * @param {string} accessId The **accessId** for which to retrieve transaction patterns
     * @param {string} accountId The **accountId** for which to retrieve transaction patterns
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionPatternApi
     */
    public listTransactionPatterns(accessId: string, accountId: string, options?: any) {
        return TransactionPatternApiFp(this.configuration).listTransactionPatterns(accessId, accountId, options)(this.fetch, this.basePath);
    }

    /**
     * Create a new pattern for an **accountId**. The **cycle** can be `MONTHLY`, `QUARTERLY`, `SEMI_ANNUALLY` or `ANNUALLY`. The **day** can be between `1` and `366`, depending on **cycle**:  | cycle | day range | example | | --- | --- | --- | | `MONTHLY` | `1`-`31`  | every 29th of the month => `29` | | `QUARTERLY` | `1`-`92`  | 23rd of February (23rd of May, etc.) => `54` (31 [complete first month] + 23 [days in second month]) | | `SEMI_ANNUALLY` | `1`-`184` | 1st of May and 1st of November => `121` (for first half of year: 31 + 28 + 31 + 30 + 1) | | `ANNUALLY` | `1`-`366` | 24th of December => `358` |  If a similar pattern already exists, you will receive an HTTP status code 409.
     * @summary Create a new pattern
     * @param {string} accessId The **accessId** with which the newly created pattern is associated
     * @param {string} accountId The **accountId** with which the newly created pattern is associated
     * @param {TransactionPattern} transactionPatternDto The transaction pattern to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionPatternApi
     */
    public postTransactionPattern(accessId: string, accountId: string, transactionPatternDto: TransactionPattern, options?: any) {
        return TransactionPatternApiFp(this.configuration).postTransactionPattern(accessId, accountId, transactionPatternDto, options)(this.fetch, this.basePath);
    }

}

/**
 * TransactionSummaryApi - fetch parameter creator
 * @export
 */
export const TransactionSummaryApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve account summaries and provide a sum for incoming and outgoing transactions
         * @summary List account summaries
         * @param {string} accessId The **accessId** for which to list the summaries
         * @param {string} accountId The **accountId** for which to list the summaries
         * @param {number} [limit] Optional — limit the number of returned summary entries
         * @param {number} [offset] Optional — skip the first **offset** summary entries in the result
         * @param {string} [from] Optional — only return summary entries later than **from**; an         ISO8601 Date (2014-11-17)
         * @param {string} [to] Optional — only return summary entries prior or equal to         **to**; an ISO8601 Date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSummary(accessId: string, accountId: string, limit?: number, offset?: number, from?: string, to?: string, options: any = {}): FetchArgs {
            // verify required parameter 'accessId' is not null or undefined
            if (accessId === null || accessId === undefined) {
                throw new RequiredError('accessId','Required parameter accessId was null or undefined when calling listSummary.');
            }
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new RequiredError('accountId','Required parameter accountId was null or undefined when calling listSummary.');
            }
            const localVarPath = `/accesses/{accessId}/accounts/{accountId}/transactionsummaries`
                .replace(`{${"accessId"}}`, encodeURIComponent(String(accessId)))
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TransactionSummaryApi - functional programming interface
 * @export
 */
export const TransactionSummaryApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Retrieve account summaries and provide a sum for incoming and outgoing transactions
         * @summary List account summaries
         * @param {string} accessId The **accessId** for which to list the summaries
         * @param {string} accountId The **accountId** for which to list the summaries
         * @param {number} [limit] Optional — limit the number of returned summary entries
         * @param {number} [offset] Optional — skip the first **offset** summary entries in the result
         * @param {string} [from] Optional — only return summary entries later than **from**; an         ISO8601 Date (2014-11-17)
         * @param {string} [to] Optional — only return summary entries prior or equal to         **to**; an ISO8601 Date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSummary(accessId: string, accountId: string, limit?: number, offset?: number, from?: string, to?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<MonthlySummary>> {
            const localVarFetchArgs = TransactionSummaryApiFetchParamCreator(configuration).listSummary(accessId, accountId, limit, offset, from, to, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * TransactionSummaryApi - factory interface
 * @export
 */
export const TransactionSummaryApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Retrieve account summaries and provide a sum for incoming and outgoing transactions
         * @summary List account summaries
         * @param {string} accessId The **accessId** for which to list the summaries
         * @param {string} accountId The **accountId** for which to list the summaries
         * @param {number} [limit] Optional — limit the number of returned summary entries
         * @param {number} [offset] Optional — skip the first **offset** summary entries in the result
         * @param {string} [from] Optional — only return summary entries later than **from**; an         ISO8601 Date (2014-11-17)
         * @param {string} [to] Optional — only return summary entries prior or equal to         **to**; an ISO8601 Date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSummary(accessId: string, accountId: string, limit?: number, offset?: number, from?: string, to?: string, options?: any) {
            return TransactionSummaryApiFp(configuration).listSummary(accessId, accountId, limit, offset, from, to, options)(fetch, basePath);
        },
    };
};

/**
 * TransactionSummaryApi - object-oriented interface
 * @export
 * @class TransactionSummaryApi
 * @extends {BaseAPI}
 */
export class TransactionSummaryApi extends BaseAPI {
    /**
     * Retrieve account summaries and provide a sum for incoming and outgoing transactions
     * @summary List account summaries
     * @param {string} accessId The **accessId** for which to list the summaries
     * @param {string} accountId The **accountId** for which to list the summaries
     * @param {number} [limit] Optional — limit the number of returned summary entries
     * @param {number} [offset] Optional — skip the first **offset** summary entries in the result
     * @param {string} [from] Optional — only return summary entries later than **from**; an         ISO8601 Date (2014-11-17)
     * @param {string} [to] Optional — only return summary entries prior or equal to         **to**; an ISO8601 Date
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionSummaryApi
     */
    public listSummary(accessId: string, accountId: string, limit?: number, offset?: number, from?: string, to?: string, options?: any) {
        return TransactionSummaryApiFp(this.configuration).listSummary(accessId, accountId, limit, offset, from, to, options)(this.fetch, this.basePath);
    }

}

/**
 * TransferApi - fetch parameter creator
 * @export
 */
export const TransferApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * <p>**Please note:** <ul>      <li>The IBAN of the receiving account needs to exist, even if it is located in Sandbank. Otherwise the transfer will fail.      <li>The returned JSON document represents the task that covers the transfer process as a result of a subsequent TAN request.  </ul>
         * @summary Create a new transfer
         * @param {string} accessId The **id** of the access corresponding to accounts to be used
         * @param {string} accountId The **id** for the account
         * @param {Transfer} transfer Transfer to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTransfer(accessId: string, accountId: string, transfer: Transfer, options: any = {}): FetchArgs {
            // verify required parameter 'accessId' is not null or undefined
            if (accessId === null || accessId === undefined) {
                throw new RequiredError('accessId','Required parameter accessId was null or undefined when calling postTransfer.');
            }
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new RequiredError('accountId','Required parameter accountId was null or undefined when calling postTransfer.');
            }
            // verify required parameter 'transfer' is not null or undefined
            if (transfer === null || transfer === undefined) {
                throw new RequiredError('transfer','Required parameter transfer was null or undefined when calling postTransfer.');
            }
            const localVarPath = `/accesses/{accessId}/accounts/{accountId}/transfers`
                .replace(`{${"accessId"}}`, encodeURIComponent(String(accessId)))
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Transfer" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(transfer || {}) : (transfer || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TransferApi - functional programming interface
 * @export
 */
export const TransferApiFp = function(configuration?: Configuration) {
    return {
        /**
         * <p>**Please note:** <ul>      <li>The IBAN of the receiving account needs to exist, even if it is located in Sandbank. Otherwise the transfer will fail.      <li>The returned JSON document represents the task that covers the transfer process as a result of a subsequent TAN request.  </ul>
         * @summary Create a new transfer
         * @param {string} accessId The **id** of the access corresponding to accounts to be used
         * @param {string} accountId The **id** for the account
         * @param {Transfer} transfer Transfer to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTransfer(accessId: string, accountId: string, transfer: Transfer, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TransferTask> {
            const localVarFetchArgs = TransferApiFetchParamCreator(configuration).postTransfer(accessId, accountId, transfer, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * TransferApi - factory interface
 * @export
 */
export const TransferApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * <p>**Please note:** <ul>      <li>The IBAN of the receiving account needs to exist, even if it is located in Sandbank. Otherwise the transfer will fail.      <li>The returned JSON document represents the task that covers the transfer process as a result of a subsequent TAN request.  </ul>
         * @summary Create a new transfer
         * @param {string} accessId The **id** of the access corresponding to accounts to be used
         * @param {string} accountId The **id** for the account
         * @param {Transfer} transfer Transfer to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTransfer(accessId: string, accountId: string, transfer: Transfer, options?: any) {
            return TransferApiFp(configuration).postTransfer(accessId, accountId, transfer, options)(fetch, basePath);
        },
    };
};

/**
 * TransferApi - object-oriented interface
 * @export
 * @class TransferApi
 * @extends {BaseAPI}
 */
export class TransferApi extends BaseAPI {
    /**
     * <p>**Please note:** <ul>      <li>The IBAN of the receiving account needs to exist, even if it is located in Sandbank. Otherwise the transfer will fail.      <li>The returned JSON document represents the task that covers the transfer process as a result of a subsequent TAN request.  </ul>
     * @summary Create a new transfer
     * @param {string} accessId The **id** of the access corresponding to accounts to be used
     * @param {string} accountId The **id** for the account
     * @param {Transfer} transfer Transfer to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransferApi
     */
    public postTransfer(accessId: string, accountId: string, transfer: Transfer, options?: any) {
        return TransferApiFp(this.configuration).postTransfer(accessId, accountId, transfer, options)(this.fetch, this.basePath);
    }

}

