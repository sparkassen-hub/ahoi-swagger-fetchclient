<!doctype html>
<html class="no-js" lang="">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <title>ahoi-swagger-fetchclient documentation</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <link rel="icon" type="image/x-icon" href="../images/favicon.ico">
	      <link rel="stylesheet" href="../styles/style.css">
    </head>
    <body>

        <div class="navbar navbar-default navbar-fixed-top visible-xs">
            <a href="../" class="navbar-brand">ahoi-swagger-fetchclient documentation</a>
            <button type="button" class="btn btn-default btn-menu ion-ios-menu" id="btn-menu"></button>
        </div>

        <div class="xs-menu menu" id="mobile-menu">
                <div id="book-search-input" role="search"><input type="text" placeholder="Type to search"></div>            <compodoc-menu></compodoc-menu>
        </div>

        <div class="container-fluid main">
           <div class="row main">
               <div class="hidden-xs menu">
                   <compodoc-menu mode="normal"></compodoc-menu>
               </div>
               <!-- START CONTENT -->
               <div class="content miscellaneous-variables">
                   <div class="content-data">















<ol class="breadcrumb">
  <li>Miscellaneous</li>
  <li>Variables</li>
</ol>

<section>
    <h3 id="index">Index</h3>
    <table class="table table-sm table-bordered index-table">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <ul class="index-list">
                        <li>
                            <a href="#AccessApiFactory" title="api.ts"><b>AccessApiFactory</b>&nbsp;&nbsp;&nbsp;(api.ts)</a>
                        </li>
                        <li>
                            <a href="#AccessApiFetchParamCreator" title="api.ts"><b>AccessApiFetchParamCreator</b>&nbsp;&nbsp;&nbsp;(api.ts)</a>
                        </li>
                        <li>
                            <a href="#AccessApiFp" title="api.ts"><b>AccessApiFp</b>&nbsp;&nbsp;&nbsp;(api.ts)</a>
                        </li>
                        <li>
                            <a href="#AccountApiFactory" title="api.ts"><b>AccountApiFactory</b>&nbsp;&nbsp;&nbsp;(api.ts)</a>
                        </li>
                        <li>
                            <a href="#AccountApiFetchParamCreator" title="api.ts"><b>AccountApiFetchParamCreator</b>&nbsp;&nbsp;&nbsp;(api.ts)</a>
                        </li>
                        <li>
                            <a href="#AccountApiFp" title="api.ts"><b>AccountApiFp</b>&nbsp;&nbsp;&nbsp;(api.ts)</a>
                        </li>
                        <li>
                            <a href="#BASE_PATH" title="api.ts"><b>BASE_PATH</b>&nbsp;&nbsp;&nbsp;(api.ts)</a>
                        </li>
                        <li>
                            <a href="#CategoryApiFactory" title="api.ts"><b>CategoryApiFactory</b>&nbsp;&nbsp;&nbsp;(api.ts)</a>
                        </li>
                        <li>
                            <a href="#CategoryApiFetchParamCreator" title="api.ts"><b>CategoryApiFetchParamCreator</b>&nbsp;&nbsp;&nbsp;(api.ts)</a>
                        </li>
                        <li>
                            <a href="#CategoryApiFp" title="api.ts"><b>CategoryApiFp</b>&nbsp;&nbsp;&nbsp;(api.ts)</a>
                        </li>
                        <li>
                            <a href="#COLLECTION_FORMATS" title="api.ts"><b>COLLECTION_FORMATS</b>&nbsp;&nbsp;&nbsp;(api.ts)</a>
                        </li>
                        <li>
                            <a href="#ContractApiFactory" title="api.ts"><b>ContractApiFactory</b>&nbsp;&nbsp;&nbsp;(api.ts)</a>
                        </li>
                        <li>
                            <a href="#ContractApiFetchParamCreator" title="api.ts"><b>ContractApiFetchParamCreator</b>&nbsp;&nbsp;&nbsp;(api.ts)</a>
                        </li>
                        <li>
                            <a href="#ContractApiFp" title="api.ts"><b>ContractApiFp</b>&nbsp;&nbsp;&nbsp;(api.ts)</a>
                        </li>
                        <li>
                            <a href="#ForecastApiFactory" title="api.ts"><b>ForecastApiFactory</b>&nbsp;&nbsp;&nbsp;(api.ts)</a>
                        </li>
                        <li>
                            <a href="#ForecastApiFetchParamCreator" title="api.ts"><b>ForecastApiFetchParamCreator</b>&nbsp;&nbsp;&nbsp;(api.ts)</a>
                        </li>
                        <li>
                            <a href="#ForecastApiFp" title="api.ts"><b>ForecastApiFp</b>&nbsp;&nbsp;&nbsp;(api.ts)</a>
                        </li>
                        <li>
                            <a href="#ProviderApiFactory" title="api.ts"><b>ProviderApiFactory</b>&nbsp;&nbsp;&nbsp;(api.ts)</a>
                        </li>
                        <li>
                            <a href="#ProviderApiFetchParamCreator" title="api.ts"><b>ProviderApiFetchParamCreator</b>&nbsp;&nbsp;&nbsp;(api.ts)</a>
                        </li>
                        <li>
                            <a href="#ProviderApiFp" title="api.ts"><b>ProviderApiFp</b>&nbsp;&nbsp;&nbsp;(api.ts)</a>
                        </li>
                        <li>
                            <a href="#RegistrationApiFactory" title="api.ts"><b>RegistrationApiFactory</b>&nbsp;&nbsp;&nbsp;(api.ts)</a>
                        </li>
                        <li>
                            <a href="#RegistrationApiFetchParamCreator" title="api.ts"><b>RegistrationApiFetchParamCreator</b>&nbsp;&nbsp;&nbsp;(api.ts)</a>
                        </li>
                        <li>
                            <a href="#RegistrationApiFp" title="api.ts"><b>RegistrationApiFp</b>&nbsp;&nbsp;&nbsp;(api.ts)</a>
                        </li>
                        <li>
                            <a href="#SecurityApiFactory" title="api.ts"><b>SecurityApiFactory</b>&nbsp;&nbsp;&nbsp;(api.ts)</a>
                        </li>
                        <li>
                            <a href="#SecurityApiFetchParamCreator" title="api.ts"><b>SecurityApiFetchParamCreator</b>&nbsp;&nbsp;&nbsp;(api.ts)</a>
                        </li>
                        <li>
                            <a href="#SecurityApiFp" title="api.ts"><b>SecurityApiFp</b>&nbsp;&nbsp;&nbsp;(api.ts)</a>
                        </li>
                        <li>
                            <a href="#TANSchemesApiFactory" title="api.ts"><b>TANSchemesApiFactory</b>&nbsp;&nbsp;&nbsp;(api.ts)</a>
                        </li>
                        <li>
                            <a href="#TANSchemesApiFetchParamCreator" title="api.ts"><b>TANSchemesApiFetchParamCreator</b>&nbsp;&nbsp;&nbsp;(api.ts)</a>
                        </li>
                        <li>
                            <a href="#TANSchemesApiFp" title="api.ts"><b>TANSchemesApiFp</b>&nbsp;&nbsp;&nbsp;(api.ts)</a>
                        </li>
                        <li>
                            <a href="#TaskApiFactory" title="api.ts"><b>TaskApiFactory</b>&nbsp;&nbsp;&nbsp;(api.ts)</a>
                        </li>
                        <li>
                            <a href="#TaskApiFetchParamCreator" title="api.ts"><b>TaskApiFetchParamCreator</b>&nbsp;&nbsp;&nbsp;(api.ts)</a>
                        </li>
                        <li>
                            <a href="#TaskApiFp" title="api.ts"><b>TaskApiFp</b>&nbsp;&nbsp;&nbsp;(api.ts)</a>
                        </li>
                        <li>
                            <a href="#TransactionApiFactory" title="api.ts"><b>TransactionApiFactory</b>&nbsp;&nbsp;&nbsp;(api.ts)</a>
                        </li>
                        <li>
                            <a href="#TransactionApiFetchParamCreator" title="api.ts"><b>TransactionApiFetchParamCreator</b>&nbsp;&nbsp;&nbsp;(api.ts)</a>
                        </li>
                        <li>
                            <a href="#TransactionApiFp" title="api.ts"><b>TransactionApiFp</b>&nbsp;&nbsp;&nbsp;(api.ts)</a>
                        </li>
                        <li>
                            <a href="#TransactionPatternApiFactory" title="api.ts"><b>TransactionPatternApiFactory</b>&nbsp;&nbsp;&nbsp;(api.ts)</a>
                        </li>
                        <li>
                            <a href="#TransactionPatternApiFetchParamCreator" title="api.ts"><b>TransactionPatternApiFetchParamCreator</b>&nbsp;&nbsp;&nbsp;(api.ts)</a>
                        </li>
                        <li>
                            <a href="#TransactionPatternApiFp" title="api.ts"><b>TransactionPatternApiFp</b>&nbsp;&nbsp;&nbsp;(api.ts)</a>
                        </li>
                        <li>
                            <a href="#TransactionSummaryApiFactory" title="api.ts"><b>TransactionSummaryApiFactory</b>&nbsp;&nbsp;&nbsp;(api.ts)</a>
                        </li>
                        <li>
                            <a href="#TransactionSummaryApiFetchParamCreator" title="api.ts"><b>TransactionSummaryApiFetchParamCreator</b>&nbsp;&nbsp;&nbsp;(api.ts)</a>
                        </li>
                        <li>
                            <a href="#TransactionSummaryApiFp" title="api.ts"><b>TransactionSummaryApiFp</b>&nbsp;&nbsp;&nbsp;(api.ts)</a>
                        </li>
                        <li>
                            <a href="#TransferApiFactory" title="api.ts"><b>TransferApiFactory</b>&nbsp;&nbsp;&nbsp;(api.ts)</a>
                        </li>
                        <li>
                            <a href="#TransferApiFetchParamCreator" title="api.ts"><b>TransferApiFetchParamCreator</b>&nbsp;&nbsp;&nbsp;(api.ts)</a>
                        </li>
                        <li>
                            <a href="#TransferApiFp" title="api.ts"><b>TransferApiFp</b>&nbsp;&nbsp;&nbsp;(api.ts)</a>
                        </li>
                    </ul>
                </td>
            </tr>
        </tbody>
    </table>
</section>

    <h3>api.ts</h3>
    <section>
    <h3></h3>        <table class="table table-sm table-bordered">
            <tbody>
                <tr>
                    <td class="col-md-4">
                        <a name="AccessApiFactory"></a>
                        <span class="name">
                            <b>
                            AccessApiFactory
                            </b>
                            <a href="#AccessApiFactory"><span class="icon ion-ios-link"></span></a>
                        </span>
                    </td>
                </tr>
                <tr>
                    <td class="col-md-4">
                        <code>AccessApiFactory:     <code></code>
</code>
                    </td>
                </tr>
                    <tr>
                        <td class="col-md-4">
                            <i>Default value : </i><code>function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Delete access with **accessId** and all related accounts.
         * @summary Delete access
         * @param {string} accessId The **id** for the access to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccess(accessId: string, options?: any) {
            return AccessApiFp(configuration).deleteAccess(accessId, options)(fetch, basePath);
        },
        /**
         * Retrieve the access with **accessId**. The retrieved object does not contain sensitive information such as the PIN.
         * @summary Get access
         * @param {string} accessId The **id** for the access to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccess(accessId: string, options?: any) {
            return AccessApiFp(configuration).getAccess(accessId, options)(fetch, basePath);
        },
        /**
         * Returns all registered accesses for the authenticated user. Confidential information like the PIN will not be returned.
         * @summary List accesses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccesses(options?: any) {
            return AccessApiFp(configuration).getAccesses(options)(fetch, basePath);
        },
        /**
         * Create a new access and setup all associated accounts and transactions. This will also trigger the creation of monthly transaction summaries, the analysis of all accounts for recurring transactions, and the calculation of the balance forecast.   If the credentials were invalid, the validation state is set accordingly.    It is possible to have multiple accesses for one user.
         * @summary Create a new access
         * @param {Access} accessDto A valid BankAccess object containing the required             **accessFields** as indicated by the provider object and the             **providerId**.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAccess(accessDto: Access, options?: any) {
            return AccessApiFp(configuration).postAccess(accessDto, options)(fetch, basePath);
        },
        /**
         * Update the access credentials in **accessFields**. If the access does not exist, the **accessId** does not match the **id** in **accessDto** or the **providerId** is not the same, the status code 404 is returned. If another access with the same login  data already exists, the status code 409 is returned.  The updated access is validated by setting up an account. The status code 200 does not imply that the credentials are correct. To check this the client should obtain access.
         * @summary Update access
         * @param {string} accessId The **id** for the access to update.
         * @param {Access} accessDto The Access object that contains the changed credentials in             **accessFields**. Other fields cannot be edited.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putAccess(accessId: string, accessDto: Access, options?: any) {
            return AccessApiFp(configuration).putAccess(accessId, accessDto, options)(fetch, basePath);
        },
    };
}</code>
                        </td>
                    </tr>

                <tr>
                    <td class="col-md-4">
                        <div class="io-description"><p>AccessApi - factory interface</p>
</div>
                    </td>
                </tr>

            </tbody>
        </table>
        <table class="table table-sm table-bordered">
            <tbody>
                <tr>
                    <td class="col-md-4">
                        <a name="AccessApiFetchParamCreator"></a>
                        <span class="name">
                            <b>
                            AccessApiFetchParamCreator
                            </b>
                            <a href="#AccessApiFetchParamCreator"><span class="icon ion-ios-link"></span></a>
                        </span>
                    </td>
                </tr>
                <tr>
                    <td class="col-md-4">
                        <code>AccessApiFetchParamCreator:     <code></code>
</code>
                    </td>
                </tr>
                    <tr>
                        <td class="col-md-4">
                            <i>Default value : </i><code>function (configuration?: Configuration) {
    return {
        /**
         * Delete access with **accessId** and all related accounts.
         * @summary Delete access
         * @param {string} accessId The **id** for the access to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccess(accessId: string, options: any &#x3D; {}): FetchArgs {
            // verify required parameter &#x27;accessId&#x27; is not null or undefined
            if (accessId &#x3D;&#x3D;&#x3D; null || accessId &#x3D;&#x3D;&#x3D; undefined) {
                throw new RequiredError(&#x27;accessId&#x27;,&#x27;Required parameter accessId was null or undefined when calling deleteAccess.&#x27;);
            }
            const localVarPath &#x3D; &#x60;/accesses/{accessId}&#x60;
                .replace(&#x60;{${&quot;accessId&quot;}}&#x60;, encodeURIComponent(String(accessId)));
            const localVarUrlObj &#x3D; url.parse(localVarPath, true);
            const localVarRequestOptions &#x3D; Object.assign({ method: &#x27;DELETE&#x27; }, options);
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration &amp;&amp; configuration.accessToken) {
				const localVarAccessTokenValue &#x3D; typeof configuration.accessToken &#x3D;&#x3D;&#x3D; &#x27;function&#x27;
					? configuration.accessToken(&quot;oauth2&quot;, [])
					: configuration.accessToken;
                localVarHeaderParameter[&quot;Authorization&quot;] &#x3D; &quot;Bearer &quot; + localVarAccessTokenValue;
            }

            localVarUrlObj.query &#x3D; Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers &#x3D; Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the access with **accessId**. The retrieved object does not contain sensitive information such as the PIN.
         * @summary Get access
         * @param {string} accessId The **id** for the access to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccess(accessId: string, options: any &#x3D; {}): FetchArgs {
            // verify required parameter &#x27;accessId&#x27; is not null or undefined
            if (accessId &#x3D;&#x3D;&#x3D; null || accessId &#x3D;&#x3D;&#x3D; undefined) {
                throw new RequiredError(&#x27;accessId&#x27;,&#x27;Required parameter accessId was null or undefined when calling getAccess.&#x27;);
            }
            const localVarPath &#x3D; &#x60;/accesses/{accessId}&#x60;
                .replace(&#x60;{${&quot;accessId&quot;}}&#x60;, encodeURIComponent(String(accessId)));
            const localVarUrlObj &#x3D; url.parse(localVarPath, true);
            const localVarRequestOptions &#x3D; Object.assign({ method: &#x27;GET&#x27; }, options);
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration &amp;&amp; configuration.accessToken) {
				const localVarAccessTokenValue &#x3D; typeof configuration.accessToken &#x3D;&#x3D;&#x3D; &#x27;function&#x27;
					? configuration.accessToken(&quot;oauth2&quot;, [])
					: configuration.accessToken;
                localVarHeaderParameter[&quot;Authorization&quot;] &#x3D; &quot;Bearer &quot; + localVarAccessTokenValue;
            }

            localVarUrlObj.query &#x3D; Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers &#x3D; Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all registered accesses for the authenticated user. Confidential information like the PIN will not be returned.
         * @summary List accesses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccesses(options: any &#x3D; {}): FetchArgs {
            const localVarPath &#x3D; &#x60;/accesses&#x60;;
            const localVarUrlObj &#x3D; url.parse(localVarPath, true);
            const localVarRequestOptions &#x3D; Object.assign({ method: &#x27;GET&#x27; }, options);
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration &amp;&amp; configuration.accessToken) {
				const localVarAccessTokenValue &#x3D; typeof configuration.accessToken &#x3D;&#x3D;&#x3D; &#x27;function&#x27;
					? configuration.accessToken(&quot;oauth2&quot;, [])
					: configuration.accessToken;
                localVarHeaderParameter[&quot;Authorization&quot;] &#x3D; &quot;Bearer &quot; + localVarAccessTokenValue;
            }

            localVarUrlObj.query &#x3D; Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers &#x3D; Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new access and setup all associated accounts and transactions. This will also trigger the creation of monthly transaction summaries, the analysis of all accounts for recurring transactions, and the calculation of the balance forecast.   If the credentials were invalid, the validation state is set accordingly.    It is possible to have multiple accesses for one user.
         * @summary Create a new access
         * @param {Access} accessDto A valid BankAccess object containing the required             **accessFields** as indicated by the provider object and the             **providerId**.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAccess(accessDto: Access, options: any &#x3D; {}): FetchArgs {
            // verify required parameter &#x27;accessDto&#x27; is not null or undefined
            if (accessDto &#x3D;&#x3D;&#x3D; null || accessDto &#x3D;&#x3D;&#x3D; undefined) {
                throw new RequiredError(&#x27;accessDto&#x27;,&#x27;Required parameter accessDto was null or undefined when calling postAccess.&#x27;);
            }
            const localVarPath &#x3D; &#x60;/accesses&#x60;;
            const localVarUrlObj &#x3D; url.parse(localVarPath, true);
            const localVarRequestOptions &#x3D; Object.assign({ method: &#x27;POST&#x27; }, options);
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration &amp;&amp; configuration.accessToken) {
				const localVarAccessTokenValue &#x3D; typeof configuration.accessToken &#x3D;&#x3D;&#x3D; &#x27;function&#x27;
					? configuration.accessToken(&quot;oauth2&quot;, [])
					: configuration.accessToken;
                localVarHeaderParameter[&quot;Authorization&quot;] &#x3D; &quot;Bearer &quot; + localVarAccessTokenValue;
            }

            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            localVarUrlObj.query &#x3D; Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers &#x3D; Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization &#x3D; (&lt;any&gt;&quot;Access&quot; !&#x3D;&#x3D; &quot;string&quot;) || localVarRequestOptions.headers[&#x27;Content-Type&#x27;] &#x3D;&#x3D;&#x3D; &#x27;application/json&#x27;;
            localVarRequestOptions.body &#x3D;  needsSerialization ? JSON.stringify(accessDto || {}) : (accessDto || &quot;&quot;);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the access credentials in **accessFields**. If the access does not exist, the **accessId** does not match the **id** in **accessDto** or the **providerId** is not the same, the status code 404 is returned. If another access with the same login  data already exists, the status code 409 is returned.  The updated access is validated by setting up an account. The status code 200 does not imply that the credentials are correct. To check this the client should obtain access.
         * @summary Update access
         * @param {string} accessId The **id** for the access to update.
         * @param {Access} accessDto The Access object that contains the changed credentials in             **accessFields**. Other fields cannot be edited.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putAccess(accessId: string, accessDto: Access, options: any &#x3D; {}): FetchArgs {
            // verify required parameter &#x27;accessId&#x27; is not null or undefined
            if (accessId &#x3D;&#x3D;&#x3D; null || accessId &#x3D;&#x3D;&#x3D; undefined) {
                throw new RequiredError(&#x27;accessId&#x27;,&#x27;Required parameter accessId was null or undefined when calling putAccess.&#x27;);
            }
            // verify required parameter &#x27;accessDto&#x27; is not null or undefined
            if (accessDto &#x3D;&#x3D;&#x3D; null || accessDto &#x3D;&#x3D;&#x3D; undefined) {
                throw new RequiredError(&#x27;accessDto&#x27;,&#x27;Required parameter accessDto was null or undefined when calling putAccess.&#x27;);
            }
            const localVarPath &#x3D; &#x60;/accesses/{accessId}&#x60;
                .replace(&#x60;{${&quot;accessId&quot;}}&#x60;, encodeURIComponent(String(accessId)));
            const localVarUrlObj &#x3D; url.parse(localVarPath, true);
            const localVarRequestOptions &#x3D; Object.assign({ method: &#x27;PUT&#x27; }, options);
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration &amp;&amp; configuration.accessToken) {
				const localVarAccessTokenValue &#x3D; typeof configuration.accessToken &#x3D;&#x3D;&#x3D; &#x27;function&#x27;
					? configuration.accessToken(&quot;oauth2&quot;, [])
					: configuration.accessToken;
                localVarHeaderParameter[&quot;Authorization&quot;] &#x3D; &quot;Bearer &quot; + localVarAccessTokenValue;
            }

            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            localVarUrlObj.query &#x3D; Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers &#x3D; Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization &#x3D; (&lt;any&gt;&quot;Access&quot; !&#x3D;&#x3D; &quot;string&quot;) || localVarRequestOptions.headers[&#x27;Content-Type&#x27;] &#x3D;&#x3D;&#x3D; &#x27;application/json&#x27;;
            localVarRequestOptions.body &#x3D;  needsSerialization ? JSON.stringify(accessDto || {}) : (accessDto || &quot;&quot;);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
}</code>
                        </td>
                    </tr>

                <tr>
                    <td class="col-md-4">
                        <div class="io-description"><p>AccessApi - fetch parameter creator</p>
</div>
                    </td>
                </tr>

            </tbody>
        </table>
        <table class="table table-sm table-bordered">
            <tbody>
                <tr>
                    <td class="col-md-4">
                        <a name="AccessApiFp"></a>
                        <span class="name">
                            <b>
                            AccessApiFp
                            </b>
                            <a href="#AccessApiFp"><span class="icon ion-ios-link"></span></a>
                        </span>
                    </td>
                </tr>
                <tr>
                    <td class="col-md-4">
                        <code>AccessApiFp:     <code></code>
</code>
                    </td>
                </tr>
                    <tr>
                        <td class="col-md-4">
                            <i>Default value : </i><code>function(configuration?: Configuration) {
    return {
        /**
         * Delete access with **accessId** and all related accounts.
         * @summary Delete access
         * @param {string} accessId The **id** for the access to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccess(accessId: string, options?: any): (fetch?: FetchAPI, basePath?: string) &#x3D;&gt; Promise&lt;Response&gt; {
            const localVarFetchArgs &#x3D; AccessApiFetchParamCreator(configuration).deleteAccess(accessId, options);
            return (fetch: FetchAPI &#x3D; portableFetch, basePath: string &#x3D; BASE_PATH) &#x3D;&gt; {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) &#x3D;&gt; {
                    if (response.status &gt;&#x3D; 200 &amp;&amp; response.status &lt; 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve the access with **accessId**. The retrieved object does not contain sensitive information such as the PIN.
         * @summary Get access
         * @param {string} accessId The **id** for the access to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccess(accessId: string, options?: any): (fetch?: FetchAPI, basePath?: string) &#x3D;&gt; Promise&lt;Access&gt; {
            const localVarFetchArgs &#x3D; AccessApiFetchParamCreator(configuration).getAccess(accessId, options);
            return (fetch: FetchAPI &#x3D; portableFetch, basePath: string &#x3D; BASE_PATH) &#x3D;&gt; {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) &#x3D;&gt; {
                    if (response.status &gt;&#x3D; 200 &amp;&amp; response.status &lt; 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns all registered accesses for the authenticated user. Confidential information like the PIN will not be returned.
         * @summary List accesses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccesses(options?: any): (fetch?: FetchAPI, basePath?: string) &#x3D;&gt; Promise&lt;Array&lt;Access&gt;&gt; {
            const localVarFetchArgs &#x3D; AccessApiFetchParamCreator(configuration).getAccesses(options);
            return (fetch: FetchAPI &#x3D; portableFetch, basePath: string &#x3D; BASE_PATH) &#x3D;&gt; {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) &#x3D;&gt; {
                    if (response.status &gt;&#x3D; 200 &amp;&amp; response.status &lt; 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create a new access and setup all associated accounts and transactions. This will also trigger the creation of monthly transaction summaries, the analysis of all accounts for recurring transactions, and the calculation of the balance forecast.   If the credentials were invalid, the validation state is set accordingly.    It is possible to have multiple accesses for one user.
         * @summary Create a new access
         * @param {Access} accessDto A valid BankAccess object containing the required             **accessFields** as indicated by the provider object and the             **providerId**.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAccess(accessDto: Access, options?: any): (fetch?: FetchAPI, basePath?: string) &#x3D;&gt; Promise&lt;Access&gt; {
            const localVarFetchArgs &#x3D; AccessApiFetchParamCreator(configuration).postAccess(accessDto, options);
            return (fetch: FetchAPI &#x3D; portableFetch, basePath: string &#x3D; BASE_PATH) &#x3D;&gt; {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) &#x3D;&gt; {
                    if (response.status &gt;&#x3D; 200 &amp;&amp; response.status &lt; 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update the access credentials in **accessFields**. If the access does not exist, the **accessId** does not match the **id** in **accessDto** or the **providerId** is not the same, the status code 404 is returned. If another access with the same login  data already exists, the status code 409 is returned.  The updated access is validated by setting up an account. The status code 200 does not imply that the credentials are correct. To check this the client should obtain access.
         * @summary Update access
         * @param {string} accessId The **id** for the access to update.
         * @param {Access} accessDto The Access object that contains the changed credentials in             **accessFields**. Other fields cannot be edited.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putAccess(accessId: string, accessDto: Access, options?: any): (fetch?: FetchAPI, basePath?: string) &#x3D;&gt; Promise&lt;Access&gt; {
            const localVarFetchArgs &#x3D; AccessApiFetchParamCreator(configuration).putAccess(accessId, accessDto, options);
            return (fetch: FetchAPI &#x3D; portableFetch, basePath: string &#x3D; BASE_PATH) &#x3D;&gt; {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) &#x3D;&gt; {
                    if (response.status &gt;&#x3D; 200 &amp;&amp; response.status &lt; 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
}</code>
                        </td>
                    </tr>

                <tr>
                    <td class="col-md-4">
                        <div class="io-description"><p>AccessApi - functional programming interface</p>
</div>
                    </td>
                </tr>

            </tbody>
        </table>
        <table class="table table-sm table-bordered">
            <tbody>
                <tr>
                    <td class="col-md-4">
                        <a name="AccountApiFactory"></a>
                        <span class="name">
                            <b>
                            AccountApiFactory
                            </b>
                            <a href="#AccountApiFactory"><span class="icon ion-ios-link"></span></a>
                        </span>
                    </td>
                </tr>
                <tr>
                    <td class="col-md-4">
                        <code>AccountApiFactory:     <code></code>
</code>
                    </td>
                </tr>
                    <tr>
                        <td class="col-md-4">
                            <i>Default value : </i><code>function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Delete the account identified by **accountId**. 
         * @summary Delete account
         * @param {string} accessId The **accessId** for the account to delete
         * @param {string} accountId The **id** for the account to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccount(accessId: string, accountId: string, options?: any) {
            return AccountApiFp(configuration).deleteAccount(accessId, accountId, options)(fetch, basePath);
        },
        /**
         * Returns the account identified by **accountId**.
         * @summary Get account
         * @param {string} accessId The **accessId** for the account to retrieve
         * @param {string} accountId The **id** for the account to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccount(accessId: string, accountId: string, options?: any) {
            return AccountApiFp(configuration).getAccount(accessId, accountId, options)(fetch, basePath);
        },
        /**
         * Retrieve all accounts for the current user under the **accessId**.
         * @summary List accounts
         * @param {string} accessId The **id** for the access for which to retrieve all accounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccounts(accessId: string, options?: any) {
            return AccountApiFp(configuration).getAccounts(accessId, options)(fetch, basePath);
        },
        /**
         * Update the account name used in AHOI. Name must be URL encoded.
         * @summary Update account name
         * @param {string} accessId The **accessId** for which the user-defined account name should be altered
         * @param {string} accountId The **id** for which the user-defined account name should be altered
         * @param {string} name The new URL-encoded name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccount(accessId: string, accountId: string, name: string, options?: any) {
            return AccountApiFp(configuration).updateAccount(accessId, accountId, name, options)(fetch, basePath);
        },
    };
}</code>
                        </td>
                    </tr>

                <tr>
                    <td class="col-md-4">
                        <div class="io-description"><p>AccountApi - factory interface</p>
</div>
                    </td>
                </tr>

            </tbody>
        </table>
        <table class="table table-sm table-bordered">
            <tbody>
                <tr>
                    <td class="col-md-4">
                        <a name="AccountApiFetchParamCreator"></a>
                        <span class="name">
                            <b>
                            AccountApiFetchParamCreator
                            </b>
                            <a href="#AccountApiFetchParamCreator"><span class="icon ion-ios-link"></span></a>
                        </span>
                    </td>
                </tr>
                <tr>
                    <td class="col-md-4">
                        <code>AccountApiFetchParamCreator:     <code></code>
</code>
                    </td>
                </tr>
                    <tr>
                        <td class="col-md-4">
                            <i>Default value : </i><code>function (configuration?: Configuration) {
    return {
        /**
         * Delete the account identified by **accountId**. 
         * @summary Delete account
         * @param {string} accessId The **accessId** for the account to delete
         * @param {string} accountId The **id** for the account to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccount(accessId: string, accountId: string, options: any &#x3D; {}): FetchArgs {
            // verify required parameter &#x27;accessId&#x27; is not null or undefined
            if (accessId &#x3D;&#x3D;&#x3D; null || accessId &#x3D;&#x3D;&#x3D; undefined) {
                throw new RequiredError(&#x27;accessId&#x27;,&#x27;Required parameter accessId was null or undefined when calling deleteAccount.&#x27;);
            }
            // verify required parameter &#x27;accountId&#x27; is not null or undefined
            if (accountId &#x3D;&#x3D;&#x3D; null || accountId &#x3D;&#x3D;&#x3D; undefined) {
                throw new RequiredError(&#x27;accountId&#x27;,&#x27;Required parameter accountId was null or undefined when calling deleteAccount.&#x27;);
            }
            const localVarPath &#x3D; &#x60;/accesses/{accessId}/accounts/{accountId}&#x60;
                .replace(&#x60;{${&quot;accessId&quot;}}&#x60;, encodeURIComponent(String(accessId)))
                .replace(&#x60;{${&quot;accountId&quot;}}&#x60;, encodeURIComponent(String(accountId)));
            const localVarUrlObj &#x3D; url.parse(localVarPath, true);
            const localVarRequestOptions &#x3D; Object.assign({ method: &#x27;DELETE&#x27; }, options);
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration &amp;&amp; configuration.accessToken) {
				const localVarAccessTokenValue &#x3D; typeof configuration.accessToken &#x3D;&#x3D;&#x3D; &#x27;function&#x27;
					? configuration.accessToken(&quot;oauth2&quot;, [])
					: configuration.accessToken;
                localVarHeaderParameter[&quot;Authorization&quot;] &#x3D; &quot;Bearer &quot; + localVarAccessTokenValue;
            }

            localVarUrlObj.query &#x3D; Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers &#x3D; Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the account identified by **accountId**.
         * @summary Get account
         * @param {string} accessId The **accessId** for the account to retrieve
         * @param {string} accountId The **id** for the account to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccount(accessId: string, accountId: string, options: any &#x3D; {}): FetchArgs {
            // verify required parameter &#x27;accessId&#x27; is not null or undefined
            if (accessId &#x3D;&#x3D;&#x3D; null || accessId &#x3D;&#x3D;&#x3D; undefined) {
                throw new RequiredError(&#x27;accessId&#x27;,&#x27;Required parameter accessId was null or undefined when calling getAccount.&#x27;);
            }
            // verify required parameter &#x27;accountId&#x27; is not null or undefined
            if (accountId &#x3D;&#x3D;&#x3D; null || accountId &#x3D;&#x3D;&#x3D; undefined) {
                throw new RequiredError(&#x27;accountId&#x27;,&#x27;Required parameter accountId was null or undefined when calling getAccount.&#x27;);
            }
            const localVarPath &#x3D; &#x60;/accesses/{accessId}/accounts/{accountId}&#x60;
                .replace(&#x60;{${&quot;accessId&quot;}}&#x60;, encodeURIComponent(String(accessId)))
                .replace(&#x60;{${&quot;accountId&quot;}}&#x60;, encodeURIComponent(String(accountId)));
            const localVarUrlObj &#x3D; url.parse(localVarPath, true);
            const localVarRequestOptions &#x3D; Object.assign({ method: &#x27;GET&#x27; }, options);
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration &amp;&amp; configuration.accessToken) {
				const localVarAccessTokenValue &#x3D; typeof configuration.accessToken &#x3D;&#x3D;&#x3D; &#x27;function&#x27;
					? configuration.accessToken(&quot;oauth2&quot;, [])
					: configuration.accessToken;
                localVarHeaderParameter[&quot;Authorization&quot;] &#x3D; &quot;Bearer &quot; + localVarAccessTokenValue;
            }

            localVarUrlObj.query &#x3D; Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers &#x3D; Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all accounts for the current user under the **accessId**.
         * @summary List accounts
         * @param {string} accessId The **id** for the access for which to retrieve all accounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccounts(accessId: string, options: any &#x3D; {}): FetchArgs {
            // verify required parameter &#x27;accessId&#x27; is not null or undefined
            if (accessId &#x3D;&#x3D;&#x3D; null || accessId &#x3D;&#x3D;&#x3D; undefined) {
                throw new RequiredError(&#x27;accessId&#x27;,&#x27;Required parameter accessId was null or undefined when calling getAccounts.&#x27;);
            }
            const localVarPath &#x3D; &#x60;/accesses/{accessId}/accounts&#x60;
                .replace(&#x60;{${&quot;accessId&quot;}}&#x60;, encodeURIComponent(String(accessId)));
            const localVarUrlObj &#x3D; url.parse(localVarPath, true);
            const localVarRequestOptions &#x3D; Object.assign({ method: &#x27;GET&#x27; }, options);
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration &amp;&amp; configuration.accessToken) {
				const localVarAccessTokenValue &#x3D; typeof configuration.accessToken &#x3D;&#x3D;&#x3D; &#x27;function&#x27;
					? configuration.accessToken(&quot;oauth2&quot;, [])
					: configuration.accessToken;
                localVarHeaderParameter[&quot;Authorization&quot;] &#x3D; &quot;Bearer &quot; + localVarAccessTokenValue;
            }

            localVarUrlObj.query &#x3D; Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers &#x3D; Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the account name used in AHOI. Name must be URL encoded.
         * @summary Update account name
         * @param {string} accessId The **accessId** for which the user-defined account name should be altered
         * @param {string} accountId The **id** for which the user-defined account name should be altered
         * @param {string} name The new URL-encoded name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccount(accessId: string, accountId: string, name: string, options: any &#x3D; {}): FetchArgs {
            // verify required parameter &#x27;accessId&#x27; is not null or undefined
            if (accessId &#x3D;&#x3D;&#x3D; null || accessId &#x3D;&#x3D;&#x3D; undefined) {
                throw new RequiredError(&#x27;accessId&#x27;,&#x27;Required parameter accessId was null or undefined when calling updateAccount.&#x27;);
            }
            // verify required parameter &#x27;accountId&#x27; is not null or undefined
            if (accountId &#x3D;&#x3D;&#x3D; null || accountId &#x3D;&#x3D;&#x3D; undefined) {
                throw new RequiredError(&#x27;accountId&#x27;,&#x27;Required parameter accountId was null or undefined when calling updateAccount.&#x27;);
            }
            // verify required parameter &#x27;name&#x27; is not null or undefined
            if (name &#x3D;&#x3D;&#x3D; null || name &#x3D;&#x3D;&#x3D; undefined) {
                throw new RequiredError(&#x27;name&#x27;,&#x27;Required parameter name was null or undefined when calling updateAccount.&#x27;);
            }
            const localVarPath &#x3D; &#x60;/accesses/{accessId}/accounts/{accountId}/userdefinedname/{name}&#x60;
                .replace(&#x60;{${&quot;accessId&quot;}}&#x60;, encodeURIComponent(String(accessId)))
                .replace(&#x60;{${&quot;accountId&quot;}}&#x60;, encodeURIComponent(String(accountId)))
                .replace(&#x60;{${&quot;name&quot;}}&#x60;, encodeURIComponent(String(name)));
            const localVarUrlObj &#x3D; url.parse(localVarPath, true);
            const localVarRequestOptions &#x3D; Object.assign({ method: &#x27;PUT&#x27; }, options);
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration &amp;&amp; configuration.accessToken) {
				const localVarAccessTokenValue &#x3D; typeof configuration.accessToken &#x3D;&#x3D;&#x3D; &#x27;function&#x27;
					? configuration.accessToken(&quot;oauth2&quot;, [])
					: configuration.accessToken;
                localVarHeaderParameter[&quot;Authorization&quot;] &#x3D; &quot;Bearer &quot; + localVarAccessTokenValue;
            }

            localVarUrlObj.query &#x3D; Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers &#x3D; Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
}</code>
                        </td>
                    </tr>

                <tr>
                    <td class="col-md-4">
                        <div class="io-description"><p>AccountApi - fetch parameter creator</p>
</div>
                    </td>
                </tr>

            </tbody>
        </table>
        <table class="table table-sm table-bordered">
            <tbody>
                <tr>
                    <td class="col-md-4">
                        <a name="AccountApiFp"></a>
                        <span class="name">
                            <b>
                            AccountApiFp
                            </b>
                            <a href="#AccountApiFp"><span class="icon ion-ios-link"></span></a>
                        </span>
                    </td>
                </tr>
                <tr>
                    <td class="col-md-4">
                        <code>AccountApiFp:     <code></code>
</code>
                    </td>
                </tr>
                    <tr>
                        <td class="col-md-4">
                            <i>Default value : </i><code>function(configuration?: Configuration) {
    return {
        /**
         * Delete the account identified by **accountId**. 
         * @summary Delete account
         * @param {string} accessId The **accessId** for the account to delete
         * @param {string} accountId The **id** for the account to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccount(accessId: string, accountId: string, options?: any): (fetch?: FetchAPI, basePath?: string) &#x3D;&gt; Promise&lt;Response&gt; {
            const localVarFetchArgs &#x3D; AccountApiFetchParamCreator(configuration).deleteAccount(accessId, accountId, options);
            return (fetch: FetchAPI &#x3D; portableFetch, basePath: string &#x3D; BASE_PATH) &#x3D;&gt; {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) &#x3D;&gt; {
                    if (response.status &gt;&#x3D; 200 &amp;&amp; response.status &lt; 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns the account identified by **accountId**.
         * @summary Get account
         * @param {string} accessId The **accessId** for the account to retrieve
         * @param {string} accountId The **id** for the account to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccount(accessId: string, accountId: string, options?: any): (fetch?: FetchAPI, basePath?: string) &#x3D;&gt; Promise&lt;Account&gt; {
            const localVarFetchArgs &#x3D; AccountApiFetchParamCreator(configuration).getAccount(accessId, accountId, options);
            return (fetch: FetchAPI &#x3D; portableFetch, basePath: string &#x3D; BASE_PATH) &#x3D;&gt; {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) &#x3D;&gt; {
                    if (response.status &gt;&#x3D; 200 &amp;&amp; response.status &lt; 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve all accounts for the current user under the **accessId**.
         * @summary List accounts
         * @param {string} accessId The **id** for the access for which to retrieve all accounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccounts(accessId: string, options?: any): (fetch?: FetchAPI, basePath?: string) &#x3D;&gt; Promise&lt;Array&lt;Account&gt;&gt; {
            const localVarFetchArgs &#x3D; AccountApiFetchParamCreator(configuration).getAccounts(accessId, options);
            return (fetch: FetchAPI &#x3D; portableFetch, basePath: string &#x3D; BASE_PATH) &#x3D;&gt; {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) &#x3D;&gt; {
                    if (response.status &gt;&#x3D; 200 &amp;&amp; response.status &lt; 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update the account name used in AHOI. Name must be URL encoded.
         * @summary Update account name
         * @param {string} accessId The **accessId** for which the user-defined account name should be altered
         * @param {string} accountId The **id** for which the user-defined account name should be altered
         * @param {string} name The new URL-encoded name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccount(accessId: string, accountId: string, name: string, options?: any): (fetch?: FetchAPI, basePath?: string) &#x3D;&gt; Promise&lt;Account&gt; {
            const localVarFetchArgs &#x3D; AccountApiFetchParamCreator(configuration).updateAccount(accessId, accountId, name, options);
            return (fetch: FetchAPI &#x3D; portableFetch, basePath: string &#x3D; BASE_PATH) &#x3D;&gt; {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) &#x3D;&gt; {
                    if (response.status &gt;&#x3D; 200 &amp;&amp; response.status &lt; 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
}</code>
                        </td>
                    </tr>

                <tr>
                    <td class="col-md-4">
                        <div class="io-description"><p>AccountApi - functional programming interface</p>
</div>
                    </td>
                </tr>

            </tbody>
        </table>
        <table class="table table-sm table-bordered">
            <tbody>
                <tr>
                    <td class="col-md-4">
                        <a name="BASE_PATH"></a>
                        <span class="name">
                            <b>
                            BASE_PATH
                            </b>
                            <a href="#BASE_PATH"><span class="icon ion-ios-link"></span></a>
                        </span>
                    </td>
                </tr>
                <tr>
                    <td class="col-md-4">
                        <code>BASE_PATH:     <code></code>
</code>
                    </td>
                </tr>
                    <tr>
                        <td class="col-md-4">
                            <i>Default value : </i><code>&quot;https://localhost/ahoi/api/v2&quot;.replace(/\/+$/, &quot;&quot;)</code>
                        </td>
                    </tr>


            </tbody>
        </table>
        <table class="table table-sm table-bordered">
            <tbody>
                <tr>
                    <td class="col-md-4">
                        <a name="CategoryApiFactory"></a>
                        <span class="name">
                            <b>
                            CategoryApiFactory
                            </b>
                            <a href="#CategoryApiFactory"><span class="icon ion-ios-link"></span></a>
                        </span>
                    </td>
                </tr>
                <tr>
                    <td class="col-md-4">
                        <code>CategoryApiFactory:     <code></code>
</code>
                    </td>
                </tr>
                    <tr>
                        <td class="col-md-4">
                            <i>Default value : </i><code>function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Supported origins are: FINLYTICS
         * @summary Retrieve all categories for given origin.
         * @param {string} origin identifier of a supported origin
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategories(origin: string, options?: any) {
            return CategoryApiFp(configuration).getCategories(origin, options)(fetch, basePath);
        },
    };
}</code>
                        </td>
                    </tr>

                <tr>
                    <td class="col-md-4">
                        <div class="io-description"><p>CategoryApi - factory interface</p>
</div>
                    </td>
                </tr>

            </tbody>
        </table>
        <table class="table table-sm table-bordered">
            <tbody>
                <tr>
                    <td class="col-md-4">
                        <a name="CategoryApiFetchParamCreator"></a>
                        <span class="name">
                            <b>
                            CategoryApiFetchParamCreator
                            </b>
                            <a href="#CategoryApiFetchParamCreator"><span class="icon ion-ios-link"></span></a>
                        </span>
                    </td>
                </tr>
                <tr>
                    <td class="col-md-4">
                        <code>CategoryApiFetchParamCreator:     <code></code>
</code>
                    </td>
                </tr>
                    <tr>
                        <td class="col-md-4">
                            <i>Default value : </i><code>function (configuration?: Configuration) {
    return {
        /**
         * Supported origins are: FINLYTICS
         * @summary Retrieve all categories for given origin.
         * @param {string} origin identifier of a supported origin
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategories(origin: string, options: any &#x3D; {}): FetchArgs {
            // verify required parameter &#x27;origin&#x27; is not null or undefined
            if (origin &#x3D;&#x3D;&#x3D; null || origin &#x3D;&#x3D;&#x3D; undefined) {
                throw new RequiredError(&#x27;origin&#x27;,&#x27;Required parameter origin was null or undefined when calling getCategories.&#x27;);
            }
            const localVarPath &#x3D; &#x60;/categories&#x60;;
            const localVarUrlObj &#x3D; url.parse(localVarPath, true);
            const localVarRequestOptions &#x3D; Object.assign({ method: &#x27;GET&#x27; }, options);
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration &amp;&amp; configuration.accessToken) {
				const localVarAccessTokenValue &#x3D; typeof configuration.accessToken &#x3D;&#x3D;&#x3D; &#x27;function&#x27;
					? configuration.accessToken(&quot;oauth2&quot;, [])
					: configuration.accessToken;
                localVarHeaderParameter[&quot;Authorization&quot;] &#x3D; &quot;Bearer &quot; + localVarAccessTokenValue;
            }

            if (origin !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;origin&#x27;] &#x3D; origin;
            }

            localVarUrlObj.query &#x3D; Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers &#x3D; Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
}</code>
                        </td>
                    </tr>

                <tr>
                    <td class="col-md-4">
                        <div class="io-description"><p>CategoryApi - fetch parameter creator</p>
</div>
                    </td>
                </tr>

            </tbody>
        </table>
        <table class="table table-sm table-bordered">
            <tbody>
                <tr>
                    <td class="col-md-4">
                        <a name="CategoryApiFp"></a>
                        <span class="name">
                            <b>
                            CategoryApiFp
                            </b>
                            <a href="#CategoryApiFp"><span class="icon ion-ios-link"></span></a>
                        </span>
                    </td>
                </tr>
                <tr>
                    <td class="col-md-4">
                        <code>CategoryApiFp:     <code></code>
</code>
                    </td>
                </tr>
                    <tr>
                        <td class="col-md-4">
                            <i>Default value : </i><code>function(configuration?: Configuration) {
    return {
        /**
         * Supported origins are: FINLYTICS
         * @summary Retrieve all categories for given origin.
         * @param {string} origin identifier of a supported origin
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategories(origin: string, options?: any): (fetch?: FetchAPI, basePath?: string) &#x3D;&gt; Promise&lt;Array&lt;Category&gt;&gt; {
            const localVarFetchArgs &#x3D; CategoryApiFetchParamCreator(configuration).getCategories(origin, options);
            return (fetch: FetchAPI &#x3D; portableFetch, basePath: string &#x3D; BASE_PATH) &#x3D;&gt; {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) &#x3D;&gt; {
                    if (response.status &gt;&#x3D; 200 &amp;&amp; response.status &lt; 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
}</code>
                        </td>
                    </tr>

                <tr>
                    <td class="col-md-4">
                        <div class="io-description"><p>CategoryApi - functional programming interface</p>
</div>
                    </td>
                </tr>

            </tbody>
        </table>
        <table class="table table-sm table-bordered">
            <tbody>
                <tr>
                    <td class="col-md-4">
                        <a name="COLLECTION_FORMATS"></a>
                        <span class="name">
                            <b>
                            COLLECTION_FORMATS
                            </b>
                            <a href="#COLLECTION_FORMATS"><span class="icon ion-ios-link"></span></a>
                        </span>
                    </td>
                </tr>
                <tr>
                    <td class="col-md-4">
                        <code>COLLECTION_FORMATS:     <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/object" target="_blank" >object</a></code>
</code>
                    </td>
                </tr>
                    <tr>
                        <td class="col-md-4">
                            <i>Type : </i>    <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/object" target="_blank" >object</a></code>

                        </td>
                    </tr>
                    <tr>
                        <td class="col-md-4">
                            <i>Default value : </i><code>{
    csv: &quot;,&quot;,
    ssv: &quot; &quot;,
    tsv: &quot;\t&quot;,
    pipes: &quot;|&quot;,
}</code>
                        </td>
                    </tr>


            </tbody>
        </table>
        <table class="table table-sm table-bordered">
            <tbody>
                <tr>
                    <td class="col-md-4">
                        <a name="ContractApiFactory"></a>
                        <span class="name">
                            <b>
                            ContractApiFactory
                            </b>
                            <a href="#ContractApiFactory"><span class="icon ion-ios-link"></span></a>
                        </span>
                    </td>
                </tr>
                <tr>
                    <td class="col-md-4">
                        <code>ContractApiFactory:     <code></code>
</code>
                    </td>
                </tr>
                    <tr>
                        <td class="col-md-4">
                            <i>Default value : </i><code>function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Fetches contract list of current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContractList(options?: any) {
            return ContractApiFp(configuration).getContractList(options)(fetch, basePath);
        },
    };
}</code>
                        </td>
                    </tr>

                <tr>
                    <td class="col-md-4">
                        <div class="io-description"><p>ContractApi - factory interface</p>
</div>
                    </td>
                </tr>

            </tbody>
        </table>
        <table class="table table-sm table-bordered">
            <tbody>
                <tr>
                    <td class="col-md-4">
                        <a name="ContractApiFetchParamCreator"></a>
                        <span class="name">
                            <b>
                            ContractApiFetchParamCreator
                            </b>
                            <a href="#ContractApiFetchParamCreator"><span class="icon ion-ios-link"></span></a>
                        </span>
                    </td>
                </tr>
                <tr>
                    <td class="col-md-4">
                        <code>ContractApiFetchParamCreator:     <code></code>
</code>
                    </td>
                </tr>
                    <tr>
                        <td class="col-md-4">
                            <i>Default value : </i><code>function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Fetches contract list of current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContractList(options: any &#x3D; {}): FetchArgs {
            const localVarPath &#x3D; &#x60;/contracts&#x60;;
            const localVarUrlObj &#x3D; url.parse(localVarPath, true);
            const localVarRequestOptions &#x3D; Object.assign({ method: &#x27;GET&#x27; }, options);
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration &amp;&amp; configuration.accessToken) {
				const localVarAccessTokenValue &#x3D; typeof configuration.accessToken &#x3D;&#x3D;&#x3D; &#x27;function&#x27;
					? configuration.accessToken(&quot;oauth2&quot;, [])
					: configuration.accessToken;
                localVarHeaderParameter[&quot;Authorization&quot;] &#x3D; &quot;Bearer &quot; + localVarAccessTokenValue;
            }

            localVarUrlObj.query &#x3D; Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers &#x3D; Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
}</code>
                        </td>
                    </tr>

                <tr>
                    <td class="col-md-4">
                        <div class="io-description"><p>ContractApi - fetch parameter creator</p>
</div>
                    </td>
                </tr>

            </tbody>
        </table>
        <table class="table table-sm table-bordered">
            <tbody>
                <tr>
                    <td class="col-md-4">
                        <a name="ContractApiFp"></a>
                        <span class="name">
                            <b>
                            ContractApiFp
                            </b>
                            <a href="#ContractApiFp"><span class="icon ion-ios-link"></span></a>
                        </span>
                    </td>
                </tr>
                <tr>
                    <td class="col-md-4">
                        <code>ContractApiFp:     <code></code>
</code>
                    </td>
                </tr>
                    <tr>
                        <td class="col-md-4">
                            <i>Default value : </i><code>function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Fetches contract list of current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContractList(options?: any): (fetch?: FetchAPI, basePath?: string) &#x3D;&gt; Promise&lt;Array&lt;Contract&gt;&gt; {
            const localVarFetchArgs &#x3D; ContractApiFetchParamCreator(configuration).getContractList(options);
            return (fetch: FetchAPI &#x3D; portableFetch, basePath: string &#x3D; BASE_PATH) &#x3D;&gt; {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) &#x3D;&gt; {
                    if (response.status &gt;&#x3D; 200 &amp;&amp; response.status &lt; 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
}</code>
                        </td>
                    </tr>

                <tr>
                    <td class="col-md-4">
                        <div class="io-description"><p>ContractApi - functional programming interface</p>
</div>
                    </td>
                </tr>

            </tbody>
        </table>
        <table class="table table-sm table-bordered">
            <tbody>
                <tr>
                    <td class="col-md-4">
                        <a name="ForecastApiFactory"></a>
                        <span class="name">
                            <b>
                            ForecastApiFactory
                            </b>
                            <a href="#ForecastApiFactory"><span class="icon ion-ios-link"></span></a>
                        </span>
                    </td>
                </tr>
                <tr>
                    <td class="col-md-4">
                        <code>ForecastApiFactory:     <code></code>
</code>
                    </td>
                </tr>
                    <tr>
                        <td class="col-md-4">
                            <i>Default value : </i><code>function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * The current month is determined by the latest refresh.
         * @summary Get balance forecast
         * @param {string} accessId The **accessId** for which to retrieve forecasts
         * @param {string} accountId The **accountId** for which to retrieve forecasts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForecast(accessId: string, accountId: string, options?: any) {
            return ForecastApiFp(configuration).getForecast(accessId, accountId, options)(fetch, basePath);
        },
        /**
         * The current  month is determined by latest refresh of transactions. The request  also retrieves the transactions expected to be applied until the  end of the current month.
         * @summary Retrieve balance forecast for the end of the current month.
         * @param {string} accessId The **accessId** for the forecast.
         * @param {string} accountId The **id** for the account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForecastTransactions(accessId: string, accountId: string, options?: any) {
            return ForecastApiFp(configuration).getForecastTransactions(accessId, accountId, options)(fetch, basePath);
        },
    };
}</code>
                        </td>
                    </tr>

                <tr>
                    <td class="col-md-4">
                        <div class="io-description"><p>ForecastApi - factory interface</p>
</div>
                    </td>
                </tr>

            </tbody>
        </table>
        <table class="table table-sm table-bordered">
            <tbody>
                <tr>
                    <td class="col-md-4">
                        <a name="ForecastApiFetchParamCreator"></a>
                        <span class="name">
                            <b>
                            ForecastApiFetchParamCreator
                            </b>
                            <a href="#ForecastApiFetchParamCreator"><span class="icon ion-ios-link"></span></a>
                        </span>
                    </td>
                </tr>
                <tr>
                    <td class="col-md-4">
                        <code>ForecastApiFetchParamCreator:     <code></code>
</code>
                    </td>
                </tr>
                    <tr>
                        <td class="col-md-4">
                            <i>Default value : </i><code>function (configuration?: Configuration) {
    return {
        /**
         * The current month is determined by the latest refresh.
         * @summary Get balance forecast
         * @param {string} accessId The **accessId** for which to retrieve forecasts
         * @param {string} accountId The **accountId** for which to retrieve forecasts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForecast(accessId: string, accountId: string, options: any &#x3D; {}): FetchArgs {
            // verify required parameter &#x27;accessId&#x27; is not null or undefined
            if (accessId &#x3D;&#x3D;&#x3D; null || accessId &#x3D;&#x3D;&#x3D; undefined) {
                throw new RequiredError(&#x27;accessId&#x27;,&#x27;Required parameter accessId was null or undefined when calling getForecast.&#x27;);
            }
            // verify required parameter &#x27;accountId&#x27; is not null or undefined
            if (accountId &#x3D;&#x3D;&#x3D; null || accountId &#x3D;&#x3D;&#x3D; undefined) {
                throw new RequiredError(&#x27;accountId&#x27;,&#x27;Required parameter accountId was null or undefined when calling getForecast.&#x27;);
            }
            const localVarPath &#x3D; &#x60;/accesses/{accessId}/accounts/{accountId}/forecast&#x60;
                .replace(&#x60;{${&quot;accessId&quot;}}&#x60;, encodeURIComponent(String(accessId)))
                .replace(&#x60;{${&quot;accountId&quot;}}&#x60;, encodeURIComponent(String(accountId)));
            const localVarUrlObj &#x3D; url.parse(localVarPath, true);
            const localVarRequestOptions &#x3D; Object.assign({ method: &#x27;GET&#x27; }, options);
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration &amp;&amp; configuration.accessToken) {
				const localVarAccessTokenValue &#x3D; typeof configuration.accessToken &#x3D;&#x3D;&#x3D; &#x27;function&#x27;
					? configuration.accessToken(&quot;oauth2&quot;, [])
					: configuration.accessToken;
                localVarHeaderParameter[&quot;Authorization&quot;] &#x3D; &quot;Bearer &quot; + localVarAccessTokenValue;
            }

            localVarUrlObj.query &#x3D; Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers &#x3D; Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The current  month is determined by latest refresh of transactions. The request  also retrieves the transactions expected to be applied until the  end of the current month.
         * @summary Retrieve balance forecast for the end of the current month.
         * @param {string} accessId The **accessId** for the forecast.
         * @param {string} accountId The **id** for the account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForecastTransactions(accessId: string, accountId: string, options: any &#x3D; {}): FetchArgs {
            // verify required parameter &#x27;accessId&#x27; is not null or undefined
            if (accessId &#x3D;&#x3D;&#x3D; null || accessId &#x3D;&#x3D;&#x3D; undefined) {
                throw new RequiredError(&#x27;accessId&#x27;,&#x27;Required parameter accessId was null or undefined when calling getForecastTransactions.&#x27;);
            }
            // verify required parameter &#x27;accountId&#x27; is not null or undefined
            if (accountId &#x3D;&#x3D;&#x3D; null || accountId &#x3D;&#x3D;&#x3D; undefined) {
                throw new RequiredError(&#x27;accountId&#x27;,&#x27;Required parameter accountId was null or undefined when calling getForecastTransactions.&#x27;);
            }
            const localVarPath &#x3D; &#x60;/accesses/{accessId}/accounts/{accountId}/forecast/transactions&#x60;
                .replace(&#x60;{${&quot;accessId&quot;}}&#x60;, encodeURIComponent(String(accessId)))
                .replace(&#x60;{${&quot;accountId&quot;}}&#x60;, encodeURIComponent(String(accountId)));
            const localVarUrlObj &#x3D; url.parse(localVarPath, true);
            const localVarRequestOptions &#x3D; Object.assign({ method: &#x27;GET&#x27; }, options);
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration &amp;&amp; configuration.accessToken) {
				const localVarAccessTokenValue &#x3D; typeof configuration.accessToken &#x3D;&#x3D;&#x3D; &#x27;function&#x27;
					? configuration.accessToken(&quot;oauth2&quot;, [])
					: configuration.accessToken;
                localVarHeaderParameter[&quot;Authorization&quot;] &#x3D; &quot;Bearer &quot; + localVarAccessTokenValue;
            }

            localVarUrlObj.query &#x3D; Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers &#x3D; Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
}</code>
                        </td>
                    </tr>

                <tr>
                    <td class="col-md-4">
                        <div class="io-description"><p>ForecastApi - fetch parameter creator</p>
</div>
                    </td>
                </tr>

            </tbody>
        </table>
        <table class="table table-sm table-bordered">
            <tbody>
                <tr>
                    <td class="col-md-4">
                        <a name="ForecastApiFp"></a>
                        <span class="name">
                            <b>
                            ForecastApiFp
                            </b>
                            <a href="#ForecastApiFp"><span class="icon ion-ios-link"></span></a>
                        </span>
                    </td>
                </tr>
                <tr>
                    <td class="col-md-4">
                        <code>ForecastApiFp:     <code></code>
</code>
                    </td>
                </tr>
                    <tr>
                        <td class="col-md-4">
                            <i>Default value : </i><code>function(configuration?: Configuration) {
    return {
        /**
         * The current month is determined by the latest refresh.
         * @summary Get balance forecast
         * @param {string} accessId The **accessId** for which to retrieve forecasts
         * @param {string} accountId The **accountId** for which to retrieve forecasts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForecast(accessId: string, accountId: string, options?: any): (fetch?: FetchAPI, basePath?: string) &#x3D;&gt; Promise&lt;Forecast&gt; {
            const localVarFetchArgs &#x3D; ForecastApiFetchParamCreator(configuration).getForecast(accessId, accountId, options);
            return (fetch: FetchAPI &#x3D; portableFetch, basePath: string &#x3D; BASE_PATH) &#x3D;&gt; {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) &#x3D;&gt; {
                    if (response.status &gt;&#x3D; 200 &amp;&amp; response.status &lt; 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * The current  month is determined by latest refresh of transactions. The request  also retrieves the transactions expected to be applied until the  end of the current month.
         * @summary Retrieve balance forecast for the end of the current month.
         * @param {string} accessId The **accessId** for the forecast.
         * @param {string} accountId The **id** for the account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForecastTransactions(accessId: string, accountId: string, options?: any): (fetch?: FetchAPI, basePath?: string) &#x3D;&gt; Promise&lt;ForecastTransaction&gt; {
            const localVarFetchArgs &#x3D; ForecastApiFetchParamCreator(configuration).getForecastTransactions(accessId, accountId, options);
            return (fetch: FetchAPI &#x3D; portableFetch, basePath: string &#x3D; BASE_PATH) &#x3D;&gt; {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) &#x3D;&gt; {
                    if (response.status &gt;&#x3D; 200 &amp;&amp; response.status &lt; 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
}</code>
                        </td>
                    </tr>

                <tr>
                    <td class="col-md-4">
                        <div class="io-description"><p>ForecastApi - functional programming interface</p>
</div>
                    </td>
                </tr>

            </tbody>
        </table>
        <table class="table table-sm table-bordered">
            <tbody>
                <tr>
                    <td class="col-md-4">
                        <a name="ProviderApiFactory"></a>
                        <span class="name">
                            <b>
                            ProviderApiFactory
                            </b>
                            <a href="#ProviderApiFactory"><span class="icon ion-ios-link"></span></a>
                        </span>
                    </td>
                </tr>
                <tr>
                    <td class="col-md-4">
                        <code>ProviderApiFactory:     <code></code>
</code>
                    </td>
                </tr>
                    <tr>
                        <td class="col-md-4">
                            <i>Default value : </i><code>function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Retrieve a single provider identified by **providerId**.
         * @summary Get provider
         * @param {string} providerId The **providerId** to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProvider(providerId: string, options?: any) {
            return ProviderApiFp(configuration).getProvider(providerId, options)(fetch, basePath);
        },
        /**
         * Retrieve a list of bank providers. A provider-**id** is necessary to create an _access_. To retrieve the necessary access fields, you need to query the specific &#x60;provider/{providerId}&#x60;. For performance reasons they are kept separate. 
         * @summary List bank providers
         * @param {string} [bankCode] Optional  if length &amp;#x3D; 8, the response will also contain data describing             the fields required for account setup
         * @param {boolean} [supported] Optional  response should only contain providers supported for account             setup via this API
         * @param {string} [query] Optional  search parameters for BankCode, BIC, Location, Name. Will be ignored             if the bankCode query parameter is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProviders(bankCode?: string, supported?: boolean, query?: string, options?: any) {
            return ProviderApiFp(configuration).getProviders(bankCode, supported, query, options)(fetch, basePath);
        },
    };
}</code>
                        </td>
                    </tr>

                <tr>
                    <td class="col-md-4">
                        <div class="io-description"><p>ProviderApi - factory interface</p>
</div>
                    </td>
                </tr>

            </tbody>
        </table>
        <table class="table table-sm table-bordered">
            <tbody>
                <tr>
                    <td class="col-md-4">
                        <a name="ProviderApiFetchParamCreator"></a>
                        <span class="name">
                            <b>
                            ProviderApiFetchParamCreator
                            </b>
                            <a href="#ProviderApiFetchParamCreator"><span class="icon ion-ios-link"></span></a>
                        </span>
                    </td>
                </tr>
                <tr>
                    <td class="col-md-4">
                        <code>ProviderApiFetchParamCreator:     <code></code>
</code>
                    </td>
                </tr>
                    <tr>
                        <td class="col-md-4">
                            <i>Default value : </i><code>function (configuration?: Configuration) {
    return {
        /**
         * Retrieve a single provider identified by **providerId**.
         * @summary Get provider
         * @param {string} providerId The **providerId** to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProvider(providerId: string, options: any &#x3D; {}): FetchArgs {
            // verify required parameter &#x27;providerId&#x27; is not null or undefined
            if (providerId &#x3D;&#x3D;&#x3D; null || providerId &#x3D;&#x3D;&#x3D; undefined) {
                throw new RequiredError(&#x27;providerId&#x27;,&#x27;Required parameter providerId was null or undefined when calling getProvider.&#x27;);
            }
            const localVarPath &#x3D; &#x60;/providers/{providerId}&#x60;
                .replace(&#x60;{${&quot;providerId&quot;}}&#x60;, encodeURIComponent(String(providerId)));
            const localVarUrlObj &#x3D; url.parse(localVarPath, true);
            const localVarRequestOptions &#x3D; Object.assign({ method: &#x27;GET&#x27; }, options);
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration &amp;&amp; configuration.accessToken) {
				const localVarAccessTokenValue &#x3D; typeof configuration.accessToken &#x3D;&#x3D;&#x3D; &#x27;function&#x27;
					? configuration.accessToken(&quot;oauth2&quot;, [])
					: configuration.accessToken;
                localVarHeaderParameter[&quot;Authorization&quot;] &#x3D; &quot;Bearer &quot; + localVarAccessTokenValue;
            }

            localVarUrlObj.query &#x3D; Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers &#x3D; Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of bank providers. A provider-**id** is necessary to create an _access_. To retrieve the necessary access fields, you need to query the specific &#x60;provider/{providerId}&#x60;. For performance reasons they are kept separate. 
         * @summary List bank providers
         * @param {string} [bankCode] Optional  if length &amp;#x3D; 8, the response will also contain data describing             the fields required for account setup
         * @param {boolean} [supported] Optional  response should only contain providers supported for account             setup via this API
         * @param {string} [query] Optional  search parameters for BankCode, BIC, Location, Name. Will be ignored             if the bankCode query parameter is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProviders(bankCode?: string, supported?: boolean, query?: string, options: any &#x3D; {}): FetchArgs {
            const localVarPath &#x3D; &#x60;/providers&#x60;;
            const localVarUrlObj &#x3D; url.parse(localVarPath, true);
            const localVarRequestOptions &#x3D; Object.assign({ method: &#x27;GET&#x27; }, options);
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration &amp;&amp; configuration.accessToken) {
				const localVarAccessTokenValue &#x3D; typeof configuration.accessToken &#x3D;&#x3D;&#x3D; &#x27;function&#x27;
					? configuration.accessToken(&quot;oauth2&quot;, [])
					: configuration.accessToken;
                localVarHeaderParameter[&quot;Authorization&quot;] &#x3D; &quot;Bearer &quot; + localVarAccessTokenValue;
            }

            if (bankCode !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;bankCode&#x27;] &#x3D; bankCode;
            }

            if (supported !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;supported&#x27;] &#x3D; supported;
            }

            if (query !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;query&#x27;] &#x3D; query;
            }

            localVarUrlObj.query &#x3D; Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers &#x3D; Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
}</code>
                        </td>
                    </tr>

                <tr>
                    <td class="col-md-4">
                        <div class="io-description"><p>ProviderApi - fetch parameter creator</p>
</div>
                    </td>
                </tr>

            </tbody>
        </table>
        <table class="table table-sm table-bordered">
            <tbody>
                <tr>
                    <td class="col-md-4">
                        <a name="ProviderApiFp"></a>
                        <span class="name">
                            <b>
                            ProviderApiFp
                            </b>
                            <a href="#ProviderApiFp"><span class="icon ion-ios-link"></span></a>
                        </span>
                    </td>
                </tr>
                <tr>
                    <td class="col-md-4">
                        <code>ProviderApiFp:     <code></code>
</code>
                    </td>
                </tr>
                    <tr>
                        <td class="col-md-4">
                            <i>Default value : </i><code>function(configuration?: Configuration) {
    return {
        /**
         * Retrieve a single provider identified by **providerId**.
         * @summary Get provider
         * @param {string} providerId The **providerId** to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProvider(providerId: string, options?: any): (fetch?: FetchAPI, basePath?: string) &#x3D;&gt; Promise&lt;Provider&gt; {
            const localVarFetchArgs &#x3D; ProviderApiFetchParamCreator(configuration).getProvider(providerId, options);
            return (fetch: FetchAPI &#x3D; portableFetch, basePath: string &#x3D; BASE_PATH) &#x3D;&gt; {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) &#x3D;&gt; {
                    if (response.status &gt;&#x3D; 200 &amp;&amp; response.status &lt; 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve a list of bank providers. A provider-**id** is necessary to create an _access_. To retrieve the necessary access fields, you need to query the specific &#x60;provider/{providerId}&#x60;. For performance reasons they are kept separate. 
         * @summary List bank providers
         * @param {string} [bankCode] Optional  if length &amp;#x3D; 8, the response will also contain data describing             the fields required for account setup
         * @param {boolean} [supported] Optional  response should only contain providers supported for account             setup via this API
         * @param {string} [query] Optional  search parameters for BankCode, BIC, Location, Name. Will be ignored             if the bankCode query parameter is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProviders(bankCode?: string, supported?: boolean, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) &#x3D;&gt; Promise&lt;Array&lt;Provider&gt;&gt; {
            const localVarFetchArgs &#x3D; ProviderApiFetchParamCreator(configuration).getProviders(bankCode, supported, query, options);
            return (fetch: FetchAPI &#x3D; portableFetch, basePath: string &#x3D; BASE_PATH) &#x3D;&gt; {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) &#x3D;&gt; {
                    if (response.status &gt;&#x3D; 200 &amp;&amp; response.status &lt; 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
}</code>
                        </td>
                    </tr>

                <tr>
                    <td class="col-md-4">
                        <div class="io-description"><p>ProviderApi - functional programming interface</p>
</div>
                    </td>
                </tr>

            </tbody>
        </table>
        <table class="table table-sm table-bordered">
            <tbody>
                <tr>
                    <td class="col-md-4">
                        <a name="RegistrationApiFactory"></a>
                        <span class="name">
                            <b>
                            RegistrationApiFactory
                            </b>
                            <a href="#RegistrationApiFactory"><span class="icon ion-ios-link"></span></a>
                        </span>
                    </td>
                </tr>
                <tr>
                    <td class="col-md-4">
                        <code>RegistrationApiFactory:     <code></code>
</code>
                    </td>
                </tr>
                    <tr>
                        <td class="col-md-4">
                            <i>Default value : </i><code>function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Delete the user context for the current token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRegistration(options?: any) {
            return RegistrationApiFp(configuration).deleteRegistration(options)(fetch, basePath);
        },
        /**
         * A valid API public key will be returned in JWK format to be used to encrypt registration data
         * @summary Request API jwk public key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJsonWebKey(options?: any) {
            return RegistrationApiFp(configuration).getJsonWebKey(options)(fetch, basePath);
        },
        /**
         * A valid API public key will be returned to be used to encrypt registration data
         * @summary Request API public key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRegistrationPublicKey(options?: any) {
            return RegistrationApiFp(configuration).getRegistrationPublicKey(options)(fetch, basePath);
        },
        /**
         * Registers a user with AHOI
         * @summary User registration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register(options?: any) {
            return RegistrationApiFp(configuration).register(options)(fetch, basePath);
        },
    };
}</code>
                        </td>
                    </tr>

                <tr>
                    <td class="col-md-4">
                        <div class="io-description"><p>RegistrationApi - factory interface</p>
</div>
                    </td>
                </tr>

            </tbody>
        </table>
        <table class="table table-sm table-bordered">
            <tbody>
                <tr>
                    <td class="col-md-4">
                        <a name="RegistrationApiFetchParamCreator"></a>
                        <span class="name">
                            <b>
                            RegistrationApiFetchParamCreator
                            </b>
                            <a href="#RegistrationApiFetchParamCreator"><span class="icon ion-ios-link"></span></a>
                        </span>
                    </td>
                </tr>
                <tr>
                    <td class="col-md-4">
                        <code>RegistrationApiFetchParamCreator:     <code></code>
</code>
                    </td>
                </tr>
                    <tr>
                        <td class="col-md-4">
                            <i>Default value : </i><code>function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete the user context for the current token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRegistration(options: any &#x3D; {}): FetchArgs {
            const localVarPath &#x3D; &#x60;/registration&#x60;;
            const localVarUrlObj &#x3D; url.parse(localVarPath, true);
            const localVarRequestOptions &#x3D; Object.assign({ method: &#x27;DELETE&#x27; }, options);
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration &amp;&amp; configuration.accessToken) {
				const localVarAccessTokenValue &#x3D; typeof configuration.accessToken &#x3D;&#x3D;&#x3D; &#x27;function&#x27;
					? configuration.accessToken(&quot;oauth2&quot;, [])
					: configuration.accessToken;
                localVarHeaderParameter[&quot;Authorization&quot;] &#x3D; &quot;Bearer &quot; + localVarAccessTokenValue;
            }

            localVarUrlObj.query &#x3D; Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers &#x3D; Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A valid API public key will be returned in JWK format to be used to encrypt registration data
         * @summary Request API jwk public key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJsonWebKey(options: any &#x3D; {}): FetchArgs {
            const localVarPath &#x3D; &#x60;/registration/jwk&#x60;;
            const localVarUrlObj &#x3D; url.parse(localVarPath, true);
            const localVarRequestOptions &#x3D; Object.assign({ method: &#x27;GET&#x27; }, options);
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration &amp;&amp; configuration.accessToken) {
				const localVarAccessTokenValue &#x3D; typeof configuration.accessToken &#x3D;&#x3D;&#x3D; &#x27;function&#x27;
					? configuration.accessToken(&quot;oauth2&quot;, [])
					: configuration.accessToken;
                localVarHeaderParameter[&quot;Authorization&quot;] &#x3D; &quot;Bearer &quot; + localVarAccessTokenValue;
            }

            localVarUrlObj.query &#x3D; Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers &#x3D; Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A valid API public key will be returned to be used to encrypt registration data
         * @summary Request API public key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRegistrationPublicKey(options: any &#x3D; {}): FetchArgs {
            const localVarPath &#x3D; &#x60;/registration/keys&#x60;;
            const localVarUrlObj &#x3D; url.parse(localVarPath, true);
            const localVarRequestOptions &#x3D; Object.assign({ method: &#x27;GET&#x27; }, options);
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration &amp;&amp; configuration.accessToken) {
				const localVarAccessTokenValue &#x3D; typeof configuration.accessToken &#x3D;&#x3D;&#x3D; &#x27;function&#x27;
					? configuration.accessToken(&quot;oauth2&quot;, [])
					: configuration.accessToken;
                localVarHeaderParameter[&quot;Authorization&quot;] &#x3D; &quot;Bearer &quot; + localVarAccessTokenValue;
            }

            localVarUrlObj.query &#x3D; Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers &#x3D; Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Registers a user with AHOI
         * @summary User registration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register(options: any &#x3D; {}): FetchArgs {
            const localVarPath &#x3D; &#x60;/registration&#x60;;
            const localVarUrlObj &#x3D; url.parse(localVarPath, true);
            const localVarRequestOptions &#x3D; Object.assign({ method: &#x27;POST&#x27; }, options);
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration &amp;&amp; configuration.accessToken) {
				const localVarAccessTokenValue &#x3D; typeof configuration.accessToken &#x3D;&#x3D;&#x3D; &#x27;function&#x27;
					? configuration.accessToken(&quot;oauth2&quot;, [])
					: configuration.accessToken;
                localVarHeaderParameter[&quot;Authorization&quot;] &#x3D; &quot;Bearer &quot; + localVarAccessTokenValue;
            }

            localVarUrlObj.query &#x3D; Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers &#x3D; Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
}</code>
                        </td>
                    </tr>

                <tr>
                    <td class="col-md-4">
                        <div class="io-description"><p>RegistrationApi - fetch parameter creator</p>
</div>
                    </td>
                </tr>

            </tbody>
        </table>
        <table class="table table-sm table-bordered">
            <tbody>
                <tr>
                    <td class="col-md-4">
                        <a name="RegistrationApiFp"></a>
                        <span class="name">
                            <b>
                            RegistrationApiFp
                            </b>
                            <a href="#RegistrationApiFp"><span class="icon ion-ios-link"></span></a>
                        </span>
                    </td>
                </tr>
                <tr>
                    <td class="col-md-4">
                        <code>RegistrationApiFp:     <code></code>
</code>
                    </td>
                </tr>
                    <tr>
                        <td class="col-md-4">
                            <i>Default value : </i><code>function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete the user context for the current token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRegistration(options?: any): (fetch?: FetchAPI, basePath?: string) &#x3D;&gt; Promise&lt;Response&gt; {
            const localVarFetchArgs &#x3D; RegistrationApiFetchParamCreator(configuration).deleteRegistration(options);
            return (fetch: FetchAPI &#x3D; portableFetch, basePath: string &#x3D; BASE_PATH) &#x3D;&gt; {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) &#x3D;&gt; {
                    if (response.status &gt;&#x3D; 200 &amp;&amp; response.status &lt; 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * A valid API public key will be returned in JWK format to be used to encrypt registration data
         * @summary Request API jwk public key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJsonWebKey(options?: any): (fetch?: FetchAPI, basePath?: string) &#x3D;&gt; Promise&lt;JwkJwkPublicKey&gt; {
            const localVarFetchArgs &#x3D; RegistrationApiFetchParamCreator(configuration).getJsonWebKey(options);
            return (fetch: FetchAPI &#x3D; portableFetch, basePath: string &#x3D; BASE_PATH) &#x3D;&gt; {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) &#x3D;&gt; {
                    if (response.status &gt;&#x3D; 200 &amp;&amp; response.status &lt; 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * A valid API public key will be returned to be used to encrypt registration data
         * @summary Request API public key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRegistrationPublicKey(options?: any): (fetch?: FetchAPI, basePath?: string) &#x3D;&gt; Promise&lt;RegistrationPublicKey&gt; {
            const localVarFetchArgs &#x3D; RegistrationApiFetchParamCreator(configuration).getRegistrationPublicKey(options);
            return (fetch: FetchAPI &#x3D; portableFetch, basePath: string &#x3D; BASE_PATH) &#x3D;&gt; {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) &#x3D;&gt; {
                    if (response.status &gt;&#x3D; 200 &amp;&amp; response.status &lt; 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Registers a user with AHOI
         * @summary User registration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register(options?: any): (fetch?: FetchAPI, basePath?: string) &#x3D;&gt; Promise&lt;RegistrationResponse&gt; {
            const localVarFetchArgs &#x3D; RegistrationApiFetchParamCreator(configuration).register(options);
            return (fetch: FetchAPI &#x3D; portableFetch, basePath: string &#x3D; BASE_PATH) &#x3D;&gt; {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) &#x3D;&gt; {
                    if (response.status &gt;&#x3D; 200 &amp;&amp; response.status &lt; 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
}</code>
                        </td>
                    </tr>

                <tr>
                    <td class="col-md-4">
                        <div class="io-description"><p>RegistrationApi - functional programming interface</p>
</div>
                    </td>
                </tr>

            </tbody>
        </table>
        <table class="table table-sm table-bordered">
            <tbody>
                <tr>
                    <td class="col-md-4">
                        <a name="SecurityApiFactory"></a>
                        <span class="name">
                            <b>
                            SecurityApiFactory
                            </b>
                            <a href="#SecurityApiFactory"><span class="icon ion-ios-link"></span></a>
                        </span>
                    </td>
                </tr>
                <tr>
                    <td class="col-md-4">
                        <code>SecurityApiFactory:     <code></code>
</code>
                    </td>
                </tr>
                    <tr>
                        <td class="col-md-4">
                            <i>Default value : </i><code>function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Get security
         * @param {string} accessId 
         * @param {string} accountId The **accountId** for which to retrieve securities
         * @param {string} securityId The **securityId** for the security to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSecurity(accessId: string, accountId: string, securityId: string, options?: any) {
            return SecurityApiFp(configuration).getSecurity(accessId, accountId, securityId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List securities for account
         * @param {string} accessId 
         * @param {string} accountId The **accountId** for which to retrieve securities
         * @param {number} [maxAge] Optional - defines maximum age (in seconds) of cached account data provided by the bank.         A \&amp;quot;maxAge\&amp;quot; of 3600 will not trigger an update of the account securities, when last         refresh has been done 2000 seconds ago.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSecurities(accessId: string, accountId: string, maxAge?: number, options?: any) {
            return SecurityApiFp(configuration).listSecurities(accessId, accountId, maxAge, options)(fetch, basePath);
        },
    };
}</code>
                        </td>
                    </tr>

                <tr>
                    <td class="col-md-4">
                        <div class="io-description"><p>SecurityApi - factory interface</p>
</div>
                    </td>
                </tr>

            </tbody>
        </table>
        <table class="table table-sm table-bordered">
            <tbody>
                <tr>
                    <td class="col-md-4">
                        <a name="SecurityApiFetchParamCreator"></a>
                        <span class="name">
                            <b>
                            SecurityApiFetchParamCreator
                            </b>
                            <a href="#SecurityApiFetchParamCreator"><span class="icon ion-ios-link"></span></a>
                        </span>
                    </td>
                </tr>
                <tr>
                    <td class="col-md-4">
                        <code>SecurityApiFetchParamCreator:     <code></code>
</code>
                    </td>
                </tr>
                    <tr>
                        <td class="col-md-4">
                            <i>Default value : </i><code>function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get security
         * @param {string} accessId 
         * @param {string} accountId The **accountId** for which to retrieve securities
         * @param {string} securityId The **securityId** for the security to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSecurity(accessId: string, accountId: string, securityId: string, options: any &#x3D; {}): FetchArgs {
            // verify required parameter &#x27;accessId&#x27; is not null or undefined
            if (accessId &#x3D;&#x3D;&#x3D; null || accessId &#x3D;&#x3D;&#x3D; undefined) {
                throw new RequiredError(&#x27;accessId&#x27;,&#x27;Required parameter accessId was null or undefined when calling getSecurity.&#x27;);
            }
            // verify required parameter &#x27;accountId&#x27; is not null or undefined
            if (accountId &#x3D;&#x3D;&#x3D; null || accountId &#x3D;&#x3D;&#x3D; undefined) {
                throw new RequiredError(&#x27;accountId&#x27;,&#x27;Required parameter accountId was null or undefined when calling getSecurity.&#x27;);
            }
            // verify required parameter &#x27;securityId&#x27; is not null or undefined
            if (securityId &#x3D;&#x3D;&#x3D; null || securityId &#x3D;&#x3D;&#x3D; undefined) {
                throw new RequiredError(&#x27;securityId&#x27;,&#x27;Required parameter securityId was null or undefined when calling getSecurity.&#x27;);
            }
            const localVarPath &#x3D; &#x60;/accesses/{accessId}/accounts/{accountId}/securities/{securityId}&#x60;
                .replace(&#x60;{${&quot;accessId&quot;}}&#x60;, encodeURIComponent(String(accessId)))
                .replace(&#x60;{${&quot;accountId&quot;}}&#x60;, encodeURIComponent(String(accountId)))
                .replace(&#x60;{${&quot;securityId&quot;}}&#x60;, encodeURIComponent(String(securityId)));
            const localVarUrlObj &#x3D; url.parse(localVarPath, true);
            const localVarRequestOptions &#x3D; Object.assign({ method: &#x27;GET&#x27; }, options);
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration &amp;&amp; configuration.accessToken) {
				const localVarAccessTokenValue &#x3D; typeof configuration.accessToken &#x3D;&#x3D;&#x3D; &#x27;function&#x27;
					? configuration.accessToken(&quot;oauth2&quot;, [])
					: configuration.accessToken;
                localVarHeaderParameter[&quot;Authorization&quot;] &#x3D; &quot;Bearer &quot; + localVarAccessTokenValue;
            }

            localVarUrlObj.query &#x3D; Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers &#x3D; Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List securities for account
         * @param {string} accessId 
         * @param {string} accountId The **accountId** for which to retrieve securities
         * @param {number} [maxAge] Optional - defines maximum age (in seconds) of cached account data provided by the bank.         A \&amp;quot;maxAge\&amp;quot; of 3600 will not trigger an update of the account securities, when last         refresh has been done 2000 seconds ago.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSecurities(accessId: string, accountId: string, maxAge?: number, options: any &#x3D; {}): FetchArgs {
            // verify required parameter &#x27;accessId&#x27; is not null or undefined
            if (accessId &#x3D;&#x3D;&#x3D; null || accessId &#x3D;&#x3D;&#x3D; undefined) {
                throw new RequiredError(&#x27;accessId&#x27;,&#x27;Required parameter accessId was null or undefined when calling listSecurities.&#x27;);
            }
            // verify required parameter &#x27;accountId&#x27; is not null or undefined
            if (accountId &#x3D;&#x3D;&#x3D; null || accountId &#x3D;&#x3D;&#x3D; undefined) {
                throw new RequiredError(&#x27;accountId&#x27;,&#x27;Required parameter accountId was null or undefined when calling listSecurities.&#x27;);
            }
            const localVarPath &#x3D; &#x60;/accesses/{accessId}/accounts/{accountId}/securities&#x60;
                .replace(&#x60;{${&quot;accessId&quot;}}&#x60;, encodeURIComponent(String(accessId)))
                .replace(&#x60;{${&quot;accountId&quot;}}&#x60;, encodeURIComponent(String(accountId)));
            const localVarUrlObj &#x3D; url.parse(localVarPath, true);
            const localVarRequestOptions &#x3D; Object.assign({ method: &#x27;GET&#x27; }, options);
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration &amp;&amp; configuration.accessToken) {
				const localVarAccessTokenValue &#x3D; typeof configuration.accessToken &#x3D;&#x3D;&#x3D; &#x27;function&#x27;
					? configuration.accessToken(&quot;oauth2&quot;, [])
					: configuration.accessToken;
                localVarHeaderParameter[&quot;Authorization&quot;] &#x3D; &quot;Bearer &quot; + localVarAccessTokenValue;
            }

            if (maxAge !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;max-age&#x27;] &#x3D; maxAge;
            }

            localVarUrlObj.query &#x3D; Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers &#x3D; Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
}</code>
                        </td>
                    </tr>

                <tr>
                    <td class="col-md-4">
                        <div class="io-description"><p>SecurityApi - fetch parameter creator</p>
</div>
                    </td>
                </tr>

            </tbody>
        </table>
        <table class="table table-sm table-bordered">
            <tbody>
                <tr>
                    <td class="col-md-4">
                        <a name="SecurityApiFp"></a>
                        <span class="name">
                            <b>
                            SecurityApiFp
                            </b>
                            <a href="#SecurityApiFp"><span class="icon ion-ios-link"></span></a>
                        </span>
                    </td>
                </tr>
                <tr>
                    <td class="col-md-4">
                        <code>SecurityApiFp:     <code></code>
</code>
                    </td>
                </tr>
                    <tr>
                        <td class="col-md-4">
                            <i>Default value : </i><code>function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get security
         * @param {string} accessId 
         * @param {string} accountId The **accountId** for which to retrieve securities
         * @param {string} securityId The **securityId** for the security to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSecurity(accessId: string, accountId: string, securityId: string, options?: any): (fetch?: FetchAPI, basePath?: string) &#x3D;&gt; Promise&lt;Security&gt; {
            const localVarFetchArgs &#x3D; SecurityApiFetchParamCreator(configuration).getSecurity(accessId, accountId, securityId, options);
            return (fetch: FetchAPI &#x3D; portableFetch, basePath: string &#x3D; BASE_PATH) &#x3D;&gt; {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) &#x3D;&gt; {
                    if (response.status &gt;&#x3D; 200 &amp;&amp; response.status &lt; 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List securities for account
         * @param {string} accessId 
         * @param {string} accountId The **accountId** for which to retrieve securities
         * @param {number} [maxAge] Optional - defines maximum age (in seconds) of cached account data provided by the bank.         A \&amp;quot;maxAge\&amp;quot; of 3600 will not trigger an update of the account securities, when last         refresh has been done 2000 seconds ago.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSecurities(accessId: string, accountId: string, maxAge?: number, options?: any): (fetch?: FetchAPI, basePath?: string) &#x3D;&gt; Promise&lt;Array&lt;Security&gt;&gt; {
            const localVarFetchArgs &#x3D; SecurityApiFetchParamCreator(configuration).listSecurities(accessId, accountId, maxAge, options);
            return (fetch: FetchAPI &#x3D; portableFetch, basePath: string &#x3D; BASE_PATH) &#x3D;&gt; {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) &#x3D;&gt; {
                    if (response.status &gt;&#x3D; 200 &amp;&amp; response.status &lt; 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
}</code>
                        </td>
                    </tr>

                <tr>
                    <td class="col-md-4">
                        <div class="io-description"><p>SecurityApi - functional programming interface</p>
</div>
                    </td>
                </tr>

            </tbody>
        </table>
        <table class="table table-sm table-bordered">
            <tbody>
                <tr>
                    <td class="col-md-4">
                        <a name="TANSchemesApiFactory"></a>
                        <span class="name">
                            <b>
                            TANSchemesApiFactory
                            </b>
                            <a href="#TANSchemesApiFactory"><span class="icon ion-ios-link"></span></a>
                        </span>
                    </td>
                </tr>
                <tr>
                    <td class="col-md-4">
                        <code>TANSchemesApiFactory:     <code></code>
</code>
                    </td>
                </tr>
                    <tr>
                        <td class="col-md-4">
                            <i>Default value : </i><code>function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Returns the currently selected TAN media for the access.
         * @summary Get current TAN media.
         * @param {string} accessId The **accessId** for which to retrieve the current TAN media.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentTanMedia(accessId: string, options?: any) {
            return TANSchemesApiFp(configuration).getCurrentTanMedia(accessId, options)(fetch, basePath);
        },
        /**
         * Returns the currently selected TAN scheme for the access.
         * @summary Get current TAN scheme.
         * @param {string} accessId The **accessId** for which to retrieve the current TAN scheme.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentTanScheme(accessId: string, options?: any) {
            return TANSchemesApiFp(configuration).getCurrentTanScheme(accessId, options)(fetch, basePath);
        },
        /**
         * Retrieves all available TAN schemes for access.
         * @summary List TAN schemes for access
         * @param {string} accessId The **id** for the access for which to retrieve the TAN list
         * @param {number} [maxAge] Optional - defines maximum age (in seconds) of cached account data provided by the bank.      A \&amp;quot;maxAge\&amp;quot; of 3600 will not trigger an update of TAN schemes, when last refresh has been      done 2000 seconds ago.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTanSchemes(accessId: string, maxAge?: number, options?: any) {
            return TANSchemesApiFp(configuration).getTanSchemes(accessId, maxAge, options)(fetch, basePath);
        },
        /**
         * Update the access with a new currentTanMedia.
         * @summary Update current TAN media.
         * @param {string} accessId The **accessId** for which to set the current TAN media.
         * @param {string} tanMediaId The **id** for the TAN media that should be set as the new currentTanMedia.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putCurrentTanMedia(accessId: string, tanMediaId: string, options?: any) {
            return TANSchemesApiFp(configuration).putCurrentTanMedia(accessId, tanMediaId, options)(fetch, basePath);
        },
        /**
         * Update the access with a new currentTanScheme.
         * @summary Update current TAN scheme.
         * @param {string} accessId The **accessId** for which to set the current TAN scheme.
         * @param {string} tanSchemeId The **id** for the TAN scheme that should be set as the new currentTanScheme.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putCurrentTanScheme(accessId: string, tanSchemeId: string, options?: any) {
            return TANSchemesApiFp(configuration).putCurrentTanScheme(accessId, tanSchemeId, options)(fetch, basePath);
        },
    };
}</code>
                        </td>
                    </tr>

                <tr>
                    <td class="col-md-4">
                        <div class="io-description"><p>TANSchemesApi - factory interface</p>
</div>
                    </td>
                </tr>

            </tbody>
        </table>
        <table class="table table-sm table-bordered">
            <tbody>
                <tr>
                    <td class="col-md-4">
                        <a name="TANSchemesApiFetchParamCreator"></a>
                        <span class="name">
                            <b>
                            TANSchemesApiFetchParamCreator
                            </b>
                            <a href="#TANSchemesApiFetchParamCreator"><span class="icon ion-ios-link"></span></a>
                        </span>
                    </td>
                </tr>
                <tr>
                    <td class="col-md-4">
                        <code>TANSchemesApiFetchParamCreator:     <code></code>
</code>
                    </td>
                </tr>
                    <tr>
                        <td class="col-md-4">
                            <i>Default value : </i><code>function (configuration?: Configuration) {
    return {
        /**
         * Returns the currently selected TAN media for the access.
         * @summary Get current TAN media.
         * @param {string} accessId The **accessId** for which to retrieve the current TAN media.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentTanMedia(accessId: string, options: any &#x3D; {}): FetchArgs {
            // verify required parameter &#x27;accessId&#x27; is not null or undefined
            if (accessId &#x3D;&#x3D;&#x3D; null || accessId &#x3D;&#x3D;&#x3D; undefined) {
                throw new RequiredError(&#x27;accessId&#x27;,&#x27;Required parameter accessId was null or undefined when calling getCurrentTanMedia.&#x27;);
            }
            const localVarPath &#x3D; &#x60;/accesses/{accessId}/currenttanmedia&#x60;
                .replace(&#x60;{${&quot;accessId&quot;}}&#x60;, encodeURIComponent(String(accessId)));
            const localVarUrlObj &#x3D; url.parse(localVarPath, true);
            const localVarRequestOptions &#x3D; Object.assign({ method: &#x27;GET&#x27; }, options);
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration &amp;&amp; configuration.accessToken) {
				const localVarAccessTokenValue &#x3D; typeof configuration.accessToken &#x3D;&#x3D;&#x3D; &#x27;function&#x27;
					? configuration.accessToken(&quot;oauth2&quot;, [])
					: configuration.accessToken;
                localVarHeaderParameter[&quot;Authorization&quot;] &#x3D; &quot;Bearer &quot; + localVarAccessTokenValue;
            }

            localVarUrlObj.query &#x3D; Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers &#x3D; Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the currently selected TAN scheme for the access.
         * @summary Get current TAN scheme.
         * @param {string} accessId The **accessId** for which to retrieve the current TAN scheme.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentTanScheme(accessId: string, options: any &#x3D; {}): FetchArgs {
            // verify required parameter &#x27;accessId&#x27; is not null or undefined
            if (accessId &#x3D;&#x3D;&#x3D; null || accessId &#x3D;&#x3D;&#x3D; undefined) {
                throw new RequiredError(&#x27;accessId&#x27;,&#x27;Required parameter accessId was null or undefined when calling getCurrentTanScheme.&#x27;);
            }
            const localVarPath &#x3D; &#x60;/accesses/{accessId}/currenttanscheme&#x60;
                .replace(&#x60;{${&quot;accessId&quot;}}&#x60;, encodeURIComponent(String(accessId)));
            const localVarUrlObj &#x3D; url.parse(localVarPath, true);
            const localVarRequestOptions &#x3D; Object.assign({ method: &#x27;GET&#x27; }, options);
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration &amp;&amp; configuration.accessToken) {
				const localVarAccessTokenValue &#x3D; typeof configuration.accessToken &#x3D;&#x3D;&#x3D; &#x27;function&#x27;
					? configuration.accessToken(&quot;oauth2&quot;, [])
					: configuration.accessToken;
                localVarHeaderParameter[&quot;Authorization&quot;] &#x3D; &quot;Bearer &quot; + localVarAccessTokenValue;
            }

            localVarUrlObj.query &#x3D; Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers &#x3D; Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves all available TAN schemes for access.
         * @summary List TAN schemes for access
         * @param {string} accessId The **id** for the access for which to retrieve the TAN list
         * @param {number} [maxAge] Optional - defines maximum age (in seconds) of cached account data provided by the bank.      A \&amp;quot;maxAge\&amp;quot; of 3600 will not trigger an update of TAN schemes, when last refresh has been      done 2000 seconds ago.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTanSchemes(accessId: string, maxAge?: number, options: any &#x3D; {}): FetchArgs {
            // verify required parameter &#x27;accessId&#x27; is not null or undefined
            if (accessId &#x3D;&#x3D;&#x3D; null || accessId &#x3D;&#x3D;&#x3D; undefined) {
                throw new RequiredError(&#x27;accessId&#x27;,&#x27;Required parameter accessId was null or undefined when calling getTanSchemes.&#x27;);
            }
            const localVarPath &#x3D; &#x60;/accesses/{accessId}/tanschemes&#x60;
                .replace(&#x60;{${&quot;accessId&quot;}}&#x60;, encodeURIComponent(String(accessId)));
            const localVarUrlObj &#x3D; url.parse(localVarPath, true);
            const localVarRequestOptions &#x3D; Object.assign({ method: &#x27;GET&#x27; }, options);
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration &amp;&amp; configuration.accessToken) {
				const localVarAccessTokenValue &#x3D; typeof configuration.accessToken &#x3D;&#x3D;&#x3D; &#x27;function&#x27;
					? configuration.accessToken(&quot;oauth2&quot;, [])
					: configuration.accessToken;
                localVarHeaderParameter[&quot;Authorization&quot;] &#x3D; &quot;Bearer &quot; + localVarAccessTokenValue;
            }

            if (maxAge !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;max-age&#x27;] &#x3D; maxAge;
            }

            localVarUrlObj.query &#x3D; Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers &#x3D; Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the access with a new currentTanMedia.
         * @summary Update current TAN media.
         * @param {string} accessId The **accessId** for which to set the current TAN media.
         * @param {string} tanMediaId The **id** for the TAN media that should be set as the new currentTanMedia.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putCurrentTanMedia(accessId: string, tanMediaId: string, options: any &#x3D; {}): FetchArgs {
            // verify required parameter &#x27;accessId&#x27; is not null or undefined
            if (accessId &#x3D;&#x3D;&#x3D; null || accessId &#x3D;&#x3D;&#x3D; undefined) {
                throw new RequiredError(&#x27;accessId&#x27;,&#x27;Required parameter accessId was null or undefined when calling putCurrentTanMedia.&#x27;);
            }
            // verify required parameter &#x27;tanMediaId&#x27; is not null or undefined
            if (tanMediaId &#x3D;&#x3D;&#x3D; null || tanMediaId &#x3D;&#x3D;&#x3D; undefined) {
                throw new RequiredError(&#x27;tanMediaId&#x27;,&#x27;Required parameter tanMediaId was null or undefined when calling putCurrentTanMedia.&#x27;);
            }
            const localVarPath &#x3D; &#x60;/accesses/{accessId}/currenttanmedia/{tanMediaId}&#x60;
                .replace(&#x60;{${&quot;accessId&quot;}}&#x60;, encodeURIComponent(String(accessId)))
                .replace(&#x60;{${&quot;tanMediaId&quot;}}&#x60;, encodeURIComponent(String(tanMediaId)));
            const localVarUrlObj &#x3D; url.parse(localVarPath, true);
            const localVarRequestOptions &#x3D; Object.assign({ method: &#x27;PUT&#x27; }, options);
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration &amp;&amp; configuration.accessToken) {
				const localVarAccessTokenValue &#x3D; typeof configuration.accessToken &#x3D;&#x3D;&#x3D; &#x27;function&#x27;
					? configuration.accessToken(&quot;oauth2&quot;, [])
					: configuration.accessToken;
                localVarHeaderParameter[&quot;Authorization&quot;] &#x3D; &quot;Bearer &quot; + localVarAccessTokenValue;
            }

            localVarUrlObj.query &#x3D; Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers &#x3D; Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the access with a new currentTanScheme.
         * @summary Update current TAN scheme.
         * @param {string} accessId The **accessId** for which to set the current TAN scheme.
         * @param {string} tanSchemeId The **id** for the TAN scheme that should be set as the new currentTanScheme.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putCurrentTanScheme(accessId: string, tanSchemeId: string, options: any &#x3D; {}): FetchArgs {
            // verify required parameter &#x27;accessId&#x27; is not null or undefined
            if (accessId &#x3D;&#x3D;&#x3D; null || accessId &#x3D;&#x3D;&#x3D; undefined) {
                throw new RequiredError(&#x27;accessId&#x27;,&#x27;Required parameter accessId was null or undefined when calling putCurrentTanScheme.&#x27;);
            }
            // verify required parameter &#x27;tanSchemeId&#x27; is not null or undefined
            if (tanSchemeId &#x3D;&#x3D;&#x3D; null || tanSchemeId &#x3D;&#x3D;&#x3D; undefined) {
                throw new RequiredError(&#x27;tanSchemeId&#x27;,&#x27;Required parameter tanSchemeId was null or undefined when calling putCurrentTanScheme.&#x27;);
            }
            const localVarPath &#x3D; &#x60;/accesses/{accessId}/currenttanscheme/{tanSchemeId}&#x60;
                .replace(&#x60;{${&quot;accessId&quot;}}&#x60;, encodeURIComponent(String(accessId)))
                .replace(&#x60;{${&quot;tanSchemeId&quot;}}&#x60;, encodeURIComponent(String(tanSchemeId)));
            const localVarUrlObj &#x3D; url.parse(localVarPath, true);
            const localVarRequestOptions &#x3D; Object.assign({ method: &#x27;PUT&#x27; }, options);
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration &amp;&amp; configuration.accessToken) {
				const localVarAccessTokenValue &#x3D; typeof configuration.accessToken &#x3D;&#x3D;&#x3D; &#x27;function&#x27;
					? configuration.accessToken(&quot;oauth2&quot;, [])
					: configuration.accessToken;
                localVarHeaderParameter[&quot;Authorization&quot;] &#x3D; &quot;Bearer &quot; + localVarAccessTokenValue;
            }

            localVarUrlObj.query &#x3D; Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers &#x3D; Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
}</code>
                        </td>
                    </tr>

                <tr>
                    <td class="col-md-4">
                        <div class="io-description"><p>TANSchemesApi - fetch parameter creator</p>
</div>
                    </td>
                </tr>

            </tbody>
        </table>
        <table class="table table-sm table-bordered">
            <tbody>
                <tr>
                    <td class="col-md-4">
                        <a name="TANSchemesApiFp"></a>
                        <span class="name">
                            <b>
                            TANSchemesApiFp
                            </b>
                            <a href="#TANSchemesApiFp"><span class="icon ion-ios-link"></span></a>
                        </span>
                    </td>
                </tr>
                <tr>
                    <td class="col-md-4">
                        <code>TANSchemesApiFp:     <code></code>
</code>
                    </td>
                </tr>
                    <tr>
                        <td class="col-md-4">
                            <i>Default value : </i><code>function(configuration?: Configuration) {
    return {
        /**
         * Returns the currently selected TAN media for the access.
         * @summary Get current TAN media.
         * @param {string} accessId The **accessId** for which to retrieve the current TAN media.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentTanMedia(accessId: string, options?: any): (fetch?: FetchAPI, basePath?: string) &#x3D;&gt; Promise&lt;TanMedia&gt; {
            const localVarFetchArgs &#x3D; TANSchemesApiFetchParamCreator(configuration).getCurrentTanMedia(accessId, options);
            return (fetch: FetchAPI &#x3D; portableFetch, basePath: string &#x3D; BASE_PATH) &#x3D;&gt; {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) &#x3D;&gt; {
                    if (response.status &gt;&#x3D; 200 &amp;&amp; response.status &lt; 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns the currently selected TAN scheme for the access.
         * @summary Get current TAN scheme.
         * @param {string} accessId The **accessId** for which to retrieve the current TAN scheme.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentTanScheme(accessId: string, options?: any): (fetch?: FetchAPI, basePath?: string) &#x3D;&gt; Promise&lt;TanScheme&gt; {
            const localVarFetchArgs &#x3D; TANSchemesApiFetchParamCreator(configuration).getCurrentTanScheme(accessId, options);
            return (fetch: FetchAPI &#x3D; portableFetch, basePath: string &#x3D; BASE_PATH) &#x3D;&gt; {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) &#x3D;&gt; {
                    if (response.status &gt;&#x3D; 200 &amp;&amp; response.status &lt; 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves all available TAN schemes for access.
         * @summary List TAN schemes for access
         * @param {string} accessId The **id** for the access for which to retrieve the TAN list
         * @param {number} [maxAge] Optional - defines maximum age (in seconds) of cached account data provided by the bank.      A \&amp;quot;maxAge\&amp;quot; of 3600 will not trigger an update of TAN schemes, when last refresh has been      done 2000 seconds ago.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTanSchemes(accessId: string, maxAge?: number, options?: any): (fetch?: FetchAPI, basePath?: string) &#x3D;&gt; Promise&lt;Array&lt;TanScheme&gt;&gt; {
            const localVarFetchArgs &#x3D; TANSchemesApiFetchParamCreator(configuration).getTanSchemes(accessId, maxAge, options);
            return (fetch: FetchAPI &#x3D; portableFetch, basePath: string &#x3D; BASE_PATH) &#x3D;&gt; {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) &#x3D;&gt; {
                    if (response.status &gt;&#x3D; 200 &amp;&amp; response.status &lt; 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update the access with a new currentTanMedia.
         * @summary Update current TAN media.
         * @param {string} accessId The **accessId** for which to set the current TAN media.
         * @param {string} tanMediaId The **id** for the TAN media that should be set as the new currentTanMedia.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putCurrentTanMedia(accessId: string, tanMediaId: string, options?: any): (fetch?: FetchAPI, basePath?: string) &#x3D;&gt; Promise&lt;Access&gt; {
            const localVarFetchArgs &#x3D; TANSchemesApiFetchParamCreator(configuration).putCurrentTanMedia(accessId, tanMediaId, options);
            return (fetch: FetchAPI &#x3D; portableFetch, basePath: string &#x3D; BASE_PATH) &#x3D;&gt; {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) &#x3D;&gt; {
                    if (response.status &gt;&#x3D; 200 &amp;&amp; response.status &lt; 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update the access with a new currentTanScheme.
         * @summary Update current TAN scheme.
         * @param {string} accessId The **accessId** for which to set the current TAN scheme.
         * @param {string} tanSchemeId The **id** for the TAN scheme that should be set as the new currentTanScheme.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putCurrentTanScheme(accessId: string, tanSchemeId: string, options?: any): (fetch?: FetchAPI, basePath?: string) &#x3D;&gt; Promise&lt;Access&gt; {
            const localVarFetchArgs &#x3D; TANSchemesApiFetchParamCreator(configuration).putCurrentTanScheme(accessId, tanSchemeId, options);
            return (fetch: FetchAPI &#x3D; portableFetch, basePath: string &#x3D; BASE_PATH) &#x3D;&gt; {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) &#x3D;&gt; {
                    if (response.status &gt;&#x3D; 200 &amp;&amp; response.status &lt; 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
}</code>
                        </td>
                    </tr>

                <tr>
                    <td class="col-md-4">
                        <div class="io-description"><p>TANSchemesApi - functional programming interface</p>
</div>
                    </td>
                </tr>

            </tbody>
        </table>
        <table class="table table-sm table-bordered">
            <tbody>
                <tr>
                    <td class="col-md-4">
                        <a name="TaskApiFactory"></a>
                        <span class="name">
                            <b>
                            TaskApiFactory
                            </b>
                            <a href="#TaskApiFactory"><span class="icon ion-ios-link"></span></a>
                        </span>
                    </td>
                </tr>
                <tr>
                    <td class="col-md-4">
                        <code>TaskApiFactory:     <code></code>
</code>
                    </td>
                </tr>
                    <tr>
                        <td class="col-md-4">
                            <i>Default value : </i><code>function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Fetch challenge for asynchronous running task item from AHOI.
         * @summary Fetch challenge
         * @param {string} taskId The **id** for the Task.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChallenge(taskId: string, options?: any) {
            return TaskApiFp(configuration).getChallenge(taskId, options)(fetch, basePath);
        },
        /**
         * Fetch asynchronous running task item and its state from AHOI.
         * @summary Fetch task
         * @param {string} taskId The **id** for the access to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTask(taskId: string, options?: any) {
            return TaskApiFp(configuration).getTask(taskId, options)(fetch, basePath);
        },
        /**
         * Provide an authorization information (e.g. TAN) to an asynchronous running task.
         * @summary Authorize task
         * @param {string} taskId The **id** for the Task.
         * @param {ChallengeResponse} challengeResponse the response to process
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postChallengeResponse(taskId: string, challengeResponse: ChallengeResponse, options?: any) {
            return TaskApiFp(configuration).postChallengeResponse(taskId, challengeResponse, options)(fetch, basePath);
        },
    };
}</code>
                        </td>
                    </tr>

                <tr>
                    <td class="col-md-4">
                        <div class="io-description"><p>TaskApi - factory interface</p>
</div>
                    </td>
                </tr>

            </tbody>
        </table>
        <table class="table table-sm table-bordered">
            <tbody>
                <tr>
                    <td class="col-md-4">
                        <a name="TaskApiFetchParamCreator"></a>
                        <span class="name">
                            <b>
                            TaskApiFetchParamCreator
                            </b>
                            <a href="#TaskApiFetchParamCreator"><span class="icon ion-ios-link"></span></a>
                        </span>
                    </td>
                </tr>
                <tr>
                    <td class="col-md-4">
                        <code>TaskApiFetchParamCreator:     <code></code>
</code>
                    </td>
                </tr>
                    <tr>
                        <td class="col-md-4">
                            <i>Default value : </i><code>function (configuration?: Configuration) {
    return {
        /**
         * Fetch challenge for asynchronous running task item from AHOI.
         * @summary Fetch challenge
         * @param {string} taskId The **id** for the Task.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChallenge(taskId: string, options: any &#x3D; {}): FetchArgs {
            // verify required parameter &#x27;taskId&#x27; is not null or undefined
            if (taskId &#x3D;&#x3D;&#x3D; null || taskId &#x3D;&#x3D;&#x3D; undefined) {
                throw new RequiredError(&#x27;taskId&#x27;,&#x27;Required parameter taskId was null or undefined when calling getChallenge.&#x27;);
            }
            const localVarPath &#x3D; &#x60;/tasks/{taskId}/challenges&#x60;
                .replace(&#x60;{${&quot;taskId&quot;}}&#x60;, encodeURIComponent(String(taskId)));
            const localVarUrlObj &#x3D; url.parse(localVarPath, true);
            const localVarRequestOptions &#x3D; Object.assign({ method: &#x27;GET&#x27; }, options);
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration &amp;&amp; configuration.accessToken) {
				const localVarAccessTokenValue &#x3D; typeof configuration.accessToken &#x3D;&#x3D;&#x3D; &#x27;function&#x27;
					? configuration.accessToken(&quot;oauth2&quot;, [])
					: configuration.accessToken;
                localVarHeaderParameter[&quot;Authorization&quot;] &#x3D; &quot;Bearer &quot; + localVarAccessTokenValue;
            }

            localVarUrlObj.query &#x3D; Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers &#x3D; Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch asynchronous running task item and its state from AHOI.
         * @summary Fetch task
         * @param {string} taskId The **id** for the access to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTask(taskId: string, options: any &#x3D; {}): FetchArgs {
            // verify required parameter &#x27;taskId&#x27; is not null or undefined
            if (taskId &#x3D;&#x3D;&#x3D; null || taskId &#x3D;&#x3D;&#x3D; undefined) {
                throw new RequiredError(&#x27;taskId&#x27;,&#x27;Required parameter taskId was null or undefined when calling getTask.&#x27;);
            }
            const localVarPath &#x3D; &#x60;/tasks/{taskId}&#x60;
                .replace(&#x60;{${&quot;taskId&quot;}}&#x60;, encodeURIComponent(String(taskId)));
            const localVarUrlObj &#x3D; url.parse(localVarPath, true);
            const localVarRequestOptions &#x3D; Object.assign({ method: &#x27;GET&#x27; }, options);
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration &amp;&amp; configuration.accessToken) {
				const localVarAccessTokenValue &#x3D; typeof configuration.accessToken &#x3D;&#x3D;&#x3D; &#x27;function&#x27;
					? configuration.accessToken(&quot;oauth2&quot;, [])
					: configuration.accessToken;
                localVarHeaderParameter[&quot;Authorization&quot;] &#x3D; &quot;Bearer &quot; + localVarAccessTokenValue;
            }

            localVarUrlObj.query &#x3D; Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers &#x3D; Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Provide an authorization information (e.g. TAN) to an asynchronous running task.
         * @summary Authorize task
         * @param {string} taskId The **id** for the Task.
         * @param {ChallengeResponse} challengeResponse the response to process
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postChallengeResponse(taskId: string, challengeResponse: ChallengeResponse, options: any &#x3D; {}): FetchArgs {
            // verify required parameter &#x27;taskId&#x27; is not null or undefined
            if (taskId &#x3D;&#x3D;&#x3D; null || taskId &#x3D;&#x3D;&#x3D; undefined) {
                throw new RequiredError(&#x27;taskId&#x27;,&#x27;Required parameter taskId was null or undefined when calling postChallengeResponse.&#x27;);
            }
            // verify required parameter &#x27;challengeResponse&#x27; is not null or undefined
            if (challengeResponse &#x3D;&#x3D;&#x3D; null || challengeResponse &#x3D;&#x3D;&#x3D; undefined) {
                throw new RequiredError(&#x27;challengeResponse&#x27;,&#x27;Required parameter challengeResponse was null or undefined when calling postChallengeResponse.&#x27;);
            }
            const localVarPath &#x3D; &#x60;/tasks/{taskId}/authorizations&#x60;
                .replace(&#x60;{${&quot;taskId&quot;}}&#x60;, encodeURIComponent(String(taskId)));
            const localVarUrlObj &#x3D; url.parse(localVarPath, true);
            const localVarRequestOptions &#x3D; Object.assign({ method: &#x27;POST&#x27; }, options);
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration &amp;&amp; configuration.accessToken) {
				const localVarAccessTokenValue &#x3D; typeof configuration.accessToken &#x3D;&#x3D;&#x3D; &#x27;function&#x27;
					? configuration.accessToken(&quot;oauth2&quot;, [])
					: configuration.accessToken;
                localVarHeaderParameter[&quot;Authorization&quot;] &#x3D; &quot;Bearer &quot; + localVarAccessTokenValue;
            }

            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            localVarUrlObj.query &#x3D; Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers &#x3D; Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization &#x3D; (&lt;any&gt;&quot;ChallengeResponse&quot; !&#x3D;&#x3D; &quot;string&quot;) || localVarRequestOptions.headers[&#x27;Content-Type&#x27;] &#x3D;&#x3D;&#x3D; &#x27;application/json&#x27;;
            localVarRequestOptions.body &#x3D;  needsSerialization ? JSON.stringify(challengeResponse || {}) : (challengeResponse || &quot;&quot;);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
}</code>
                        </td>
                    </tr>

                <tr>
                    <td class="col-md-4">
                        <div class="io-description"><p>TaskApi - fetch parameter creator</p>
</div>
                    </td>
                </tr>

            </tbody>
        </table>
        <table class="table table-sm table-bordered">
            <tbody>
                <tr>
                    <td class="col-md-4">
                        <a name="TaskApiFp"></a>
                        <span class="name">
                            <b>
                            TaskApiFp
                            </b>
                            <a href="#TaskApiFp"><span class="icon ion-ios-link"></span></a>
                        </span>
                    </td>
                </tr>
                <tr>
                    <td class="col-md-4">
                        <code>TaskApiFp:     <code></code>
</code>
                    </td>
                </tr>
                    <tr>
                        <td class="col-md-4">
                            <i>Default value : </i><code>function(configuration?: Configuration) {
    return {
        /**
         * Fetch challenge for asynchronous running task item from AHOI.
         * @summary Fetch challenge
         * @param {string} taskId The **id** for the Task.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChallenge(taskId: string, options?: any): (fetch?: FetchAPI, basePath?: string) &#x3D;&gt; Promise&lt;Challenge&gt; {
            const localVarFetchArgs &#x3D; TaskApiFetchParamCreator(configuration).getChallenge(taskId, options);
            return (fetch: FetchAPI &#x3D; portableFetch, basePath: string &#x3D; BASE_PATH) &#x3D;&gt; {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) &#x3D;&gt; {
                    if (response.status &gt;&#x3D; 200 &amp;&amp; response.status &lt; 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Fetch asynchronous running task item and its state from AHOI.
         * @summary Fetch task
         * @param {string} taskId The **id** for the access to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTask(taskId: string, options?: any): (fetch?: FetchAPI, basePath?: string) &#x3D;&gt; Promise&lt;Task&gt; {
            const localVarFetchArgs &#x3D; TaskApiFetchParamCreator(configuration).getTask(taskId, options);
            return (fetch: FetchAPI &#x3D; portableFetch, basePath: string &#x3D; BASE_PATH) &#x3D;&gt; {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) &#x3D;&gt; {
                    if (response.status &gt;&#x3D; 200 &amp;&amp; response.status &lt; 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Provide an authorization information (e.g. TAN) to an asynchronous running task.
         * @summary Authorize task
         * @param {string} taskId The **id** for the Task.
         * @param {ChallengeResponse} challengeResponse the response to process
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postChallengeResponse(taskId: string, challengeResponse: ChallengeResponse, options?: any): (fetch?: FetchAPI, basePath?: string) &#x3D;&gt; Promise&lt;Task&gt; {
            const localVarFetchArgs &#x3D; TaskApiFetchParamCreator(configuration).postChallengeResponse(taskId, challengeResponse, options);
            return (fetch: FetchAPI &#x3D; portableFetch, basePath: string &#x3D; BASE_PATH) &#x3D;&gt; {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) &#x3D;&gt; {
                    if (response.status &gt;&#x3D; 200 &amp;&amp; response.status &lt; 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
}</code>
                        </td>
                    </tr>

                <tr>
                    <td class="col-md-4">
                        <div class="io-description"><p>TaskApi - functional programming interface</p>
</div>
                    </td>
                </tr>

            </tbody>
        </table>
        <table class="table table-sm table-bordered">
            <tbody>
                <tr>
                    <td class="col-md-4">
                        <a name="TransactionApiFactory"></a>
                        <span class="name">
                            <b>
                            TransactionApiFactory
                            </b>
                            <a href="#TransactionApiFactory"><span class="icon ion-ios-link"></span></a>
                        </span>
                    </td>
                </tr>
                <tr>
                    <td class="col-md-4">
                        <code>TransactionApiFactory:     <code></code>
</code>
                    </td>
                </tr>
                    <tr>
                        <td class="col-md-4">
                            <i>Default value : </i><code>function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Returns the transaction identified by **transactionId** in relationship with **accountId**.
         * @summary Get transaction
         * @param {string} accessId The **accessId** for the transaction to retrieve
         * @param {string} accountId The **accountId** for the transaction to retrieve
         * @param {string} transactionId The **transactionId** for the pattern to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransaction(accessId: string, accountId: string, transactionId: string, options?: any) {
            return TransactionApiFp(configuration).getTransaction(accessId, accountId, transactionId, options)(fetch, basePath);
        },
        /**
         * Retrieve all transactions for **accountId**.
         * @summary List transactions for account
         * @param {string} accessId The **accessId** for which to retrieve transactions.
         * @param {string} accountId The **accountId** for which to retrieve transactions.
         * @param {number} [maxAge] Optional - defines maximum age (in seconds) of cached account data provided by the bank.          A \&amp;quot;maxAge\&amp;quot; of 3600 will not trigger an update of transactions, when last refresh has          been done 2000 seconds ago.
         * @param {number} [limit] Optional  limit the number of returned transactions
         * @param {number} [offset] Optional  skip the first **offset** transactions in result
         * @param {string} [from] Optional  only return transactions with booking date later than **from**; an ISO8601 Month(2014-11), Date (2014-11-17) or DateTime         (2014-11-17T12:00:00Z)
         * @param {string} [to] Optional  only return transactions with booking date prior or equal to **to**; an ISO8601 Date, Month or DateTime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactions(accessId: string, accountId: string, maxAge?: number, limit?: number, offset?: number, from?: string, to?: string, options?: any) {
            return TransactionApiFp(configuration).listTransactions(accessId, accountId, maxAge, limit, offset, from, to, options)(fetch, basePath);
        },
        /**
         * Retrieve all transactions for **patternId**.
         * @summary List transactions for pattern
         * @param {string} accessId The **accessId** for which to retrieve transactions
         * @param {string} accountId The **accountId** for which to retrieve transactions
         * @param {string} patternId The **patternId** for which to retrieve transactions
         * @param {number} [maxAge] Optional - defines maximum age (in seconds) of cached account data provided by the bank.       A \&amp;quot;maxAge\&amp;quot; of 3600 will not trigger an update of transactions, when last refresh has       been done 2000 seconds ago.
         * @param {number} [limit] Optional  limit the number of returned transactions
         * @param {number} [offset] Optional  skip the first **offset** transactions in result
         * @param {string} [from] Optional  only return transactions with a booking date later than **from**; an ISO8601 Month(2014-11), Date (2014-11-17) or DateTime         (2014-11-17T12:00:00Z)
         * @param {string} [to] Optional  only return transactions with a booking date prior or equal to **to**; an ISO8601 Date, Month or DateTime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactionsForPattern(accessId: string, accountId: string, patternId: string, maxAge?: number, limit?: number, offset?: number, from?: string, to?: string, options?: any) {
            return TransactionApiFp(configuration).listTransactionsForPattern(accessId, accountId, patternId, maxAge, limit, offset, from, to, options)(fetch, basePath);
        },
    };
}</code>
                        </td>
                    </tr>

                <tr>
                    <td class="col-md-4">
                        <div class="io-description"><p>TransactionApi - factory interface</p>
</div>
                    </td>
                </tr>

            </tbody>
        </table>
        <table class="table table-sm table-bordered">
            <tbody>
                <tr>
                    <td class="col-md-4">
                        <a name="TransactionApiFetchParamCreator"></a>
                        <span class="name">
                            <b>
                            TransactionApiFetchParamCreator
                            </b>
                            <a href="#TransactionApiFetchParamCreator"><span class="icon ion-ios-link"></span></a>
                        </span>
                    </td>
                </tr>
                <tr>
                    <td class="col-md-4">
                        <code>TransactionApiFetchParamCreator:     <code></code>
</code>
                    </td>
                </tr>
                    <tr>
                        <td class="col-md-4">
                            <i>Default value : </i><code>function (configuration?: Configuration) {
    return {
        /**
         * Returns the transaction identified by **transactionId** in relationship with **accountId**.
         * @summary Get transaction
         * @param {string} accessId The **accessId** for the transaction to retrieve
         * @param {string} accountId The **accountId** for the transaction to retrieve
         * @param {string} transactionId The **transactionId** for the pattern to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransaction(accessId: string, accountId: string, transactionId: string, options: any &#x3D; {}): FetchArgs {
            // verify required parameter &#x27;accessId&#x27; is not null or undefined
            if (accessId &#x3D;&#x3D;&#x3D; null || accessId &#x3D;&#x3D;&#x3D; undefined) {
                throw new RequiredError(&#x27;accessId&#x27;,&#x27;Required parameter accessId was null or undefined when calling getTransaction.&#x27;);
            }
            // verify required parameter &#x27;accountId&#x27; is not null or undefined
            if (accountId &#x3D;&#x3D;&#x3D; null || accountId &#x3D;&#x3D;&#x3D; undefined) {
                throw new RequiredError(&#x27;accountId&#x27;,&#x27;Required parameter accountId was null or undefined when calling getTransaction.&#x27;);
            }
            // verify required parameter &#x27;transactionId&#x27; is not null or undefined
            if (transactionId &#x3D;&#x3D;&#x3D; null || transactionId &#x3D;&#x3D;&#x3D; undefined) {
                throw new RequiredError(&#x27;transactionId&#x27;,&#x27;Required parameter transactionId was null or undefined when calling getTransaction.&#x27;);
            }
            const localVarPath &#x3D; &#x60;/accesses/{accessId}/accounts/{accountId}/transactions/{transactionId}&#x60;
                .replace(&#x60;{${&quot;accessId&quot;}}&#x60;, encodeURIComponent(String(accessId)))
                .replace(&#x60;{${&quot;accountId&quot;}}&#x60;, encodeURIComponent(String(accountId)))
                .replace(&#x60;{${&quot;transactionId&quot;}}&#x60;, encodeURIComponent(String(transactionId)));
            const localVarUrlObj &#x3D; url.parse(localVarPath, true);
            const localVarRequestOptions &#x3D; Object.assign({ method: &#x27;GET&#x27; }, options);
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration &amp;&amp; configuration.accessToken) {
				const localVarAccessTokenValue &#x3D; typeof configuration.accessToken &#x3D;&#x3D;&#x3D; &#x27;function&#x27;
					? configuration.accessToken(&quot;oauth2&quot;, [])
					: configuration.accessToken;
                localVarHeaderParameter[&quot;Authorization&quot;] &#x3D; &quot;Bearer &quot; + localVarAccessTokenValue;
            }

            localVarUrlObj.query &#x3D; Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers &#x3D; Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all transactions for **accountId**.
         * @summary List transactions for account
         * @param {string} accessId The **accessId** for which to retrieve transactions.
         * @param {string} accountId The **accountId** for which to retrieve transactions.
         * @param {number} [maxAge] Optional - defines maximum age (in seconds) of cached account data provided by the bank.          A \&amp;quot;maxAge\&amp;quot; of 3600 will not trigger an update of transactions, when last refresh has          been done 2000 seconds ago.
         * @param {number} [limit] Optional  limit the number of returned transactions
         * @param {number} [offset] Optional  skip the first **offset** transactions in result
         * @param {string} [from] Optional  only return transactions with booking date later than **from**; an ISO8601 Month(2014-11), Date (2014-11-17) or DateTime         (2014-11-17T12:00:00Z)
         * @param {string} [to] Optional  only return transactions with booking date prior or equal to **to**; an ISO8601 Date, Month or DateTime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactions(accessId: string, accountId: string, maxAge?: number, limit?: number, offset?: number, from?: string, to?: string, options: any &#x3D; {}): FetchArgs {
            // verify required parameter &#x27;accessId&#x27; is not null or undefined
            if (accessId &#x3D;&#x3D;&#x3D; null || accessId &#x3D;&#x3D;&#x3D; undefined) {
                throw new RequiredError(&#x27;accessId&#x27;,&#x27;Required parameter accessId was null or undefined when calling listTransactions.&#x27;);
            }
            // verify required parameter &#x27;accountId&#x27; is not null or undefined
            if (accountId &#x3D;&#x3D;&#x3D; null || accountId &#x3D;&#x3D;&#x3D; undefined) {
                throw new RequiredError(&#x27;accountId&#x27;,&#x27;Required parameter accountId was null or undefined when calling listTransactions.&#x27;);
            }
            const localVarPath &#x3D; &#x60;/accesses/{accessId}/accounts/{accountId}/transactions&#x60;
                .replace(&#x60;{${&quot;accessId&quot;}}&#x60;, encodeURIComponent(String(accessId)))
                .replace(&#x60;{${&quot;accountId&quot;}}&#x60;, encodeURIComponent(String(accountId)));
            const localVarUrlObj &#x3D; url.parse(localVarPath, true);
            const localVarRequestOptions &#x3D; Object.assign({ method: &#x27;GET&#x27; }, options);
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration &amp;&amp; configuration.accessToken) {
				const localVarAccessTokenValue &#x3D; typeof configuration.accessToken &#x3D;&#x3D;&#x3D; &#x27;function&#x27;
					? configuration.accessToken(&quot;oauth2&quot;, [])
					: configuration.accessToken;
                localVarHeaderParameter[&quot;Authorization&quot;] &#x3D; &quot;Bearer &quot; + localVarAccessTokenValue;
            }

            if (maxAge !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;max-age&#x27;] &#x3D; maxAge;
            }

            if (limit !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;limit&#x27;] &#x3D; limit;
            }

            if (offset !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;offset&#x27;] &#x3D; offset;
            }

            if (from !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;from&#x27;] &#x3D; from;
            }

            if (to !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;to&#x27;] &#x3D; to;
            }

            localVarUrlObj.query &#x3D; Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers &#x3D; Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all transactions for **patternId**.
         * @summary List transactions for pattern
         * @param {string} accessId The **accessId** for which to retrieve transactions
         * @param {string} accountId The **accountId** for which to retrieve transactions
         * @param {string} patternId The **patternId** for which to retrieve transactions
         * @param {number} [maxAge] Optional - defines maximum age (in seconds) of cached account data provided by the bank.       A \&amp;quot;maxAge\&amp;quot; of 3600 will not trigger an update of transactions, when last refresh has       been done 2000 seconds ago.
         * @param {number} [limit] Optional  limit the number of returned transactions
         * @param {number} [offset] Optional  skip the first **offset** transactions in result
         * @param {string} [from] Optional  only return transactions with a booking date later than **from**; an ISO8601 Month(2014-11), Date (2014-11-17) or DateTime         (2014-11-17T12:00:00Z)
         * @param {string} [to] Optional  only return transactions with a booking date prior or equal to **to**; an ISO8601 Date, Month or DateTime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactionsForPattern(accessId: string, accountId: string, patternId: string, maxAge?: number, limit?: number, offset?: number, from?: string, to?: string, options: any &#x3D; {}): FetchArgs {
            // verify required parameter &#x27;accessId&#x27; is not null or undefined
            if (accessId &#x3D;&#x3D;&#x3D; null || accessId &#x3D;&#x3D;&#x3D; undefined) {
                throw new RequiredError(&#x27;accessId&#x27;,&#x27;Required parameter accessId was null or undefined when calling listTransactionsForPattern.&#x27;);
            }
            // verify required parameter &#x27;accountId&#x27; is not null or undefined
            if (accountId &#x3D;&#x3D;&#x3D; null || accountId &#x3D;&#x3D;&#x3D; undefined) {
                throw new RequiredError(&#x27;accountId&#x27;,&#x27;Required parameter accountId was null or undefined when calling listTransactionsForPattern.&#x27;);
            }
            // verify required parameter &#x27;patternId&#x27; is not null or undefined
            if (patternId &#x3D;&#x3D;&#x3D; null || patternId &#x3D;&#x3D;&#x3D; undefined) {
                throw new RequiredError(&#x27;patternId&#x27;,&#x27;Required parameter patternId was null or undefined when calling listTransactionsForPattern.&#x27;);
            }
            const localVarPath &#x3D; &#x60;/accesses/{accessId}/accounts/{accountId}/transactionpatterns/{patternId}/transactions&#x60;
                .replace(&#x60;{${&quot;accessId&quot;}}&#x60;, encodeURIComponent(String(accessId)))
                .replace(&#x60;{${&quot;accountId&quot;}}&#x60;, encodeURIComponent(String(accountId)))
                .replace(&#x60;{${&quot;patternId&quot;}}&#x60;, encodeURIComponent(String(patternId)));
            const localVarUrlObj &#x3D; url.parse(localVarPath, true);
            const localVarRequestOptions &#x3D; Object.assign({ method: &#x27;GET&#x27; }, options);
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration &amp;&amp; configuration.accessToken) {
				const localVarAccessTokenValue &#x3D; typeof configuration.accessToken &#x3D;&#x3D;&#x3D; &#x27;function&#x27;
					? configuration.accessToken(&quot;oauth2&quot;, [])
					: configuration.accessToken;
                localVarHeaderParameter[&quot;Authorization&quot;] &#x3D; &quot;Bearer &quot; + localVarAccessTokenValue;
            }

            if (maxAge !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;max-age&#x27;] &#x3D; maxAge;
            }

            if (limit !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;limit&#x27;] &#x3D; limit;
            }

            if (offset !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;offset&#x27;] &#x3D; offset;
            }

            if (from !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;from&#x27;] &#x3D; from;
            }

            if (to !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;to&#x27;] &#x3D; to;
            }

            localVarUrlObj.query &#x3D; Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers &#x3D; Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
}</code>
                        </td>
                    </tr>

                <tr>
                    <td class="col-md-4">
                        <div class="io-description"><p>TransactionApi - fetch parameter creator</p>
</div>
                    </td>
                </tr>

            </tbody>
        </table>
        <table class="table table-sm table-bordered">
            <tbody>
                <tr>
                    <td class="col-md-4">
                        <a name="TransactionApiFp"></a>
                        <span class="name">
                            <b>
                            TransactionApiFp
                            </b>
                            <a href="#TransactionApiFp"><span class="icon ion-ios-link"></span></a>
                        </span>
                    </td>
                </tr>
                <tr>
                    <td class="col-md-4">
                        <code>TransactionApiFp:     <code></code>
</code>
                    </td>
                </tr>
                    <tr>
                        <td class="col-md-4">
                            <i>Default value : </i><code>function(configuration?: Configuration) {
    return {
        /**
         * Returns the transaction identified by **transactionId** in relationship with **accountId**.
         * @summary Get transaction
         * @param {string} accessId The **accessId** for the transaction to retrieve
         * @param {string} accountId The **accountId** for the transaction to retrieve
         * @param {string} transactionId The **transactionId** for the pattern to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransaction(accessId: string, accountId: string, transactionId: string, options?: any): (fetch?: FetchAPI, basePath?: string) &#x3D;&gt; Promise&lt;Transaction&gt; {
            const localVarFetchArgs &#x3D; TransactionApiFetchParamCreator(configuration).getTransaction(accessId, accountId, transactionId, options);
            return (fetch: FetchAPI &#x3D; portableFetch, basePath: string &#x3D; BASE_PATH) &#x3D;&gt; {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) &#x3D;&gt; {
                    if (response.status &gt;&#x3D; 200 &amp;&amp; response.status &lt; 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve all transactions for **accountId**.
         * @summary List transactions for account
         * @param {string} accessId The **accessId** for which to retrieve transactions.
         * @param {string} accountId The **accountId** for which to retrieve transactions.
         * @param {number} [maxAge] Optional - defines maximum age (in seconds) of cached account data provided by the bank.          A \&amp;quot;maxAge\&amp;quot; of 3600 will not trigger an update of transactions, when last refresh has          been done 2000 seconds ago.
         * @param {number} [limit] Optional  limit the number of returned transactions
         * @param {number} [offset] Optional  skip the first **offset** transactions in result
         * @param {string} [from] Optional  only return transactions with booking date later than **from**; an ISO8601 Month(2014-11), Date (2014-11-17) or DateTime         (2014-11-17T12:00:00Z)
         * @param {string} [to] Optional  only return transactions with booking date prior or equal to **to**; an ISO8601 Date, Month or DateTime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactions(accessId: string, accountId: string, maxAge?: number, limit?: number, offset?: number, from?: string, to?: string, options?: any): (fetch?: FetchAPI, basePath?: string) &#x3D;&gt; Promise&lt;Array&lt;Transaction&gt;&gt; {
            const localVarFetchArgs &#x3D; TransactionApiFetchParamCreator(configuration).listTransactions(accessId, accountId, maxAge, limit, offset, from, to, options);
            return (fetch: FetchAPI &#x3D; portableFetch, basePath: string &#x3D; BASE_PATH) &#x3D;&gt; {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) &#x3D;&gt; {
                    if (response.status &gt;&#x3D; 200 &amp;&amp; response.status &lt; 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve all transactions for **patternId**.
         * @summary List transactions for pattern
         * @param {string} accessId The **accessId** for which to retrieve transactions
         * @param {string} accountId The **accountId** for which to retrieve transactions
         * @param {string} patternId The **patternId** for which to retrieve transactions
         * @param {number} [maxAge] Optional - defines maximum age (in seconds) of cached account data provided by the bank.       A \&amp;quot;maxAge\&amp;quot; of 3600 will not trigger an update of transactions, when last refresh has       been done 2000 seconds ago.
         * @param {number} [limit] Optional  limit the number of returned transactions
         * @param {number} [offset] Optional  skip the first **offset** transactions in result
         * @param {string} [from] Optional  only return transactions with a booking date later than **from**; an ISO8601 Month(2014-11), Date (2014-11-17) or DateTime         (2014-11-17T12:00:00Z)
         * @param {string} [to] Optional  only return transactions with a booking date prior or equal to **to**; an ISO8601 Date, Month or DateTime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactionsForPattern(accessId: string, accountId: string, patternId: string, maxAge?: number, limit?: number, offset?: number, from?: string, to?: string, options?: any): (fetch?: FetchAPI, basePath?: string) &#x3D;&gt; Promise&lt;Array&lt;Transaction&gt;&gt; {
            const localVarFetchArgs &#x3D; TransactionApiFetchParamCreator(configuration).listTransactionsForPattern(accessId, accountId, patternId, maxAge, limit, offset, from, to, options);
            return (fetch: FetchAPI &#x3D; portableFetch, basePath: string &#x3D; BASE_PATH) &#x3D;&gt; {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) &#x3D;&gt; {
                    if (response.status &gt;&#x3D; 200 &amp;&amp; response.status &lt; 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
}</code>
                        </td>
                    </tr>

                <tr>
                    <td class="col-md-4">
                        <div class="io-description"><p>TransactionApi - functional programming interface</p>
</div>
                    </td>
                </tr>

            </tbody>
        </table>
        <table class="table table-sm table-bordered">
            <tbody>
                <tr>
                    <td class="col-md-4">
                        <a name="TransactionPatternApiFactory"></a>
                        <span class="name">
                            <b>
                            TransactionPatternApiFactory
                            </b>
                            <a href="#TransactionPatternApiFactory"><span class="icon ion-ios-link"></span></a>
                        </span>
                    </td>
                </tr>
                <tr>
                    <td class="col-md-4">
                        <code>TransactionPatternApiFactory:     <code></code>
</code>
                    </td>
                </tr>
                    <tr>
                        <td class="col-md-4">
                            <i>Default value : </i><code>function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Disabling the transaction pattern results in ignoring the pattern in the forecast. The transaction still exists and relations with transactions are not modified.
         * @summary Enable a transaction pattern
         * @param {string} accessId The **accessId** for which to activate the pattern
         * @param {string} accountId The **accountId** for which to activate the pattern
         * @param {string} patternId The **patternId** to (de)activate
         * @param {boolean} activated If &amp;#x60;true&amp;#x60;, the pattern will be used for forecast calculations;         &amp;#x60;false&amp;#x60; will be ignored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateTransactionPattern(accessId: string, accountId: string, patternId: string, activated: boolean, options?: any) {
            return TransactionPatternApiFp(configuration).activateTransactionPattern(accessId, accountId, patternId, activated, options)(fetch, basePath);
        },
        /**
         * Delete the transaction pattern identified by the **patternId**. All associated transactions will be updated to {{patternId &#x3D; null}}.
         * @summary Delete transaction pattern
         * @param {string} accessId The **accessId** for the transaction pattern to delete
         * @param {string} accountId The **accountId** for the transaction pattern to delete
         * @param {string} patternId The **patternId** to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTransactionPattern(accessId: string, accountId: string, patternId: string, options?: any) {
            return TransactionPatternApiFp(configuration).deleteTransactionPattern(accessId, accountId, patternId, options)(fetch, basePath);
        },
        /**
         * Returns the transaction pattern identified by **patternId** in relationship with  **accountId**.
         * @summary Get transaction pattern
         * @param {string} accessId The **accessId** for the pattern to retrieve
         * @param {string} accountId The **accoundId** for the pattern to retrieve
         * @param {string} patternId The **patternId** for the pattern to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionPattern(accessId: string, accountId: string, patternId: string, options?: any) {
            return TransactionPatternApiFp(configuration).getTransactionPattern(accessId, accountId, patternId, options)(fetch, basePath);
        },
        /**
         * Returns all transaction pattern for **accountId**. Transaction patterns are recurring transactions automatically identified by the server or manually created via [create transaction pattern](#!/Transaction_pattern/postTransactionPattern).
         * @summary List transaction patterns for account
         * @param {string} accessId The **accessId** for which to retrieve transaction patterns
         * @param {string} accountId The **accountId** for which to retrieve transaction patterns
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactionPatterns(accessId: string, accountId: string, options?: any) {
            return TransactionPatternApiFp(configuration).listTransactionPatterns(accessId, accountId, options)(fetch, basePath);
        },
        /**
         * Create a new pattern for an **accountId**. The **cycle** can be one of &#x60;MONTHLY&#x60;, &#x60;QUARTERLY&#x60;, &#x60;SEMI_ANNUALLY&#x60; or &#x60;ANNUALLY&#x60;. The **day** can be between &#x60;1&#x60; and &#x60;366&#x60;, depending on **cycle**:  | cycle | day range | example | | --- | --- | --- | | &#x60;MONTHLY&#x60; | &#x60;1&#x60;-&#x60;31&#x60;  | every 29th of the month &#x3D;&gt; &#x60;29&#x60; | | &#x60;QUARTERLY&#x60; | &#x60;1&#x60;-&#x60;92&#x60;  | 23rd of February (23rd of May, etc.) &#x3D;&gt; &#x60;54&#x60; (31 [complete first month] + 23 [days in second month]) | | &#x60;SEMI_ANNUALLY&#x60; | &#x60;1&#x60;-&#x60;184&#x60; | 1st of May and 1st of November &#x3D;&gt; &#x60;121&#x60; (for first half of year: 31 + 28 + 31 + 30 + 1) | | &#x60;ANNUALLY&#x60; | &#x60;1&#x60;-&#x60;366&#x60; | 24th of December &#x3D;&gt; &#x60;358&#x60; |  If a similar pattern already exists, you will receive an HTTP status code 409.
         * @summary Create a new pattern
         * @param {string} accessId The **accessId** to which the new created pattern is associated with
         * @param {string} accountId The **accountId** to which the new created pattern is associated with
         * @param {TransactionPattern} transactionPatternDto The transaction pattern to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTransactionPattern(accessId: string, accountId: string, transactionPatternDto: TransactionPattern, options?: any) {
            return TransactionPatternApiFp(configuration).postTransactionPattern(accessId, accountId, transactionPatternDto, options)(fetch, basePath);
        },
    };
}</code>
                        </td>
                    </tr>

                <tr>
                    <td class="col-md-4">
                        <div class="io-description"><p>TransactionPatternApi - factory interface</p>
</div>
                    </td>
                </tr>

            </tbody>
        </table>
        <table class="table table-sm table-bordered">
            <tbody>
                <tr>
                    <td class="col-md-4">
                        <a name="TransactionPatternApiFetchParamCreator"></a>
                        <span class="name">
                            <b>
                            TransactionPatternApiFetchParamCreator
                            </b>
                            <a href="#TransactionPatternApiFetchParamCreator"><span class="icon ion-ios-link"></span></a>
                        </span>
                    </td>
                </tr>
                <tr>
                    <td class="col-md-4">
                        <code>TransactionPatternApiFetchParamCreator:     <code></code>
</code>
                    </td>
                </tr>
                    <tr>
                        <td class="col-md-4">
                            <i>Default value : </i><code>function (configuration?: Configuration) {
    return {
        /**
         * Disabling the transaction pattern results in ignoring the pattern in the forecast. The transaction still exists and relations with transactions are not modified.
         * @summary Enable a transaction pattern
         * @param {string} accessId The **accessId** for which to activate the pattern
         * @param {string} accountId The **accountId** for which to activate the pattern
         * @param {string} patternId The **patternId** to (de)activate
         * @param {boolean} activated If &amp;#x60;true&amp;#x60;, the pattern will be used for forecast calculations;         &amp;#x60;false&amp;#x60; will be ignored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateTransactionPattern(accessId: string, accountId: string, patternId: string, activated: boolean, options: any &#x3D; {}): FetchArgs {
            // verify required parameter &#x27;accessId&#x27; is not null or undefined
            if (accessId &#x3D;&#x3D;&#x3D; null || accessId &#x3D;&#x3D;&#x3D; undefined) {
                throw new RequiredError(&#x27;accessId&#x27;,&#x27;Required parameter accessId was null or undefined when calling activateTransactionPattern.&#x27;);
            }
            // verify required parameter &#x27;accountId&#x27; is not null or undefined
            if (accountId &#x3D;&#x3D;&#x3D; null || accountId &#x3D;&#x3D;&#x3D; undefined) {
                throw new RequiredError(&#x27;accountId&#x27;,&#x27;Required parameter accountId was null or undefined when calling activateTransactionPattern.&#x27;);
            }
            // verify required parameter &#x27;patternId&#x27; is not null or undefined
            if (patternId &#x3D;&#x3D;&#x3D; null || patternId &#x3D;&#x3D;&#x3D; undefined) {
                throw new RequiredError(&#x27;patternId&#x27;,&#x27;Required parameter patternId was null or undefined when calling activateTransactionPattern.&#x27;);
            }
            // verify required parameter &#x27;activated&#x27; is not null or undefined
            if (activated &#x3D;&#x3D;&#x3D; null || activated &#x3D;&#x3D;&#x3D; undefined) {
                throw new RequiredError(&#x27;activated&#x27;,&#x27;Required parameter activated was null or undefined when calling activateTransactionPattern.&#x27;);
            }
            const localVarPath &#x3D; &#x60;/accesses/{accessId}/accounts/{accountId}/transactionpatterns/{patternId}/active/{activated}&#x60;
                .replace(&#x60;{${&quot;accessId&quot;}}&#x60;, encodeURIComponent(String(accessId)))
                .replace(&#x60;{${&quot;accountId&quot;}}&#x60;, encodeURIComponent(String(accountId)))
                .replace(&#x60;{${&quot;patternId&quot;}}&#x60;, encodeURIComponent(String(patternId)))
                .replace(&#x60;{${&quot;activated&quot;}}&#x60;, encodeURIComponent(String(activated)));
            const localVarUrlObj &#x3D; url.parse(localVarPath, true);
            const localVarRequestOptions &#x3D; Object.assign({ method: &#x27;PUT&#x27; }, options);
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration &amp;&amp; configuration.accessToken) {
				const localVarAccessTokenValue &#x3D; typeof configuration.accessToken &#x3D;&#x3D;&#x3D; &#x27;function&#x27;
					? configuration.accessToken(&quot;oauth2&quot;, [])
					: configuration.accessToken;
                localVarHeaderParameter[&quot;Authorization&quot;] &#x3D; &quot;Bearer &quot; + localVarAccessTokenValue;
            }

            localVarUrlObj.query &#x3D; Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers &#x3D; Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete the transaction pattern identified by the **patternId**. All associated transactions will be updated to {{patternId &#x3D; null}}.
         * @summary Delete transaction pattern
         * @param {string} accessId The **accessId** for the transaction pattern to delete
         * @param {string} accountId The **accountId** for the transaction pattern to delete
         * @param {string} patternId The **patternId** to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTransactionPattern(accessId: string, accountId: string, patternId: string, options: any &#x3D; {}): FetchArgs {
            // verify required parameter &#x27;accessId&#x27; is not null or undefined
            if (accessId &#x3D;&#x3D;&#x3D; null || accessId &#x3D;&#x3D;&#x3D; undefined) {
                throw new RequiredError(&#x27;accessId&#x27;,&#x27;Required parameter accessId was null or undefined when calling deleteTransactionPattern.&#x27;);
            }
            // verify required parameter &#x27;accountId&#x27; is not null or undefined
            if (accountId &#x3D;&#x3D;&#x3D; null || accountId &#x3D;&#x3D;&#x3D; undefined) {
                throw new RequiredError(&#x27;accountId&#x27;,&#x27;Required parameter accountId was null or undefined when calling deleteTransactionPattern.&#x27;);
            }
            // verify required parameter &#x27;patternId&#x27; is not null or undefined
            if (patternId &#x3D;&#x3D;&#x3D; null || patternId &#x3D;&#x3D;&#x3D; undefined) {
                throw new RequiredError(&#x27;patternId&#x27;,&#x27;Required parameter patternId was null or undefined when calling deleteTransactionPattern.&#x27;);
            }
            const localVarPath &#x3D; &#x60;/accesses/{accessId}/accounts/{accountId}/transactionpatterns/{patternId}&#x60;
                .replace(&#x60;{${&quot;accessId&quot;}}&#x60;, encodeURIComponent(String(accessId)))
                .replace(&#x60;{${&quot;accountId&quot;}}&#x60;, encodeURIComponent(String(accountId)))
                .replace(&#x60;{${&quot;patternId&quot;}}&#x60;, encodeURIComponent(String(patternId)));
            const localVarUrlObj &#x3D; url.parse(localVarPath, true);
            const localVarRequestOptions &#x3D; Object.assign({ method: &#x27;DELETE&#x27; }, options);
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration &amp;&amp; configuration.accessToken) {
				const localVarAccessTokenValue &#x3D; typeof configuration.accessToken &#x3D;&#x3D;&#x3D; &#x27;function&#x27;
					? configuration.accessToken(&quot;oauth2&quot;, [])
					: configuration.accessToken;
                localVarHeaderParameter[&quot;Authorization&quot;] &#x3D; &quot;Bearer &quot; + localVarAccessTokenValue;
            }

            localVarUrlObj.query &#x3D; Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers &#x3D; Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the transaction pattern identified by **patternId** in relationship with  **accountId**.
         * @summary Get transaction pattern
         * @param {string} accessId The **accessId** for the pattern to retrieve
         * @param {string} accountId The **accoundId** for the pattern to retrieve
         * @param {string} patternId The **patternId** for the pattern to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionPattern(accessId: string, accountId: string, patternId: string, options: any &#x3D; {}): FetchArgs {
            // verify required parameter &#x27;accessId&#x27; is not null or undefined
            if (accessId &#x3D;&#x3D;&#x3D; null || accessId &#x3D;&#x3D;&#x3D; undefined) {
                throw new RequiredError(&#x27;accessId&#x27;,&#x27;Required parameter accessId was null or undefined when calling getTransactionPattern.&#x27;);
            }
            // verify required parameter &#x27;accountId&#x27; is not null or undefined
            if (accountId &#x3D;&#x3D;&#x3D; null || accountId &#x3D;&#x3D;&#x3D; undefined) {
                throw new RequiredError(&#x27;accountId&#x27;,&#x27;Required parameter accountId was null or undefined when calling getTransactionPattern.&#x27;);
            }
            // verify required parameter &#x27;patternId&#x27; is not null or undefined
            if (patternId &#x3D;&#x3D;&#x3D; null || patternId &#x3D;&#x3D;&#x3D; undefined) {
                throw new RequiredError(&#x27;patternId&#x27;,&#x27;Required parameter patternId was null or undefined when calling getTransactionPattern.&#x27;);
            }
            const localVarPath &#x3D; &#x60;/accesses/{accessId}/accounts/{accountId}/transactionpatterns/{patternId}&#x60;
                .replace(&#x60;{${&quot;accessId&quot;}}&#x60;, encodeURIComponent(String(accessId)))
                .replace(&#x60;{${&quot;accountId&quot;}}&#x60;, encodeURIComponent(String(accountId)))
                .replace(&#x60;{${&quot;patternId&quot;}}&#x60;, encodeURIComponent(String(patternId)));
            const localVarUrlObj &#x3D; url.parse(localVarPath, true);
            const localVarRequestOptions &#x3D; Object.assign({ method: &#x27;GET&#x27; }, options);
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration &amp;&amp; configuration.accessToken) {
				const localVarAccessTokenValue &#x3D; typeof configuration.accessToken &#x3D;&#x3D;&#x3D; &#x27;function&#x27;
					? configuration.accessToken(&quot;oauth2&quot;, [])
					: configuration.accessToken;
                localVarHeaderParameter[&quot;Authorization&quot;] &#x3D; &quot;Bearer &quot; + localVarAccessTokenValue;
            }

            localVarUrlObj.query &#x3D; Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers &#x3D; Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all transaction pattern for **accountId**. Transaction patterns are recurring transactions automatically identified by the server or manually created via [create transaction pattern](#!/Transaction_pattern/postTransactionPattern).
         * @summary List transaction patterns for account
         * @param {string} accessId The **accessId** for which to retrieve transaction patterns
         * @param {string} accountId The **accountId** for which to retrieve transaction patterns
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactionPatterns(accessId: string, accountId: string, options: any &#x3D; {}): FetchArgs {
            // verify required parameter &#x27;accessId&#x27; is not null or undefined
            if (accessId &#x3D;&#x3D;&#x3D; null || accessId &#x3D;&#x3D;&#x3D; undefined) {
                throw new RequiredError(&#x27;accessId&#x27;,&#x27;Required parameter accessId was null or undefined when calling listTransactionPatterns.&#x27;);
            }
            // verify required parameter &#x27;accountId&#x27; is not null or undefined
            if (accountId &#x3D;&#x3D;&#x3D; null || accountId &#x3D;&#x3D;&#x3D; undefined) {
                throw new RequiredError(&#x27;accountId&#x27;,&#x27;Required parameter accountId was null or undefined when calling listTransactionPatterns.&#x27;);
            }
            const localVarPath &#x3D; &#x60;/accesses/{accessId}/accounts/{accountId}/transactionpatterns&#x60;
                .replace(&#x60;{${&quot;accessId&quot;}}&#x60;, encodeURIComponent(String(accessId)))
                .replace(&#x60;{${&quot;accountId&quot;}}&#x60;, encodeURIComponent(String(accountId)));
            const localVarUrlObj &#x3D; url.parse(localVarPath, true);
            const localVarRequestOptions &#x3D; Object.assign({ method: &#x27;GET&#x27; }, options);
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration &amp;&amp; configuration.accessToken) {
				const localVarAccessTokenValue &#x3D; typeof configuration.accessToken &#x3D;&#x3D;&#x3D; &#x27;function&#x27;
					? configuration.accessToken(&quot;oauth2&quot;, [])
					: configuration.accessToken;
                localVarHeaderParameter[&quot;Authorization&quot;] &#x3D; &quot;Bearer &quot; + localVarAccessTokenValue;
            }

            localVarUrlObj.query &#x3D; Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers &#x3D; Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new pattern for an **accountId**. The **cycle** can be one of &#x60;MONTHLY&#x60;, &#x60;QUARTERLY&#x60;, &#x60;SEMI_ANNUALLY&#x60; or &#x60;ANNUALLY&#x60;. The **day** can be between &#x60;1&#x60; and &#x60;366&#x60;, depending on **cycle**:  | cycle | day range | example | | --- | --- | --- | | &#x60;MONTHLY&#x60; | &#x60;1&#x60;-&#x60;31&#x60;  | every 29th of the month &#x3D;&gt; &#x60;29&#x60; | | &#x60;QUARTERLY&#x60; | &#x60;1&#x60;-&#x60;92&#x60;  | 23rd of February (23rd of May, etc.) &#x3D;&gt; &#x60;54&#x60; (31 [complete first month] + 23 [days in second month]) | | &#x60;SEMI_ANNUALLY&#x60; | &#x60;1&#x60;-&#x60;184&#x60; | 1st of May and 1st of November &#x3D;&gt; &#x60;121&#x60; (for first half of year: 31 + 28 + 31 + 30 + 1) | | &#x60;ANNUALLY&#x60; | &#x60;1&#x60;-&#x60;366&#x60; | 24th of December &#x3D;&gt; &#x60;358&#x60; |  If a similar pattern already exists, you will receive an HTTP status code 409.
         * @summary Create a new pattern
         * @param {string} accessId The **accessId** to which the new created pattern is associated with
         * @param {string} accountId The **accountId** to which the new created pattern is associated with
         * @param {TransactionPattern} transactionPatternDto The transaction pattern to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTransactionPattern(accessId: string, accountId: string, transactionPatternDto: TransactionPattern, options: any &#x3D; {}): FetchArgs {
            // verify required parameter &#x27;accessId&#x27; is not null or undefined
            if (accessId &#x3D;&#x3D;&#x3D; null || accessId &#x3D;&#x3D;&#x3D; undefined) {
                throw new RequiredError(&#x27;accessId&#x27;,&#x27;Required parameter accessId was null or undefined when calling postTransactionPattern.&#x27;);
            }
            // verify required parameter &#x27;accountId&#x27; is not null or undefined
            if (accountId &#x3D;&#x3D;&#x3D; null || accountId &#x3D;&#x3D;&#x3D; undefined) {
                throw new RequiredError(&#x27;accountId&#x27;,&#x27;Required parameter accountId was null or undefined when calling postTransactionPattern.&#x27;);
            }
            // verify required parameter &#x27;transactionPatternDto&#x27; is not null or undefined
            if (transactionPatternDto &#x3D;&#x3D;&#x3D; null || transactionPatternDto &#x3D;&#x3D;&#x3D; undefined) {
                throw new RequiredError(&#x27;transactionPatternDto&#x27;,&#x27;Required parameter transactionPatternDto was null or undefined when calling postTransactionPattern.&#x27;);
            }
            const localVarPath &#x3D; &#x60;/accesses/{accessId}/accounts/{accountId}/transactionpatterns&#x60;
                .replace(&#x60;{${&quot;accessId&quot;}}&#x60;, encodeURIComponent(String(accessId)))
                .replace(&#x60;{${&quot;accountId&quot;}}&#x60;, encodeURIComponent(String(accountId)));
            const localVarUrlObj &#x3D; url.parse(localVarPath, true);
            const localVarRequestOptions &#x3D; Object.assign({ method: &#x27;POST&#x27; }, options);
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration &amp;&amp; configuration.accessToken) {
				const localVarAccessTokenValue &#x3D; typeof configuration.accessToken &#x3D;&#x3D;&#x3D; &#x27;function&#x27;
					? configuration.accessToken(&quot;oauth2&quot;, [])
					: configuration.accessToken;
                localVarHeaderParameter[&quot;Authorization&quot;] &#x3D; &quot;Bearer &quot; + localVarAccessTokenValue;
            }

            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            localVarUrlObj.query &#x3D; Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers &#x3D; Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization &#x3D; (&lt;any&gt;&quot;TransactionPattern&quot; !&#x3D;&#x3D; &quot;string&quot;) || localVarRequestOptions.headers[&#x27;Content-Type&#x27;] &#x3D;&#x3D;&#x3D; &#x27;application/json&#x27;;
            localVarRequestOptions.body &#x3D;  needsSerialization ? JSON.stringify(transactionPatternDto || {}) : (transactionPatternDto || &quot;&quot;);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
}</code>
                        </td>
                    </tr>

                <tr>
                    <td class="col-md-4">
                        <div class="io-description"><p>TransactionPatternApi - fetch parameter creator</p>
</div>
                    </td>
                </tr>

            </tbody>
        </table>
        <table class="table table-sm table-bordered">
            <tbody>
                <tr>
                    <td class="col-md-4">
                        <a name="TransactionPatternApiFp"></a>
                        <span class="name">
                            <b>
                            TransactionPatternApiFp
                            </b>
                            <a href="#TransactionPatternApiFp"><span class="icon ion-ios-link"></span></a>
                        </span>
                    </td>
                </tr>
                <tr>
                    <td class="col-md-4">
                        <code>TransactionPatternApiFp:     <code></code>
</code>
                    </td>
                </tr>
                    <tr>
                        <td class="col-md-4">
                            <i>Default value : </i><code>function(configuration?: Configuration) {
    return {
        /**
         * Disabling the transaction pattern results in ignoring the pattern in the forecast. The transaction still exists and relations with transactions are not modified.
         * @summary Enable a transaction pattern
         * @param {string} accessId The **accessId** for which to activate the pattern
         * @param {string} accountId The **accountId** for which to activate the pattern
         * @param {string} patternId The **patternId** to (de)activate
         * @param {boolean} activated If &amp;#x60;true&amp;#x60;, the pattern will be used for forecast calculations;         &amp;#x60;false&amp;#x60; will be ignored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateTransactionPattern(accessId: string, accountId: string, patternId: string, activated: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) &#x3D;&gt; Promise&lt;TransactionPattern&gt; {
            const localVarFetchArgs &#x3D; TransactionPatternApiFetchParamCreator(configuration).activateTransactionPattern(accessId, accountId, patternId, activated, options);
            return (fetch: FetchAPI &#x3D; portableFetch, basePath: string &#x3D; BASE_PATH) &#x3D;&gt; {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) &#x3D;&gt; {
                    if (response.status &gt;&#x3D; 200 &amp;&amp; response.status &lt; 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete the transaction pattern identified by the **patternId**. All associated transactions will be updated to {{patternId &#x3D; null}}.
         * @summary Delete transaction pattern
         * @param {string} accessId The **accessId** for the transaction pattern to delete
         * @param {string} accountId The **accountId** for the transaction pattern to delete
         * @param {string} patternId The **patternId** to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTransactionPattern(accessId: string, accountId: string, patternId: string, options?: any): (fetch?: FetchAPI, basePath?: string) &#x3D;&gt; Promise&lt;Response&gt; {
            const localVarFetchArgs &#x3D; TransactionPatternApiFetchParamCreator(configuration).deleteTransactionPattern(accessId, accountId, patternId, options);
            return (fetch: FetchAPI &#x3D; portableFetch, basePath: string &#x3D; BASE_PATH) &#x3D;&gt; {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) &#x3D;&gt; {
                    if (response.status &gt;&#x3D; 200 &amp;&amp; response.status &lt; 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns the transaction pattern identified by **patternId** in relationship with  **accountId**.
         * @summary Get transaction pattern
         * @param {string} accessId The **accessId** for the pattern to retrieve
         * @param {string} accountId The **accoundId** for the pattern to retrieve
         * @param {string} patternId The **patternId** for the pattern to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionPattern(accessId: string, accountId: string, patternId: string, options?: any): (fetch?: FetchAPI, basePath?: string) &#x3D;&gt; Promise&lt;TransactionPattern&gt; {
            const localVarFetchArgs &#x3D; TransactionPatternApiFetchParamCreator(configuration).getTransactionPattern(accessId, accountId, patternId, options);
            return (fetch: FetchAPI &#x3D; portableFetch, basePath: string &#x3D; BASE_PATH) &#x3D;&gt; {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) &#x3D;&gt; {
                    if (response.status &gt;&#x3D; 200 &amp;&amp; response.status &lt; 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns all transaction pattern for **accountId**. Transaction patterns are recurring transactions automatically identified by the server or manually created via [create transaction pattern](#!/Transaction_pattern/postTransactionPattern).
         * @summary List transaction patterns for account
         * @param {string} accessId The **accessId** for which to retrieve transaction patterns
         * @param {string} accountId The **accountId** for which to retrieve transaction patterns
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactionPatterns(accessId: string, accountId: string, options?: any): (fetch?: FetchAPI, basePath?: string) &#x3D;&gt; Promise&lt;Array&lt;TransactionPattern&gt;&gt; {
            const localVarFetchArgs &#x3D; TransactionPatternApiFetchParamCreator(configuration).listTransactionPatterns(accessId, accountId, options);
            return (fetch: FetchAPI &#x3D; portableFetch, basePath: string &#x3D; BASE_PATH) &#x3D;&gt; {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) &#x3D;&gt; {
                    if (response.status &gt;&#x3D; 200 &amp;&amp; response.status &lt; 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create a new pattern for an **accountId**. The **cycle** can be one of &#x60;MONTHLY&#x60;, &#x60;QUARTERLY&#x60;, &#x60;SEMI_ANNUALLY&#x60; or &#x60;ANNUALLY&#x60;. The **day** can be between &#x60;1&#x60; and &#x60;366&#x60;, depending on **cycle**:  | cycle | day range | example | | --- | --- | --- | | &#x60;MONTHLY&#x60; | &#x60;1&#x60;-&#x60;31&#x60;  | every 29th of the month &#x3D;&gt; &#x60;29&#x60; | | &#x60;QUARTERLY&#x60; | &#x60;1&#x60;-&#x60;92&#x60;  | 23rd of February (23rd of May, etc.) &#x3D;&gt; &#x60;54&#x60; (31 [complete first month] + 23 [days in second month]) | | &#x60;SEMI_ANNUALLY&#x60; | &#x60;1&#x60;-&#x60;184&#x60; | 1st of May and 1st of November &#x3D;&gt; &#x60;121&#x60; (for first half of year: 31 + 28 + 31 + 30 + 1) | | &#x60;ANNUALLY&#x60; | &#x60;1&#x60;-&#x60;366&#x60; | 24th of December &#x3D;&gt; &#x60;358&#x60; |  If a similar pattern already exists, you will receive an HTTP status code 409.
         * @summary Create a new pattern
         * @param {string} accessId The **accessId** to which the new created pattern is associated with
         * @param {string} accountId The **accountId** to which the new created pattern is associated with
         * @param {TransactionPattern} transactionPatternDto The transaction pattern to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTransactionPattern(accessId: string, accountId: string, transactionPatternDto: TransactionPattern, options?: any): (fetch?: FetchAPI, basePath?: string) &#x3D;&gt; Promise&lt;TransactionPattern&gt; {
            const localVarFetchArgs &#x3D; TransactionPatternApiFetchParamCreator(configuration).postTransactionPattern(accessId, accountId, transactionPatternDto, options);
            return (fetch: FetchAPI &#x3D; portableFetch, basePath: string &#x3D; BASE_PATH) &#x3D;&gt; {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) &#x3D;&gt; {
                    if (response.status &gt;&#x3D; 200 &amp;&amp; response.status &lt; 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
}</code>
                        </td>
                    </tr>

                <tr>
                    <td class="col-md-4">
                        <div class="io-description"><p>TransactionPatternApi - functional programming interface</p>
</div>
                    </td>
                </tr>

            </tbody>
        </table>
        <table class="table table-sm table-bordered">
            <tbody>
                <tr>
                    <td class="col-md-4">
                        <a name="TransactionSummaryApiFactory"></a>
                        <span class="name">
                            <b>
                            TransactionSummaryApiFactory
                            </b>
                            <a href="#TransactionSummaryApiFactory"><span class="icon ion-ios-link"></span></a>
                        </span>
                    </td>
                </tr>
                <tr>
                    <td class="col-md-4">
                        <code>TransactionSummaryApiFactory:     <code></code>
</code>
                    </td>
                </tr>
                    <tr>
                        <td class="col-md-4">
                            <i>Default value : </i><code>function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Retrieve account summaries and provide a sum for incoming and outgoing transactions.
         * @summary List account summaries
         * @param {string} accessId The **accessId** for which to list the summaries
         * @param {string} accountId The **accountId** for which to list the summaries
         * @param {number} [limit] Optional  limit the number of returned summary entries
         * @param {number} [offset] Optional  skip the first **offset** summary entries in the result
         * @param {string} [from] Optional  only return summary entries later than **from**; an         ISO8601 Date (2014-11-17)
         * @param {string} [to] Optional  only return summary entries prior or equal to         **to**; an ISO8601 Date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSummary(accessId: string, accountId: string, limit?: number, offset?: number, from?: string, to?: string, options?: any) {
            return TransactionSummaryApiFp(configuration).listSummary(accessId, accountId, limit, offset, from, to, options)(fetch, basePath);
        },
    };
}</code>
                        </td>
                    </tr>

                <tr>
                    <td class="col-md-4">
                        <div class="io-description"><p>TransactionSummaryApi - factory interface</p>
</div>
                    </td>
                </tr>

            </tbody>
        </table>
        <table class="table table-sm table-bordered">
            <tbody>
                <tr>
                    <td class="col-md-4">
                        <a name="TransactionSummaryApiFetchParamCreator"></a>
                        <span class="name">
                            <b>
                            TransactionSummaryApiFetchParamCreator
                            </b>
                            <a href="#TransactionSummaryApiFetchParamCreator"><span class="icon ion-ios-link"></span></a>
                        </span>
                    </td>
                </tr>
                <tr>
                    <td class="col-md-4">
                        <code>TransactionSummaryApiFetchParamCreator:     <code></code>
</code>
                    </td>
                </tr>
                    <tr>
                        <td class="col-md-4">
                            <i>Default value : </i><code>function (configuration?: Configuration) {
    return {
        /**
         * Retrieve account summaries and provide a sum for incoming and outgoing transactions.
         * @summary List account summaries
         * @param {string} accessId The **accessId** for which to list the summaries
         * @param {string} accountId The **accountId** for which to list the summaries
         * @param {number} [limit] Optional  limit the number of returned summary entries
         * @param {number} [offset] Optional  skip the first **offset** summary entries in the result
         * @param {string} [from] Optional  only return summary entries later than **from**; an         ISO8601 Date (2014-11-17)
         * @param {string} [to] Optional  only return summary entries prior or equal to         **to**; an ISO8601 Date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSummary(accessId: string, accountId: string, limit?: number, offset?: number, from?: string, to?: string, options: any &#x3D; {}): FetchArgs {
            // verify required parameter &#x27;accessId&#x27; is not null or undefined
            if (accessId &#x3D;&#x3D;&#x3D; null || accessId &#x3D;&#x3D;&#x3D; undefined) {
                throw new RequiredError(&#x27;accessId&#x27;,&#x27;Required parameter accessId was null or undefined when calling listSummary.&#x27;);
            }
            // verify required parameter &#x27;accountId&#x27; is not null or undefined
            if (accountId &#x3D;&#x3D;&#x3D; null || accountId &#x3D;&#x3D;&#x3D; undefined) {
                throw new RequiredError(&#x27;accountId&#x27;,&#x27;Required parameter accountId was null or undefined when calling listSummary.&#x27;);
            }
            const localVarPath &#x3D; &#x60;/accesses/{accessId}/accounts/{accountId}/transactionsummaries&#x60;
                .replace(&#x60;{${&quot;accessId&quot;}}&#x60;, encodeURIComponent(String(accessId)))
                .replace(&#x60;{${&quot;accountId&quot;}}&#x60;, encodeURIComponent(String(accountId)));
            const localVarUrlObj &#x3D; url.parse(localVarPath, true);
            const localVarRequestOptions &#x3D; Object.assign({ method: &#x27;GET&#x27; }, options);
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration &amp;&amp; configuration.accessToken) {
				const localVarAccessTokenValue &#x3D; typeof configuration.accessToken &#x3D;&#x3D;&#x3D; &#x27;function&#x27;
					? configuration.accessToken(&quot;oauth2&quot;, [])
					: configuration.accessToken;
                localVarHeaderParameter[&quot;Authorization&quot;] &#x3D; &quot;Bearer &quot; + localVarAccessTokenValue;
            }

            if (limit !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;limit&#x27;] &#x3D; limit;
            }

            if (offset !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;offset&#x27;] &#x3D; offset;
            }

            if (from !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;from&#x27;] &#x3D; from;
            }

            if (to !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;to&#x27;] &#x3D; to;
            }

            localVarUrlObj.query &#x3D; Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers &#x3D; Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
}</code>
                        </td>
                    </tr>

                <tr>
                    <td class="col-md-4">
                        <div class="io-description"><p>TransactionSummaryApi - fetch parameter creator</p>
</div>
                    </td>
                </tr>

            </tbody>
        </table>
        <table class="table table-sm table-bordered">
            <tbody>
                <tr>
                    <td class="col-md-4">
                        <a name="TransactionSummaryApiFp"></a>
                        <span class="name">
                            <b>
                            TransactionSummaryApiFp
                            </b>
                            <a href="#TransactionSummaryApiFp"><span class="icon ion-ios-link"></span></a>
                        </span>
                    </td>
                </tr>
                <tr>
                    <td class="col-md-4">
                        <code>TransactionSummaryApiFp:     <code></code>
</code>
                    </td>
                </tr>
                    <tr>
                        <td class="col-md-4">
                            <i>Default value : </i><code>function(configuration?: Configuration) {
    return {
        /**
         * Retrieve account summaries and provide a sum for incoming and outgoing transactions.
         * @summary List account summaries
         * @param {string} accessId The **accessId** for which to list the summaries
         * @param {string} accountId The **accountId** for which to list the summaries
         * @param {number} [limit] Optional  limit the number of returned summary entries
         * @param {number} [offset] Optional  skip the first **offset** summary entries in the result
         * @param {string} [from] Optional  only return summary entries later than **from**; an         ISO8601 Date (2014-11-17)
         * @param {string} [to] Optional  only return summary entries prior or equal to         **to**; an ISO8601 Date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSummary(accessId: string, accountId: string, limit?: number, offset?: number, from?: string, to?: string, options?: any): (fetch?: FetchAPI, basePath?: string) &#x3D;&gt; Promise&lt;Array&lt;MonthlySummary&gt;&gt; {
            const localVarFetchArgs &#x3D; TransactionSummaryApiFetchParamCreator(configuration).listSummary(accessId, accountId, limit, offset, from, to, options);
            return (fetch: FetchAPI &#x3D; portableFetch, basePath: string &#x3D; BASE_PATH) &#x3D;&gt; {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) &#x3D;&gt; {
                    if (response.status &gt;&#x3D; 200 &amp;&amp; response.status &lt; 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
}</code>
                        </td>
                    </tr>

                <tr>
                    <td class="col-md-4">
                        <div class="io-description"><p>TransactionSummaryApi - functional programming interface</p>
</div>
                    </td>
                </tr>

            </tbody>
        </table>
        <table class="table table-sm table-bordered">
            <tbody>
                <tr>
                    <td class="col-md-4">
                        <a name="TransferApiFactory"></a>
                        <span class="name">
                            <b>
                            TransferApiFactory
                            </b>
                            <a href="#TransferApiFactory"><span class="icon ion-ios-link"></span></a>
                        </span>
                    </td>
                </tr>
                <tr>
                    <td class="col-md-4">
                        <code>TransferApiFactory:     <code></code>
</code>
                    </td>
                </tr>
                    <tr>
                        <td class="col-md-4">
                            <i>Default value : </i><code>function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * The transfer represents a money  transfer from the account identified by its id to another bank account.  **Please note:** Exception from the norm. This POST request will not return  the two header fields X-Id and Location. Also, the returned JSON document  does not represent the transfer entity, but a temporary placeholder.  The transfer is processed asynchronous and needs a message URL zu be configured  to report back the tan challenge and when it is finished.
         * @summary Create a new transfer
         * @param {string} accessId 
         * @param {string} accountId The **id** for the account.
         * @param {Transfer} transfer transfer to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTransfer(accessId: string, accountId: string, transfer: Transfer, options?: any) {
            return TransferApiFp(configuration).postTransfer(accessId, accountId, transfer, options)(fetch, basePath);
        },
    };
}</code>
                        </td>
                    </tr>

                <tr>
                    <td class="col-md-4">
                        <div class="io-description"><p>TransferApi - factory interface</p>
</div>
                    </td>
                </tr>

            </tbody>
        </table>
        <table class="table table-sm table-bordered">
            <tbody>
                <tr>
                    <td class="col-md-4">
                        <a name="TransferApiFetchParamCreator"></a>
                        <span class="name">
                            <b>
                            TransferApiFetchParamCreator
                            </b>
                            <a href="#TransferApiFetchParamCreator"><span class="icon ion-ios-link"></span></a>
                        </span>
                    </td>
                </tr>
                <tr>
                    <td class="col-md-4">
                        <code>TransferApiFetchParamCreator:     <code></code>
</code>
                    </td>
                </tr>
                    <tr>
                        <td class="col-md-4">
                            <i>Default value : </i><code>function (configuration?: Configuration) {
    return {
        /**
         * The transfer represents a money  transfer from the account identified by its id to another bank account.  **Please note:** Exception from the norm. This POST request will not return  the two header fields X-Id and Location. Also, the returned JSON document  does not represent the transfer entity, but a temporary placeholder.  The transfer is processed asynchronous and needs a message URL zu be configured  to report back the tan challenge and when it is finished.
         * @summary Create a new transfer
         * @param {string} accessId 
         * @param {string} accountId The **id** for the account.
         * @param {Transfer} transfer transfer to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTransfer(accessId: string, accountId: string, transfer: Transfer, options: any &#x3D; {}): FetchArgs {
            // verify required parameter &#x27;accessId&#x27; is not null or undefined
            if (accessId &#x3D;&#x3D;&#x3D; null || accessId &#x3D;&#x3D;&#x3D; undefined) {
                throw new RequiredError(&#x27;accessId&#x27;,&#x27;Required parameter accessId was null or undefined when calling postTransfer.&#x27;);
            }
            // verify required parameter &#x27;accountId&#x27; is not null or undefined
            if (accountId &#x3D;&#x3D;&#x3D; null || accountId &#x3D;&#x3D;&#x3D; undefined) {
                throw new RequiredError(&#x27;accountId&#x27;,&#x27;Required parameter accountId was null or undefined when calling postTransfer.&#x27;);
            }
            // verify required parameter &#x27;transfer&#x27; is not null or undefined
            if (transfer &#x3D;&#x3D;&#x3D; null || transfer &#x3D;&#x3D;&#x3D; undefined) {
                throw new RequiredError(&#x27;transfer&#x27;,&#x27;Required parameter transfer was null or undefined when calling postTransfer.&#x27;);
            }
            const localVarPath &#x3D; &#x60;/accesses/{accessId}/accounts/{accountId}/transfers&#x60;
                .replace(&#x60;{${&quot;accessId&quot;}}&#x60;, encodeURIComponent(String(accessId)))
                .replace(&#x60;{${&quot;accountId&quot;}}&#x60;, encodeURIComponent(String(accountId)));
            const localVarUrlObj &#x3D; url.parse(localVarPath, true);
            const localVarRequestOptions &#x3D; Object.assign({ method: &#x27;POST&#x27; }, options);
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration &amp;&amp; configuration.accessToken) {
				const localVarAccessTokenValue &#x3D; typeof configuration.accessToken &#x3D;&#x3D;&#x3D; &#x27;function&#x27;
					? configuration.accessToken(&quot;oauth2&quot;, [])
					: configuration.accessToken;
                localVarHeaderParameter[&quot;Authorization&quot;] &#x3D; &quot;Bearer &quot; + localVarAccessTokenValue;
            }

            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            localVarUrlObj.query &#x3D; Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers &#x3D; Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization &#x3D; (&lt;any&gt;&quot;Transfer&quot; !&#x3D;&#x3D; &quot;string&quot;) || localVarRequestOptions.headers[&#x27;Content-Type&#x27;] &#x3D;&#x3D;&#x3D; &#x27;application/json&#x27;;
            localVarRequestOptions.body &#x3D;  needsSerialization ? JSON.stringify(transfer || {}) : (transfer || &quot;&quot;);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
}</code>
                        </td>
                    </tr>

                <tr>
                    <td class="col-md-4">
                        <div class="io-description"><p>TransferApi - fetch parameter creator</p>
</div>
                    </td>
                </tr>

            </tbody>
        </table>
        <table class="table table-sm table-bordered">
            <tbody>
                <tr>
                    <td class="col-md-4">
                        <a name="TransferApiFp"></a>
                        <span class="name">
                            <b>
                            TransferApiFp
                            </b>
                            <a href="#TransferApiFp"><span class="icon ion-ios-link"></span></a>
                        </span>
                    </td>
                </tr>
                <tr>
                    <td class="col-md-4">
                        <code>TransferApiFp:     <code></code>
</code>
                    </td>
                </tr>
                    <tr>
                        <td class="col-md-4">
                            <i>Default value : </i><code>function(configuration?: Configuration) {
    return {
        /**
         * The transfer represents a money  transfer from the account identified by its id to another bank account.  **Please note:** Exception from the norm. This POST request will not return  the two header fields X-Id and Location. Also, the returned JSON document  does not represent the transfer entity, but a temporary placeholder.  The transfer is processed asynchronous and needs a message URL zu be configured  to report back the tan challenge and when it is finished.
         * @summary Create a new transfer
         * @param {string} accessId 
         * @param {string} accountId The **id** for the account.
         * @param {Transfer} transfer transfer to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTransfer(accessId: string, accountId: string, transfer: Transfer, options?: any): (fetch?: FetchAPI, basePath?: string) &#x3D;&gt; Promise&lt;TransferTask&gt; {
            const localVarFetchArgs &#x3D; TransferApiFetchParamCreator(configuration).postTransfer(accessId, accountId, transfer, options);
            return (fetch: FetchAPI &#x3D; portableFetch, basePath: string &#x3D; BASE_PATH) &#x3D;&gt; {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) &#x3D;&gt; {
                    if (response.status &gt;&#x3D; 200 &amp;&amp; response.status &lt; 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
}</code>
                        </td>
                    </tr>

                <tr>
                    <td class="col-md-4">
                        <div class="io-description"><p>TransferApi - functional programming interface</p>
</div>
                    </td>
                </tr>

            </tbody>
        </table>
</section>



                   </div><div class="search-results">
    <div class="has-results">
        <h1 class="search-results-title"><span class='search-results-count'></span> result-matching "<span class='search-query'></span>"</h1>
        <ul class="search-results-list"></ul>
    </div>
    <div class="no-results">
        <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
    </div>
</div>
</div>
               <!-- END CONTENT -->
           </div>
       </div>

       <script>
            var COMPODOC_CURRENT_PAGE_DEPTH = 1;
            var COMPODOC_CURRENT_PAGE_CONTEXT = 'miscellaneous-variables';
            var COMPODOC_CURRENT_PAGE_URL = 'variables.html';
       </script>

       <script src="../js/libs/custom-elements.min.js"></script>
       <script src="../js/libs/lit-html.js"></script>
       <!-- Required to polyfill modern browsers as code is ES5 for IE... -->
       <script src="../js/libs/custom-elements-es5-adapter.js" charset="utf-8" defer></script>
       <script src="../js/menu-wc.js" defer></script>

       <script src="../js/libs/bootstrap-native.js"></script>

       <script src="../js/libs/es6-shim.min.js"></script>
       <script src="../js/libs/EventDispatcher.js"></script>
       <script src="../js/libs/promise.min.js"></script>
       <script src="../js/libs/zepto.min.js"></script>

       <script src="../js/compodoc.js"></script>

       <script src="../js/tabs.js"></script>
       <script src="../js/menu.js"></script>
       <script src="../js/libs/clipboard.min.js"></script>
       <script src="../js/libs/prism.js"></script>
       <script src="../js/sourceCode.js"></script>
          <script src="../js/search/search.js"></script>
          <script src="../js/search/lunr.min.js"></script>
          <script src="../js/search/search-lunr.js"></script>
          <script src="../js/search/search_index.js"></script>
       <script src="../js/lazy-load-graphs.js"></script>


    </body>
</html>
